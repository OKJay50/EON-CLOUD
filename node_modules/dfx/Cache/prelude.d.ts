import { DiscordREST } from "dfx";
import { Gateway } from "dfx/gateway";
import { Discord, Effect, Stream } from "dfx/_common";
import { CacheDriver, CacheMissError, CacheOp, ParentCacheDriver, ParentCacheOp } from "../Cache.js";
export interface OptsWithParentOptions<E, A> {
    id: (a: A) => string;
    fromParent: Stream<never, E, [parentId: string, resources: A[]]>;
    create: Stream<never, E, [parentId: string, resource: A]>;
    update: Stream<never, E, [parentId: string, resource: A]>;
    remove: Stream<never, E, [parentId: string, id: string]>;
    parentRemove: Stream<never, E, string>;
}
export declare const opsWithParent: <E, T>({ id, fromParent, create, update, remove, parentRemove, }: OptsWithParentOptions<E, T>) => Stream<never, E, ParentCacheOp<T>>;
export interface OpsOptions<E, A> {
    id: (a: A) => string;
    create: Stream<never, E, A>;
    update: Stream<never, E, A>;
    remove: Stream<never, E, string>;
}
export declare const ops: <E, T>({ id, create, update, remove }: OpsOptions<E, T>) => Stream<never, E, CacheOp<T>>;
export declare const guilds: <RM, EM, E>(makeDriver: Effect<RM, EM, CacheDriver<E, Discord.Guild>>) => Effect<DiscordREST | Gateway.DiscordGateway | RM, EM, {
    get: (id: string) => Effect<never, import("../DiscordREST.js").DiscordRESTError | import("@effect-http/client").ResponseDecodeError | E, Discord.Guild>;
    run: Effect<never, E, void>;
    size: Effect<never, E, number>;
    set: (resourceId: string, resource: Discord.Guild) => Effect<never, E, void>;
    delete: (resourceId: string) => Effect<never, E, void>;
    refreshTTL: (resourceId: string) => Effect<never, E, void>;
}>;
export declare const channels: <RM, EM, E>(makeDriver: Effect<RM, EM, ParentCacheDriver<E, Discord.Channel>>) => Effect<DiscordREST | Gateway.DiscordGateway | RM, EM, {
    get: (parentId: string, id: string) => Effect<never, import("../DiscordREST.js").DiscordRESTError | import("@effect-http/client").ResponseDecodeError | E, Discord.Channel>;
    getForParent: (parentId: string) => Effect<never, import("../DiscordREST.js").DiscordRESTError | import("@effect-http/client").ResponseDecodeError | E, ReadonlyMap<string, Discord.Channel>>;
    run: Effect<never, E, void>;
    size: Effect<never, E, number>;
    sizeForParent: (parentId: string) => Effect<never, E, number>;
    set: (parentId: string, resourceId: string, resource: Discord.Channel) => Effect<never, E, void>;
    delete: (parentId: string, resourceId: string) => Effect<never, E, void>;
    parentDelete: (parentId: string) => Effect<never, E, void>;
    refreshTTL: (parentId: string, resourceId: string) => Effect<never, E, void>;
}>;
export declare const roles: <RM, EM, E>(makeDriver: Effect<RM, EM, ParentCacheDriver<E, Discord.Role>>) => Effect<DiscordREST | Gateway.DiscordGateway | RM, EM, {
    get: (parentId: string, id: string) => Effect<never, CacheMissError | E, Discord.Role>;
    getForParent: (parentId: string) => Effect<never, import("../DiscordREST.js").DiscordRESTError | import("@effect-http/client").ResponseDecodeError | E, ReadonlyMap<string, Discord.Role>>;
    run: Effect<never, E, void>;
    size: Effect<never, E, number>;
    sizeForParent: (parentId: string) => Effect<never, E, number>;
    set: (parentId: string, resourceId: string, resource: Discord.Role) => Effect<never, E, void>;
    delete: (parentId: string, resourceId: string) => Effect<never, E, void>;
    parentDelete: (parentId: string) => Effect<never, E, void>;
    refreshTTL: (parentId: string, resourceId: string) => Effect<never, E, void>;
}>;
