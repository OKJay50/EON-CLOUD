import * as tsplus_module_1 from "@effect/data/Duration";
import * as tsplus_module_2 from "@effect/io/Effect";
import * as tsplus_module_3 from "@effect/data/Option";
import * as tsplus_module_4 from "@effect/data/Chunk";
import { createDriver, createParentDriver } from "./driver.js";
const make = ({ ttl, resolution = tsplus_module_1.minutes(1), strategy = "usage", }) => {
    const additionalMilliseconds = (Math.floor(ttl.millis / resolution.millis) + 1) * resolution.millis;
    const items = new Map();
    const buckets = [];
    const refreshTTL = (item) => {
        const now = Date.now();
        const remainder = now % resolution.millis;
        const expires = now - remainder + additionalMilliseconds;
        let currentBucket = buckets[buckets.length - 1];
        if ((currentBucket?.expires || 0) < expires) {
            currentBucket = {
                expires,
                items: [],
            };
            buckets.push(currentBucket);
        }
        currentBucket.items.push(item);
    };
    const sweep = () => {
        const now = Date.now();
        const remainder = now % resolution.millis;
        const currentExpires = now - remainder;
        while (buckets.length && buckets[0].expires <= currentExpires) {
            buckets.shift();
        }
        if (global.gc) {
            global.gc();
        }
    };
    const getSync = (resourceId) => {
        const ref = items.get(resourceId);
        if (!ref)
            return undefined;
        const item = ref.deref();
        if (!item) {
            items.delete(resourceId);
            return undefined;
        }
        if (strategy !== "expiry") {
            refreshTTL(item);
        }
        return item.resource;
    };
    return createDriver({
        size: tsplus_module_2.sync(() => items.size),
        get: resourceId => tsplus_module_2.sync(() => tsplus_module_3.fromNullable(getSync(resourceId))),
        refreshTTL: id => tsplus_module_2.sync(() => {
            getSync(id);
        }),
        set: (resourceId, resource) => tsplus_module_2.sync(() => {
            const item = items.get(resourceId)?.deref();
            if (item && strategy !== "activity") {
                item.resource = resource;
            }
            else {
                const newItem = { resource };
                refreshTTL(newItem);
                items.set(resourceId, new WeakRef(newItem));
            }
        }),
        delete: resourceId => tsplus_module_2.sync(() => {
            items.delete(resourceId);
        }),
        run: tsplus_module_2.forever(tsplus_module_2.delay(tsplus_module_2.sync(sweep), tsplus_module_1.times(0.5)(resolution))),
    });
};
export const create = (opts) => tsplus_module_2.sync(() => make(opts));
export const createWithParent = (opts) => tsplus_module_2.sync(() => {
    const store = make(opts);
    const parentIds = new Map();
    return createParentDriver({
        size: store.size,
        sizeForParent: parentId => tsplus_module_2.sync(() => parentIds.get(parentId)?.size ?? 0),
        refreshTTL: (_, id) => store.refreshTTL(id),
        get: (_, id) => store.get(id),
        getForParent: parentId => (() => {
            const ids = parentIds.get(parentId);
            if (!ids)
                return tsplus_module_3.none();
            const toGet = [];
            ids.forEach(id => {
                toGet.push(tsplus_module_2.map(store.get(id), item => {
                    if (item._tag === "None") {
                        parentIds.delete(id);
                    }
                    return [id, item];
                }));
            });
            return tsplus_module_2.map(tsplus_module_2.collectAllPar(toGet), results => {
                const map = tsplus_module_4.reduce(results, new Map(), (map, [id, a]) => a._tag === "Some" ? map.set(id, a.value) : map);
                return tsplus_module_3.some(map);
            });
        })(),
        set: (parentId, resourceId, resource) => tsplus_module_2.map(store.set(resourceId, resource), () => {
            if (!parentIds.has(parentId)) {
                parentIds.set(parentId, new Set());
            }
            parentIds.get(parentId).add(resourceId);
        }),
        delete: (parentId, resourceId) => tsplus_module_2.map(store.delete(resourceId), () => {
            parentIds.get(parentId)?.delete(resourceId);
        }),
        parentDelete: parentId => (() => {
            const ids = parentIds.get(parentId);
            parentIds.delete(parentId);
            const effects = [];
            if (ids) {
                ids.forEach(id => {
                    effects.push(store.delete(id));
                });
            }
            return tsplus_module_2.map(tsplus_module_2.collectAllParDiscard(effects), () => void 0);
        })(),
        run: store.run,
    });
});
//# sourceMappingURL=memoryTTL.js.map