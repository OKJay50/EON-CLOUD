import * as tsplus_module_1 from "@effect/io/Effect";
import * as tsplus_module_2 from "@effect/data/Function";
import * as tsplus_module_3 from "dfx";
import * as tsplus_module_4 from "dfx/gateway";
import * as Http from "@effect-http/client";
import { handlers } from "./handlers.js";
import { InteractionContext } from "./index.js";
import { splitDefinitions } from "./utils.js";
/**
 * @tsplus pipeable dfx/InteractionBuilder runGateway
 */
export const run = (postHandler, { sync = true } = {}) => (ix) => (() => {
    const { GlobalApplicationCommand, GuildApplicationCommand } = splitDefinitions(ix.definitions);
    return tsplus_module_1.flatMap(tsplus_module_4.Gateway.DiscordGateway, gateway => tsplus_module_1.flatMap(tsplus_module_3.DiscordREST, rest => tsplus_module_1.flatMap(tsplus_module_1.flatMap(rest.getCurrentBotApplicationInformation(), a => a.json), application => {
        const globalSync = rest.bulkOverwriteGlobalApplicationCommands(application.id, { body: Http.body.json(GlobalApplicationCommand.map(a => a.command)) });
        const guildSync = GuildApplicationCommand.length
            ? gateway.handleDispatch("GUILD_CREATE", a => rest.bulkOverwriteGuildApplicationCommands(application.id, a.id, GuildApplicationCommand.map(a => a.command)))
            : tsplus_module_1.unit();
        const handle = handlers(ix.definitions);
        const run = gateway.handleDispatch("INTERACTION_CREATE", i => tsplus_module_1.provideService(tsplus_module_2.pipe(tsplus_module_1.tap(handle[i.type](i), r => rest.createInteractionResponse(i.id, i.token, r)), postHandler), InteractionContext, i));
        return tsplus_module_1.map(sync
            ? tsplus_module_1.zipPar(tsplus_module_1.zipPar(tsplus_module_1.zipPar(run, globalSync), guildSync), gateway.run)
            : run, () => void 0);
    })));
})();
//# sourceMappingURL=gateway.js.map