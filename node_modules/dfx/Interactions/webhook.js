import * as tsplus_module_1 from "@effect/data/Option";
import * as tsplus_module_2 from "@effect/data/Either";
import * as tsplus_module_3 from "@effect/io/Config/Secret";
import * as tsplus_module_4 from "dfx/_common";
import * as tsplus_module_5 from "@effect/io/Layer";
import * as tsplus_module_6 from "@effect/data/Function";
import * as tsplus_module_7 from "@effect/io/Effect";
import Nacl from "tweetnacl";
import { handlers } from "./handlers.js";
import { InteractionContext } from "./index.js";
import { fromHex } from "./utils.js";
export class BadWebhookSignature {
    _tag = "BadWebhookSignature";
}
const checkSignature = (publicKey, headers, body) => tsplus_module_2.asUnit(tsplus_module_1.toEither(() => new BadWebhookSignature())(tsplus_module_1.filter(a => {
    const enc = new TextEncoder();
    return Nacl.sign.detached.verify(enc.encode(a.timestamp + body), fromHex(`${a.signature}`), publicKey);
})(tsplus_module_1.struct({
    signature: tsplus_module_1.fromNullable(headers["x-signature-ed25519"]),
    timestamp: tsplus_module_1.fromNullable(headers["x-signature-timestamp"]),
}))));
const makeConfig = ({ applicationId, publicKey }) => ({
    applicationId,
    publicKey: fromHex(tsplus_module_3.value(publicKey)),
});
export const WebhookConfig = tsplus_module_4.Tag();
export const makeConfigLayer = tsplus_module_6.flow(makeConfig, _ => tsplus_module_5.succeed(WebhookConfig, _));
export const makeFromConfig = (a) => tsplus_module_7.toLayer(tsplus_module_7.map(tsplus_module_7.config(a), makeConfig), WebhookConfig);
export class WebhookParseError {
    reason;
    _tag = "WebhookParseError";
    constructor(reason) {
        this.reason = reason;
    }
}
const fromHeadersAndBody = (headers, body) => tsplus_module_7.flatMap(WebhookConfig, ({ publicKey }) => tsplus_module_7.flatMap(tsplus_module_7.fromEither(checkSignature(publicKey, headers, body)), () => tsplus_module_7.tryCatch(() => JSON.parse(body), reason => new WebhookParseError(reason))));
const run = (definitions) => {
    const handler = handlers(definitions);
    return (headers, body) => tsplus_module_7.flatMap(fromHeadersAndBody(headers, body), interaction => tsplus_module_7.provideService(handler[interaction.type](interaction), InteractionContext, interaction));
};
/**
 * @tsplus getter dfx/InteractionBuilder webhookHandler
 */
export const makeHandler = (ix) => {
    const handle = run(ix.definitions);
    return ({ headers, body, success, error, }) => tsplus_module_7.catchAllCause(tsplus_module_7.flatMap(handle(headers, body), success), error);
};
/**
 * @tsplus getter dfx/InteractionBuilder simpleWebhookHandler
 */
export const makeSimpleHandler = (ix) => {
    const handle = run(ix.definitions);
    return ({ headers, body }) => handle(headers, body);
};
//# sourceMappingURL=webhook.js.map