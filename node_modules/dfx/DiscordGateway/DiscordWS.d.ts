/// <reference types="ws" />
import { Discord, Effect } from "dfx/_common";
import { WS } from "dfx/gateway";
import WebSocket from "isomorphic-ws";
export type Message = Discord.GatewayPayload | WS.Reconnect;
export interface OpenOpts {
    url?: string;
    version?: number;
    encoding?: DiscordWSCodec;
    outbound: Effect<never, never, Message>;
}
export interface DiscordWSCodec {
    type: "json" | "etf";
    encode: (p: Discord.GatewayPayload) => string;
    decode: (p: WebSocket.Data) => Discord.GatewayPayload;
}
export declare const DiscordWSCodec: import("@effect/data/Context").Tag<DiscordWSCodec, DiscordWSCodec>;
export declare const LiveJsonDiscordWSCodec: import("@effect-http/client/_common").Layer<never, never, DiscordWSCodec>;
declare const make: import("@effect-http/client/_common").Effect<import("../Log.js").Log | import("./WS.js").WS | DiscordWSCodec, never, {
    readonly connect: ({ url, version, outbound, }: OpenOpts) => import("@effect-http/client/_common").Effect<never, never, {
        readonly run: import("@effect-http/client/_common").Effect<never, never, never>;
        readonly take: import("@effect-http/client/_common").Effect<never, never, import("../types.js").GatewayPayload<any>>;
        readonly setUrl: (url: string) => import("@effect-http/client/_common").Effect<never, never, void>;
    }>;
}>;
export interface DiscordWS extends Effect.Success<typeof make> {
}
export declare const DiscordWS: import("@effect/data/Context").Tag<DiscordWS, DiscordWS>;
export declare const LiveDiscordWS: import("@effect-http/client/_common").Layer<import("../Log.js").Log | DiscordWSCodec, never, DiscordWS>;
export {};
