import * as tsplus_module_1 from "@effect/io/Effect";
import * as tsplus_module_2 from "@effect/io/Ref";
import * as tsplus_module_3 from "@effect/io/Schedule";
import * as tsplus_module_4 from "@effect/io/Queue";
import * as tsplus_module_5 from "dfx";
import * as tsplus_module_6 from "dfx/_common";
import WebSocket from "isomorphic-ws";
export const Reconnect = Symbol();
export class WebSocketError {
    reason;
    _tag = "WebSocketError";
    constructor(reason) {
        this.reason = reason;
    }
}
export class WebSocketCloseError {
    code;
    reason;
    _tag = "WebSocketCloseError";
    constructor(code, reason) {
        this.code = code;
        this.reason = reason;
    }
}
const socket = (urlRef) => tsplus_module_1.acquireRelease(tsplus_module_1.flatMap(tsplus_module_2.get(urlRef), url => {
    const ws = new WebSocket(url);
    return tsplus_module_1.map(tsplus_module_1.async(resume => {
        ws.addEventListener("open", () => resume(tsplus_module_1.unit()), {
            once: true,
        });
    }), () => ws);
}), ws => tsplus_module_1.sync(() => {
    ;
    ws.removeAllListeners?.();
    ws.close();
}));
const offer = (ws, queue) => tsplus_module_1.async(resume => {
    ws.addEventListener("message", message => {
        tsplus_module_1.runFork(queue.offer(message.data));
    });
    ws.addEventListener("error", cause => {
        resume(tsplus_module_1.fail(new WebSocketError(cause)));
    });
    ws.addEventListener("close", e => {
        resume(tsplus_module_1.fail(new WebSocketCloseError(e.code, e.reason)));
    });
});
const send = (ws, take, log) => tsplus_module_1.forever(tsplus_module_1.tap(tsplus_module_1.tap(take, data => log.debug("WS", "send", data)), (data) => {
    if (data === Reconnect) {
        return tsplus_module_1.failSync(() => {
            ws.close(1012, "reconnecting");
            return new WebSocketCloseError(1012, "reconnecting");
        });
    }
    return tsplus_module_1.sync(() => {
        ws.send(data);
    });
}));
const make = tsplus_module_1.map(tsplus_module_5.Log.Log, log => {
    const connect = (url, takeOutbound) => tsplus_module_1.map(tsplus_module_4.unbounded(), queue => {
        const run = tsplus_module_1.scoped(tsplus_module_1.retry(tsplus_module_1.flatMap(socket(url), ws => tsplus_module_1.zipParLeft(offer(ws, queue), send(ws, takeOutbound, log))), tsplus_module_3.recurWhile(e => e._tag === "WebSocketCloseError" && e.code === 1012)));
        return { run, take: queue.take() };
    });
    return { connect };
});
export const WS = tsplus_module_6.Tag();
export const LiveWS = tsplus_module_1.toLayer(make, WS);
//# sourceMappingURL=WS.js.map