import * as tsplus_module_1 from "dfx/_common";
import * as tsplus_module_2 from "@effect/io/Effect";
import * as tsplus_module_3 from "@effect/data/Chunk";
import * as tsplus_module_4 from "@effect/io/Deferred";
import * as tsplus_module_5 from "@effect/io/Ref";
import * as tsplus_module_6 from "@effect/data/Duration";
import * as tsplus_module_7 from "@effect/data/Option";
import * as tsplus_module_8 from "dfx";
import * as tsplus_module_9 from "@effect/io/Layer";
import { millis } from "@effect/data/Duration";
import { ShardStore } from "./ShardStore.js";
import { LiveShard, Shard } from "./Shard.js";
import { LiveRateLimiter } from "dfx";
const make = tsplus_module_2.flatMap(ShardStore, store => tsplus_module_2.flatMap(tsplus_module_8.DiscordREST, rest => tsplus_module_2.flatMap(tsplus_module_8.DiscordConfig.DiscordConfig, ({ gateway: config }) => tsplus_module_2.flatMap(tsplus_module_8.RateLimiter, limiter => tsplus_module_2.flatMap(Shard, shard => {
    const takeConfig = (totalCount) => tsplus_module_2.map(tsplus_module_5.make(0), currentCount => {
        const claimId = (sharderCount) => tsplus_module_2.flatMap(store
            .claimId({
            totalCount,
            sharderCount,
        }), a => tsplus_module_7.match(a, () => tsplus_module_2.delay(claimId(sharderCount), tsplus_module_6.minutes(3)), id => tsplus_module_2.succeed(id)));
        return tsplus_module_2.map(tsplus_module_2.flatMap(tsplus_module_5.getAndUpdate(currentCount, _ => _ + 1), claimId), id => ({ id, totalCount }));
    });
    return tsplus_module_2.map(tsplus_module_2.catchAll(tsplus_module_2.flatMap(rest
        .getGatewayBot(), r => r.json), () => tsplus_module_2.succeed({
        url: "wss://gateway.discord.gg/",
        shards: 1,
        session_start_limit: {
            total: 0,
            remaining: 0,
            reset_after: 0,
            max_concurrency: 1,
        },
    })), gateway => {
        const run = (hub) => tsplus_module_2.flatMap(tsplus_module_4.make(), deferred => tsplus_module_2.flatMap(takeConfig(config.shardCount ?? gateway.shards), take => {
            const spawner = tsplus_module_2.forever(tsplus_module_2.flatMap(tsplus_module_2.flatMap(tsplus_module_2.tap(tsplus_module_2.map(take, config => ({
                ...config,
                url: gateway.url,
                concurrency: gateway.session_start_limit.max_concurrency,
            })), ({ id, concurrency }) => limiter.maybeWait(`dfx.sharder.${id % concurrency}`, millis(config.identifyRateLimit[0]), config.identifyRateLimit[1])), c => shard.connect([c.id, c.totalCount], hub)), shard => tsplus_module_2.fork(tsplus_module_2.catchAllCause(shard.run, _ => tsplus_module_4.failCause(deferred, _)))));
            const spawners = tsplus_module_3.map(tsplus_module_3.range(1, gateway.session_start_limit.max_concurrency), () => spawner);
            return tsplus_module_2.zipParLeft(tsplus_module_2.collectAllParDiscard(spawners), tsplus_module_1.deferredAwait(deferred));
        }));
        return { run };
    });
})))));
export const Sharder = tsplus_module_1.Tag();
export const LiveSharder = tsplus_module_9.provide(tsplus_module_2.toLayer(make, Sharder))((tsplus_module_9.merge(LiveShard)(LiveRateLimiter)));
//# sourceMappingURL=Sharder.js.map