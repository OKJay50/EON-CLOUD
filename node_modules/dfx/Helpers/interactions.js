import * as tsplus_module_1 from "dfx/_common";
import * as tsplus_module_2 from "@effect/data/Function";
import * as tsplus_module_3 from "@effect/data/Option";
import * as tsplus_module_4 from "@effect/data/HashMap";
import { Product } from "@effect/data/Option";
import * as Arr from "@effect/data/ReadonlyArray";
/**
 * Maybe find a sub-command within the interaction options.
 */
export const allSubCommands = (interaction) => tsplus_module_2.pipe(optionsWithNested(interaction), Arr.filter(o => o.type === 1 /* Discord.ApplicationCommandOptionType.SUB_COMMAND */));
/**
 * Maybe find a sub-command within the interaction options.
 */
export const findSubCommand = (name) => (interaction) => tsplus_module_2.pipe(optionsWithNested(interaction), Arr.findFirst(o => o.type === 1 /* Discord.ApplicationCommandOptionType.SUB_COMMAND */ &&
    o.name === name));
/**
 * If the sub-command exists return `true`, else `false`.
 */
export const isSubCommand = (name) => tsplus_module_2.flow(findSubCommand(name), o => tsplus_module_3.isSome(o));
/**
 * Maybe get the options for a sub-command
 */
export const subCommandOptions = (name) => tsplus_module_2.flow(findSubCommand(name), o => tsplus_module_3.flatMapNullable(o, o => o.options));
/**
 * A lens for accessing nested options in a interaction.
 */
export const optionsWithNested = (data) => {
    const optsFromOption = (opt) => tsplus_module_3.match(tsplus_module_3.map(tsplus_module_3.fromNullable(opt.options), opts => [...opts, ...opts.flatMap(optsFromOption)]), () => [], tsplus_module_2.identity);
    return tsplus_module_3.getOrElse(tsplus_module_3.map(tsplus_module_3.fromNullable(data.options), opts => [...opts, ...opts.flatMap(optsFromOption)]), () => []);
};
/**
 * Return the interaction options as a name / value map.
 */
export const transformOptions = (options) => options.reduce((map, option) => tsplus_module_4.set(map, option.name, option.value), tsplus_module_4.empty());
/**
 * Return the interaction options as a name / value map.
 */
export const optionsMap = tsplus_module_2.flow(optionsWithNested, transformOptions);
/**
 * Try find a matching option from the interaction.
 */
export const getOption = (name) => tsplus_module_2.flow(optionsWithNested, Arr.findFirst(o => o.name === name));
/**
 * Try find a matching option from the interaction.
 */
export const focusedOption = tsplus_module_2.flow(optionsWithNested, Arr.findFirst(o => o.focused === true));
/**
 * Try find a matching option value from the interaction.
 */
export const optionValue = (name) => tsplus_module_2.flow(getOption(name), o => tsplus_module_3.flatMapNullable(o, o => o.value));
/**
 * Try extract resolved data
 */
export const resolved = (data) => tsplus_module_3.flatMapNullable(tsplus_module_3.fromNullable(data.data), a => a.resolved);
/**
 * Try find a matching option value from the interaction.
 */
export const resolveOptionValue = (name, f) => (a) => tsplus_module_3.flatMap(tsplus_module_3.fromNullable(a.data), data => tsplus_module_3.flatMap(tsplus_module_3.flatMapNullable(getOption(name)(data), ({ value }) => value), id => tsplus_module_3.flatMap(resolved(a), r => tsplus_module_3.fromNullable(f(id, r)))));
/**
 * Try find matching option values from the interaction.
 */
export const resolveValues = (f) => (a) => tsplus_module_3.flatMap(tsplus_module_3.flatMapNullable(tsplus_module_3.fromNullable(a.data), a => a.values), values => tsplus_module_3.flatMap(resolved(a), r => Product.productAll(values.map(a => tsplus_module_3.fromNullable(f(a, r))))));
const extractComponents = (c) => {
    if ("components" in c) {
        return [...c.components, ...c.components.flatMap(extractComponents)];
    }
    return [];
};
/**
 * A lens for accessing the components in a interaction.
 */
export const components = (a) => [
    ...a.components,
    ...a.components.flatMap(extractComponents),
];
/**
 * A lens for accessing the components in a interaction.
 */
export const componentsWithValue = tsplus_module_2.flow(components, Arr.filter(c => "value" in c && c.value !== undefined));
/**
 * Return the interaction components as an id / value map.
 */
export const transformComponents = (options) => options.reduce((map, c) => (c.custom_id ? tsplus_module_4.set(map, c.custom_id, c.value) : map), tsplus_module_4.empty());
/**
 * Return the interaction components as an id / value map.
 */
export const componentsMap = tsplus_module_2.flow(components, transformComponents);
/**
 * Try find a matching component from the interaction.
 */
export const getComponent = (id) => tsplus_module_2.flow(components, Arr.findFirst(o => o.custom_id === id));
/**
 * Try find a matching component value from the interaction.
 */
export const componentValue = (id) => tsplus_module_2.flow(getComponent(id), o => tsplus_module_3.flatMapNullable(o, o => o.value));
export const response = (r) => r;
//# sourceMappingURL=interactions.js.map