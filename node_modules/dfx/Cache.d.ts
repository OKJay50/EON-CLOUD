import { Stream, Effect } from "dfx/_common";
import { CacheDriver, ParentCacheDriver } from "./Cache/driver.js";
export * from "./Cache/driver.js";
export { create as memoryDriver, createWithParent as memoryParentDriver, } from "./Cache/memory.js";
export { create as memoryTTLDriver, createWithParent as memoryTTLParentDriver, } from "./Cache/memoryTTL.js";
export type ParentCacheOp<T> = {
    op: "create";
    parentId: string;
    resourceId: string;
    resource: T;
} | {
    op: "update";
    parentId: string;
    resourceId: string;
    resource: T;
} | {
    op: "delete";
    parentId: string;
    resourceId: string;
} | {
    op: "parentDelete";
    parentId: string;
};
export type CacheOp<T> = {
    op: "create";
    resourceId: string;
    resource: T;
} | {
    op: "update";
    resourceId: string;
    resource: T;
} | {
    op: "delete";
    resourceId: string;
};
export declare const makeWithParent: <EOps, EDriver, EMiss, EPMiss, A>({ driver, ops, onMiss, onParentMiss, }: {
    driver: ParentCacheDriver<EDriver, A>;
    ops?: import("@effect-http/client/_common").Stream<never, EOps, ParentCacheOp<A>> | undefined;
    onMiss: (parentId: string, id: string) => import("@effect-http/client/_common").Effect<never, EMiss, A>;
    onParentMiss: (parentId: string) => import("@effect-http/client/_common").Effect<never, EPMiss, [id: string, resource: A][]>;
}) => {
    get: (parentId: string, id: string) => import("@effect-http/client/_common").Effect<never, EDriver | EMiss, A>;
    getForParent: (parentId: string) => import("@effect-http/client/_common").Effect<never, EDriver | EPMiss, ReadonlyMap<string, A>>;
    run: import("@effect-http/client/_common").Effect<never, EOps | EDriver, void>;
    size: import("@effect-http/client/_common").Effect<never, EDriver, number>;
    sizeForParent: (parentId: string) => import("@effect-http/client/_common").Effect<never, EDriver, number>;
    set: (parentId: string, resourceId: string, resource: A) => import("@effect-http/client/_common").Effect<never, EDriver, void>;
    delete: (parentId: string, resourceId: string) => import("@effect-http/client/_common").Effect<never, EDriver, void>;
    parentDelete: (parentId: string) => import("@effect-http/client/_common").Effect<never, EDriver, void>;
    refreshTTL: (parentId: string, resourceId: string) => import("@effect-http/client/_common").Effect<never, EDriver, void>;
};
export declare const make: <EOps, EDriver, EMiss, A>({ driver, ops, onMiss, }: {
    driver: CacheDriver<EDriver, A>;
    ops?: import("@effect-http/client/_common").Stream<never, EOps, CacheOp<A>> | undefined;
    onMiss: (id: string) => import("@effect-http/client/_common").Effect<never, EMiss, A>;
}) => {
    get: (id: string) => import("@effect-http/client/_common").Effect<never, EDriver | EMiss, A>;
    run: import("@effect-http/client/_common").Effect<never, EOps | EDriver, void>;
    size: import("@effect-http/client/_common").Effect<never, EDriver, number>;
    set: (resourceId: string, resource: A) => import("@effect-http/client/_common").Effect<never, EDriver, void>;
    delete: (resourceId: string) => import("@effect-http/client/_common").Effect<never, EDriver, void>;
    refreshTTL: (resourceId: string) => import("@effect-http/client/_common").Effect<never, EDriver, void>;
};
export declare class CacheMissError {
    readonly cacheName: string;
    readonly id: string;
    readonly _tag = "CacheMissError";
    constructor(cacheName: string, id: string);
}
