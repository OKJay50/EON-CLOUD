import * as tsplus_module_1 from "@effect-http/client/Request";
import * as tsplus_module_2 from "dfx/_common";
import * as tsplus_module_3 from "@effect/io/Effect";
import * as tsplus_module_4 from "@effect/data/Duration";
import * as tsplus_module_5 from "@effect/data/Option";
import * as tsplus_module_6 from "@effect/io/Config/Secret";
import * as tsplus_module_7 from "@effect-http/client/Request/Executor";
import * as tsplus_module_8 from "@effect/data/HashSet";
import * as tsplus_module_9 from "@effect/io/Ref";
import * as tsplus_module_10 from "dfx";
import * as tsplus_module_11 from "@effect/io/Layer";
import * as Http from "@effect-http/client";
import { millis } from "@effect/data/Duration";
import { rateLimitFromHeaders, retryAfter, routeFromConfig, } from "./DiscordREST/utils.js";
import Pkg from "./package.json" assert { type: "json" };
import { LiveRateLimiter } from "./RateLimit.js";
export class DiscordRESTError {
    error;
    _tag = "DiscordRESTError";
    constructor(error) {
        this.error = error;
    }
}
const make = tsplus_module_3.flatMap(tsplus_module_10.DiscordConfig.DiscordConfig, ({ token, rest }) => tsplus_module_3.flatMap(Http.HttpRequestExecutor, http => tsplus_module_3.flatMap(tsplus_module_10.Log.Log, log => tsplus_module_3.flatMap(tsplus_module_10.RateLimitStore, store => tsplus_module_3.flatMap(tsplus_module_10.RateLimiter, ({ maybeWait }) => {
    const globalRateLimit = maybeWait("dfx.rest.global", rest.globalRateLimit.window, rest.globalRateLimit.limit);
    return tsplus_module_3.map(tsplus_module_9.make(tsplus_module_8.empty()), badRoutesRef => {
        const addBadRoute = (route) => tsplus_module_3.collectAllParDiscard([
            log.info("DiscordREST", "addBadRoute", route),
            tsplus_module_9.update(badRoutesRef, s => tsplus_module_8.add(s, route)),
            store.incrementCounter("dfx.rest.invalid", tsplus_module_4.minutes(10).millis, 10000),
        ]);
        const isBadRoute = (route) => tsplus_module_3.map(tsplus_module_9.get(badRoutesRef), s => tsplus_module_8.has(s, route));
        const removeBadRoute = (route) => tsplus_module_9.update(badRoutesRef, s => tsplus_module_8.remove(s, route));
        const invalidRateLimit = (route) => tsplus_module_3.asUnit(tsplus_module_3.tap(isBadRoute(route), invalid => invalid
            ? maybeWait("dfx.rest.invalid", tsplus_module_4.minutes(10), 10000)
            : tsplus_module_3.unit()));
        // Request rate limiting
        const requestRateLimit = (path, request) => (() => {
            const route = routeFromConfig(path, request.method);
            return tsplus_module_3.flatMap(store.getBucketForRoute(route), maybeBucket => {
                const bucket = tsplus_module_5.getOrElse(maybeBucket, () => ({
                    key: `?.${route}`,
                    resetAfter: 5000,
                    limit: 1,
                }));
                const resetAfter = millis(bucket.resetAfter);
                return tsplus_module_3.flatMap(invalidRateLimit(route), () => tsplus_module_3.map(maybeWait(`dfx.rest.${bucket.key}`, resetAfter, bucket.limit), () => void 0));
            });
        })();
        // Update rate limit buckets
        const updateBuckets = (request, response) => tsplus_module_3.ignore((() => {
            const route = routeFromConfig(request.url, request.method);
            return tsplus_module_3.flatMap(tsplus_module_3.fromOption(rateLimitFromHeaders(response.headers)), ({ bucket, retryAfter, limit, remaining }) => {
                const effectsToRun = [
                    removeBadRoute(route),
                    store.putBucketRoute(route, bucket),
                ];
                return tsplus_module_3.flatMap(store.hasBucket(bucket), hasBucket => {
                    if (!hasBucket || limit - 1 === remaining) {
                        effectsToRun.push(store.removeCounter(`dfx.rest.?.${route}`), store.putBucket({
                            key: bucket,
                            resetAfter: retryAfter.millis,
                            limit: !hasBucket && remaining > 0 ? remaining : limit,
                        }));
                    }
                    return tsplus_module_3.map(tsplus_module_3.collectAllParDiscard(effectsToRun), () => void 0);
                });
            });
        })());
        const httpExecutor = tsplus_module_7.catchAll(_ => tsplus_module_3.fail(new DiscordRESTError(_)))(tsplus_module_7.contramap(_ => tsplus_module_1.setHeaders({
            Authorization: `Bot ${tsplus_module_6.value(token)}`,
            "User-Agent": `DiscordBot (https://github.com/tim-smart/dfx, ${Pkg.version})`,
        })(tsplus_module_1.updateUrl(_ => `${rest.baseUrl}${_}`)(_)))(tsplus_module_7.filterStatusOk(http.execute)));
        const executor = (request) => tsplus_module_3.catchTag(tsplus_module_3.flatMap(requestRateLimit(request.url, request), () => tsplus_module_3.flatMap(globalRateLimit, () => tsplus_module_3.flatMap(httpExecutor(request), response => tsplus_module_3.map(updateBuckets(request, response), () => response)))), "DiscordRESTError", e => {
            if (e.error._tag !== "StatusCodeError") {
                return tsplus_module_3.fail(e);
            }
            const response = e.error.response;
            switch (e.error.status) {
                case 403:
                    return tsplus_module_3.flatMap(tsplus_module_3.collectAllParDiscard([
                        log.info("DiscordREST", "403", request.url),
                        addBadRoute(routeFromConfig(request.url, request.method)),
                        updateBuckets(request, response),
                    ]), () => tsplus_module_3.fail(e));
                case 429:
                    return tsplus_module_3.flatMap(tsplus_module_3.collectAllParDiscard([
                        log.info("DiscordREST", "429", request.url),
                        addBadRoute(routeFromConfig(request.url, request.method)),
                        updateBuckets(request, response),
                        tsplus_module_3.sleep(tsplus_module_5.getOrElse(retryAfter(response.headers), () => tsplus_module_4.seconds(5))),
                    ]), () => executor(request));
            }
            return tsplus_module_3.fail(e);
        });
        const routes = tsplus_module_2.Discord.createRoutes(({ method, url, params, options = {}, }) => {
            const hasBody = method !== "GET" && method !== "DELETE";
            let request = Http.make(method)(url, options);
            if (!hasBody) {
                if (params) {
                    request = tsplus_module_1.appendParams(params)(request);
                }
            }
            else if (request.body._tag === "Some" &&
                request.body.value._tag === "FormDataBody") {
                request.body.value.value.append("payload_json", JSON.stringify(params));
            }
            else if (params) {
                request = tsplus_module_1.jsonBody(params)(request);
            }
            return executor(request);
        });
        return { executor, ...routes };
    });
})))));
export const DiscordREST = tsplus_module_2.Tag();
export const LiveDiscordREST = tsplus_module_11.provide(tsplus_module_11.effect(DiscordREST, make))(LiveRateLimiter);
//# sourceMappingURL=DiscordREST.js.map