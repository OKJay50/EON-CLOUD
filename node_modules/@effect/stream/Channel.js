"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unwrap = exports.unit = exports.toStream = exports.toSink = exports.toQueue = exports.toPull = exports.toHub = exports.sync = exports.succeed = exports.scoped = exports.runDrain = exports.runCollect = exports.run = exports.repeated = exports.readWithCause = exports.readWith = exports.readOrFail = exports.read = exports.provideSomeLayer = exports.provideService = exports.provideLayer = exports.provideContext = exports.pipeToOrFail = exports.pipeTo = exports.orElse = exports.orDieWith = exports.orDie = exports.never = exports.mergeWith = exports.mergeOutWith = exports.mergeOut = exports.mergeMapStrategy = exports.mergeMapBufferStrategy = exports.mergeMapBuffer = exports.mergeMap = exports.mergeAllWith = exports.mergeAllUnboundedWith = exports.mergeAllUnbounded = exports.mergeAll = exports.mapOutEffectPar = exports.mapOutEffect = exports.mapOut = exports.mapErrorCause = exports.mapError = exports.mapEffect = exports.map = exports.isChannelException = exports.interruptWhenDeferred = exports.interruptWhen = exports.identity = exports.fromQueue = exports.fromOption = exports.fromInput = exports.fromHubScoped = exports.fromHub = exports.fromEither = exports.fromEffect = exports.foldChannel = exports.foldCauseChannel = exports.flatten = exports.flatMap = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.ensuringWith = exports.ensuring = exports.emitCollect = exports.embedInput = exports.drain = exports.doneCollect = exports.contramapInEffect = exports.contramapIn = exports.contramapErrorEffect = exports.contramapError = exports.contramapEffect = exports.contramapContext = exports.contramap = exports.contextWithEffect = exports.contextWithChannel = exports.contextWith = exports.context = exports.concatOut = exports.concatMapWithCustom = exports.concatMapWith = exports.concatMap = exports.concatAllWith = exports.concatAll = exports.collect = exports.catchAllCause = exports.catchAll = exports.bufferChunk = exports.buffer = exports.asUnit = exports.as = exports.acquireUseRelease = exports.acquireReleaseOut = exports.ChannelTypeId = exports.ChannelExceptionTypeId = exports.ChannelException = void 0;
exports.zipRight = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeft = exports.zip = exports.writeChunk = exports.writeAll = exports.write = exports.updateService = exports.unwrapScoped = void 0;
var channel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/core"));
var sink = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/sink"));
var stream = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 * @category symbols
 */
const ChannelTypeId = core.ChannelTypeId;
/**
 * @since 1.0.0
 * @category symbols
 */
exports.ChannelTypeId = ChannelTypeId;
const ChannelExceptionTypeId = channel.ChannelExceptionTypeId;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.ChannelExceptionTypeId = ChannelExceptionTypeId;
const acquireUseRelease = channel.acquireUseRelease;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.acquireUseRelease = acquireUseRelease;
const acquireReleaseOut = core.acquireReleaseOut;
/**
 * Returns a new channel that is the same as this one, except the terminal
 * value of the channel is the specified constant value.
 *
 * This method produces the same result as mapping this channel to the
 * specified constant value.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.acquireReleaseOut = acquireReleaseOut;
const as = channel.as;
/**
 * @since 1.0.0
 * @category mapping
 */
exports.as = as;
const asUnit = channel.asUnit;
/**
 * Creates a channel backed by a buffer. When the buffer is empty, the channel
 * will simply passthrough its input as output. However, when the buffer is
 * non-empty, the value inside the buffer will be passed along as output.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.asUnit = asUnit;
const buffer = channel.buffer;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.buffer = buffer;
const bufferChunk = channel.bufferChunk;
/**
 * Returns a new channel that is the same as this one, except if this channel
 * errors for any typed error, then the returned channel will switch over to
 * using the fallback channel returned by the specified error handler.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.bufferChunk = bufferChunk;
const catchAll = channel.catchAll;
/**
 * Returns a new channel that is the same as this one, except if this channel
 * errors for any typed error, then the returned channel will switch over to
 * using the fallback channel returned by the specified error handler.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.catchAll = catchAll;
const catchAllCause = core.catchAllCause;
/**
 * Concat sequentially a channel of channels.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.catchAllCause = catchAllCause;
const concatAll = core.concatAll;
/**
 * Concat sequentially a channel of channels.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.concatAll = concatAll;
const concatAllWith = core.concatAllWith;
/**
 * Returns a new channel whose outputs are fed to the specified factory
 * function, which creates new channels in response. These new channels are
 * sequentially concatenated together, and all their outputs appear as outputs
 * of the newly returned channel.
 *
 * @since 1.0.0
 * @category utils
 */
exports.concatAllWith = concatAllWith;
const concatMap = channel.concatMap;
/**
 * Returns a new channel whose outputs are fed to the specified factory
 * function, which creates new channels in response. These new channels are
 * sequentially concatenated together, and all their outputs appear as outputs
 * of the newly returned channel. The provided merging function is used to
 * merge the terminal values of all channels into the single terminal value of
 * the returned channel.
 *
 * @since 1.0.0
 * @category utils
 */
exports.concatMap = concatMap;
const concatMapWith = core.concatMapWith;
/**
 * Returns a new channel whose outputs are fed to the specified factory
 * function, which creates new channels in response. These new channels are
 * sequentially concatenated together, and all their outputs appear as outputs
 * of the newly returned channel. The provided merging function is used to
 * merge the terminal values of all channels into the single terminal value of
 * the returned channel.
 *
 * @since 1.0.0
 * @category utils
 */
exports.concatMapWith = concatMapWith;
const concatMapWithCustom = core.concatMapWithCustom;
/**
 * Returns a new channel, which is the same as this one, except its outputs
 * are filtered and transformed by the specified partial function.
 *
 * @since 1.0.0
 * @category utils
 */
exports.concatMapWithCustom = concatMapWithCustom;
const collect = channel.collect;
/**
 * Returns a new channel, which is the concatenation of all the channels that
 * are written out by this channel. This method may only be called on channels
 * that output other channels.
 *
 * @since 1.0.0
 * @category utils
 */
exports.collect = collect;
const concatOut = channel.concatOut;
/**
 * Returns a new channel which is the same as this one but applies the given
 * function to the input channel's done value.
 *
 * @since 1.0.0
 * @category utils
 */
exports.concatOut = concatOut;
const contramap = channel.contramap;
/**
 * Returns a new channel which is the same as this one but applies the given
 * effectual function to the input channel's done value.
 *
 * @since 1.0.0
 * @category utils
 */
exports.contramap = contramap;
const contramapEffect = channel.contramapEffect;
/**
 * Returns a new channel which is the same as this one but applies the given
 * function to the input channel's error value.
 *
 * @since 1.0.0
 * @category utils
 */
exports.contramapEffect = contramapEffect;
const contramapError = channel.contramapError;
/**
 * Returns a new channel which is the same as this one but applies the given
 * effectual function to the input channel's error value.
 *
 * @since 1.0.0
 * @category utils
 */
exports.contramapError = contramapError;
const contramapErrorEffect = channel.contramapErrorEffect;
/**
 * Returns a new channel which is the same as this one but applies the given
 * function to the input channel's output elements.
 *
 * @since 1.0.0
 * @category utils
 */
exports.contramapErrorEffect = contramapErrorEffect;
const contramapIn = channel.contramapIn;
/**
 * Returns a new channel which is the same as this one but applies the given
 * effectual function to the input channel's output elements.
 *
 * @since 1.0.0
 * @category utils
 */
exports.contramapIn = contramapIn;
const contramapInEffect = channel.contramapInEffect;
/**
 * Returns a new channel, which is the same as this one, except that all the
 * outputs are collected and bundled into a tuple together with the terminal
 * value of this channel.
 *
 * As the channel returned from this channel collects all of this channel's
 * output into an in- memory chunk, it is not safe to call this method on
 * channels that output a large or unbounded number of values.
 *
 * @since 1.0.0
 * @category utils
 */
exports.contramapInEffect = contramapInEffect;
const doneCollect = channel.doneCollect;
/**
 * Returns a new channel which reads all the elements from upstream's output
 * channel and ignores them, then terminates with the upstream result value.
 *
 * @since 1.0.0
 * @category utils
 */
exports.doneCollect = doneCollect;
const drain = channel.drain;
/**
 * Returns a new channel which connects the given `AsyncInputProducer` as
 * this channel's input.
 *
 * @since 1.0.0
 * @category utils
 */
exports.drain = drain;
const embedInput = core.embedInput;
/**
 * Returns a new channel that collects the output and terminal value of this
 * channel, which it then writes as output of the returned channel.
 *
 * @since 1.0.0
 * @category utils
 */
exports.embedInput = embedInput;
const emitCollect = channel.emitCollect;
/**
 * Returns a new channel with an attached finalizer. The finalizer is
 * guaranteed to be executed so long as the channel begins execution (and
 * regardless of whether or not it completes).
 *
 * @since 1.0.0
 * @category utils
 */
exports.emitCollect = emitCollect;
const ensuring = channel.ensuring;
/**
 * Returns a new channel with an attached finalizer. The finalizer is
 * guaranteed to be executed so long as the channel begins execution (and
 * regardless of whether or not it completes).
 *
 * @since 1.0.0
 * @category utils
 */
exports.ensuring = ensuring;
const ensuringWith = core.ensuringWith;
/**
 * Accesses the whole context of the channel.
 *
 * @since 1.0.0
 * @category context
 */
exports.ensuringWith = ensuringWith;
const context = channel.context;
/**
 * Accesses the context of the channel with the specified function.
 *
 * @since 1.0.0
 * @category context
 */
exports.context = context;
const contextWith = channel.contextWith;
/**
 * Accesses the context of the channel in the context of a channel.
 *
 * @since 1.0.0
 * @category context
 */
exports.contextWith = contextWith;
const contextWithChannel = channel.contextWithChannel;
/**
 * Accesses the context of the channel in the context of an effect.
 *
 * @since 1.0.0
 * @category context
 */
exports.contextWithChannel = contextWithChannel;
const contextWithEffect = channel.contextWithEffect;
/**
 * Constructs a channel that fails immediately with the specified error.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.contextWithEffect = contextWithEffect;
const fail = core.fail;
/**
 * Constructs a channel that succeeds immediately with the specified lazily
 * evaluated value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fail = fail;
const failSync = core.failSync;
/**
 * Constructs a channel that fails immediately with the specified `Cause`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.failSync = failSync;
const failCause = core.failCause;
/**
 * Constructs a channel that succeeds immediately with the specified lazily
 * evaluated `Cause`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.failCause = failCause;
const failCauseSync = core.failCauseSync;
/**
 * Returns a new channel, which sequentially combines this channel, together
 * with the provided factory function, which creates a second channel based on
 * the terminal value of this channel. The result is a channel that will first
 * perform the functions of this channel, before performing the functions of
 * the created channel (including yielding its terminal value).
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.failCauseSync = failCauseSync;
const flatMap = core.flatMap;
/**
 * Returns a new channel, which flattens the terminal value of this channel.
 * This function may only be called if the terminal value of this channel is
 * another channel of compatible types.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.flatMap = flatMap;
const flatten = channel.flatten;
/**
 * Folds over the result of this channel.
 *
 * @since 1.0.0
 * @category utils
 */
exports.flatten = flatten;
const foldChannel = channel.foldChannel;
/**
 * Folds over the result of this channel including any cause of termination.
 *
 * @since 1.0.0
 * @category utils
 */
exports.foldChannel = foldChannel;
const foldCauseChannel = core.foldCauseChannel;
/**
 * Use an effect to end a channel.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldCauseChannel = foldCauseChannel;
const fromEffect = core.fromEffect;
/**
 * Constructs a channel from an `Either`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromEffect = fromEffect;
const fromEither = channel.fromEither;
/**
 * Construct a `Channel` from an `AsyncInputConsumer`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromEither = fromEither;
const fromInput = channel.fromInput;
/**
 * Construct a `Channel` from a `Hub`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromInput = fromInput;
const fromHub = channel.fromHub;
/**
 * Construct a `Channel` from a `Hub` within a scoped effect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromHub = fromHub;
const fromHubScoped = channel.fromHubScoped;
/**
 * Construct a `Channel` from an `Option`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromHubScoped = fromHubScoped;
const fromOption = channel.fromOption;
/**
 * Construct a `Channel` from a `Queue`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromOption = fromOption;
const fromQueue = channel.fromQueue;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.fromQueue = fromQueue;
const identity = channel.identityChannel;
/**
 * Returns a new channel, which is the same as this one, except it will be
 * interrupted when the specified effect completes. If the effect completes
 * successfully before the underlying channel is done, then the returned
 * channel will yield the success value of the effect as its terminal value.
 * On the other hand, if the underlying channel finishes first, then the
 * returned channel will yield the success value of the underlying channel as
 * its terminal value.
 *
 * @since 1.0.0
 * @category utils
 */
exports.identity = identity;
const interruptWhen = channel.interruptWhen;
/**
 * Returns a new channel, which is the same as this one, except it will be
 * interrupted when the specified deferred is completed. If the deferred is
 * completed before the underlying channel is done, then the returned channel
 * will yield the value of the deferred. Otherwise, if the underlying channel
 * finishes first, then the returned channel will yield the value of the
 * underlying channel.
 *
 * @since 1.0.0
 * @category utils
 */
exports.interruptWhen = interruptWhen;
const interruptWhenDeferred = channel.interruptWhenDeferred;
/**
 * Returns a new channel, which is the same as this one, except the terminal
 * value of the returned channel is created by applying the specified function
 * to the terminal value of this channel.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.interruptWhenDeferred = interruptWhenDeferred;
const map = channel.map;
/**
 * Returns a new channel, which is the same as this one, except the terminal
 * value of the returned channel is created by applying the specified
 * effectful function to the terminal value of this channel.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.map = map;
const mapEffect = channel.mapEffect;
/**
 * Returns a new channel, which is the same as this one, except the failure
 * value of the returned channel is created by applying the specified function
 * to the failure value of this channel.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapEffect = mapEffect;
const mapError = channel.mapError;
/**
 * A more powerful version of `mapError` which also surfaces the `Cause`
 * of the channel failure.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapError = mapError;
const mapErrorCause = channel.mapErrorCause;
/**
 * Maps the output of this channel using the specified function.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapErrorCause = mapErrorCause;
const mapOut = channel.mapOut;
/**
 * Creates a channel that is like this channel but the given effectful function
 * gets applied to each emitted output element.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapOut = mapOut;
const mapOutEffect = channel.mapOutEffect;
/**
 * Creates a channel that is like this channel but the given ZIO function gets
 * applied to each emitted output element, taking `n` elements at once and
 * mapping them in parallel.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapOutEffect = mapOutEffect;
const mapOutEffectPar = channel.mapOutEffectPar;
/**
 * @since 1.0.0
 * @category utils
 */
exports.mapOutEffectPar = mapOutEffectPar;
const mergeAll = channel.mergeAll;
/**
 * @since 1.0.0
 * @category utils
 */
exports.mergeAll = mergeAll;
const mergeAllUnbounded = channel.mergeAllUnbounded;
/**
 * @since 1.0.0
 * @category utils
 */
exports.mergeAllUnbounded = mergeAllUnbounded;
const mergeAllUnboundedWith = channel.mergeAllUnboundedWith;
/**
 * @since 1.0.0
 * @category utils
 */
exports.mergeAllUnboundedWith = mergeAllUnboundedWith;
const mergeAllWith = channel.mergeAllWith;
/**
 * Returns a new channel which creates a new channel for each emitted element
 * and merges some of them together. Different merge strategies control what
 * happens if there are more than the given maximum number of channels gets
 * created. See `Channel.mergeAll`.
 *
 * @param n The maximum number of channels to merge.
 * @param f The function that creates a new channel from each emitted element.
 * @since 1.0.0
 * @category mapping
 */
exports.mergeAllWith = mergeAllWith;
const mergeMap = channel.mergeMap;
/**
 * Like `mergeMap`, but with a configurable `mergeStrategy` parameter.
 *
 * @param n The maximum number of channels to merge.
 * @param mergeStrategy The `MergeStrategy` to use (either `BackPressure` or `Sliding`.
 * @param f The function that creates a new channel from each emitted element.
 * @since 1.0.0
 * @category mapping
 */
exports.mergeMap = mergeMap;
const mergeMapStrategy = channel.mergeMapStrategy;
/**
 * Like `mergeMap`, but with a configurable `bufferSize` parameter.
 *
 * @param n The maximum number of channels to merge.
 * @param bufferSize The number of elements that can be buffered from upstream for the merging.
 * @param f The function that creates a new channel from each emitted element.
 * @since 1.0.0
 * @category mapping
 */
exports.mergeMapStrategy = mergeMapStrategy;
const mergeMapBuffer = channel.mergeMapBuffer;
/**
 * Like `mergeMap`, but with a configurable `bufferSize` and `mergeStrategy` parameter.
 *
 * @param n The maximum number of channels to merge.
 * @param bufferSize The number of elements that can be buffered from upstream for the merging.
 * @param mergeStrategy The `MergeStrategy` to use (either `BackPressure` or `Sliding`.
 * @param f The function that creates a new channel from each emitted element.
 * @since 1.0.0
 * @category mapping
 */
exports.mergeMapBuffer = mergeMapBuffer;
const mergeMapBufferStrategy = channel.mergeMapBufferStrategy;
/**
 * Returns a new channel which merges a number of channels emitted by this
 * channel using the back pressuring merge strategy. See `Channel.mergeAll`.
 *
 * @since 1.0.0
 * @category utils
 */
exports.mergeMapBufferStrategy = mergeMapBufferStrategy;
const mergeOut = channel.mergeOut;
/**
 * Returns a new channel which merges a number of channels emitted by this
 * channel using the back pressuring merge strategy and uses a given function
 * to merge each completed subchannel's result value. See
 * `Channel.mergeAll`.
 *
 * @since 1.0.0
 * @category utils
 */
exports.mergeOut = mergeOut;
const mergeOutWith = channel.mergeOutWith;
/**
 * Returns a new channel, which is the merge of this channel and the specified
 * channel, where the behavior of the returned channel on left or right early
 * termination is decided by the specified `leftDone` and `rightDone` merge
 * decisions.
 *
 * @since 1.0.0
 * @category utils
 */
exports.mergeOutWith = mergeOutWith;
const mergeWith = channel.mergeWith;
/**
 * Returns a channel that never completes
 *
 * @since 1.0.0
 * @category constructors
 */
exports.mergeWith = mergeWith;
const never = channel.never;
/**
 * Translates channel failure into death of the fiber, making all failures
 * unchecked and not a part of the type of the channel.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.never = never;
const orDie = channel.orDie;
/**
 * Keeps none of the errors, and terminates the fiber with them, using the
 * specified function to convert the `OutErr` into a defect.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orDie = orDie;
const orDieWith = channel.orDieWith;
/**
 * Returns a new channel that will perform the operations of this one, until
 * failure, and then it will switch over to the operations of the specified
 * fallback channel.
 *
 * @since 1.0.0
 * @category error handling
 */
exports.orDieWith = orDieWith;
const orElse = channel.orElse;
/**
 * Returns a new channel that pipes the output of this channel into the
 * specified channel. The returned channel has the input type of this channel,
 * and the output type of the specified channel, terminating with the value of
 * the specified channel.
 *
 * @since 1.0.0
 * @category utils
 */
exports.orElse = orElse;
const pipeTo = core.pipeTo;
/**
 * Returns a new channel that pipes the output of this channel into the
 * specified channel and preserves this channel's failures without providing
 * them to the other channel for observation.
 *
 * @since 1.0.0
 * @category utils
 */
exports.pipeTo = pipeTo;
const pipeToOrFail = channel.pipeToOrFail;
/**
 * Provides the channel with its required context, which eliminates its
 * dependency on `Env`.
 *
 * @since 1.0.0
 * @category context
 */
exports.pipeToOrFail = pipeToOrFail;
const provideContext = core.provideContext;
/**
 * Provides a layer to the channel, which translates it to another level.
 *
 * @since 1.0.0
 * @category context
 */
exports.provideContext = provideContext;
const provideLayer = channel.provideLayer;
/**
 * Transforms the context being provided to the channel with the specified
 * function.
 *
 * @since 1.0.0
 * @category context
 */
exports.provideLayer = provideLayer;
const contramapContext = channel.contramapContext;
/**
 * Splits the context into two parts, providing one part using the
 * specified layer and leaving the remainder `Env0`.
 *
 * @since 1.0.0
 * @category context
 */
exports.contramapContext = contramapContext;
const provideSomeLayer = channel.provideSomeLayer;
/**
 * Provides the effect with the single service it requires. If the effect
 * requires more than one service use `provideContext` instead.
 *
 * @since 1.0.0
 * @category context
 */
exports.provideSomeLayer = provideSomeLayer;
const provideService = channel.provideService;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.provideService = provideService;
const read = channel.read;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.read = read;
const readOrFail = core.readOrFail;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.readOrFail = readOrFail;
const readWith = core.readWith;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.readWith = readWith;
const readWithCause = core.readWithCause;
/**
 * Creates a channel which repeatedly runs this channel.
 *
 * @since 1.0.0
 * @category utils
 */
exports.readWithCause = readWithCause;
const repeated = channel.repeated;
/**
 * Runs a channel until the end is received.
 *
 * @macro traced
 * @since 1.0.0
 * @category destructors
 */
exports.repeated = repeated;
const run = channel.run;
/**
 * Run the channel until it finishes with a done value or fails with an error
 * and collects its emitted output elements.
 *
 * The channel must not read any input.
 *
 * @macro traced
 * @since 1.0.0
 * @category destructors
 */
exports.run = run;
const runCollect = channel.runCollect;
/**
 * Runs a channel until the end is received.
 *
 * @macro traced
 * @since 1.0.0
 * @category destructors
 */
exports.runCollect = runCollect;
const runDrain = channel.runDrain;
/**
 * Use a scoped effect to emit an output element.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.runDrain = runDrain;
const scoped = channel.scoped;
/**
 * Constructs a channel that succeeds immediately with the specified value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.scoped = scoped;
const succeed = core.succeed;
/**
 * Constructs a channel that succeeds immediately with the specified lazy value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.succeed = succeed;
const sync = core.sync;
/**
 * Converts a `Channel` to a `Hub`.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.sync = sync;
const toHub = channel.toHub;
/**
 * Returns a scoped `Effect` that can be used to repeatedly pull elements from
 * the constructed `Channel`. The pull effect fails with the channel's failure
 * in case the channel fails, or returns either the channel's done value or an
 * emitted element.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.toHub = toHub;
const toPull = channel.toPull;
/**
 * Converts a `Channel` to a `Queue`.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.toPull = toPull;
const toQueue = channel.toQueue;
/** Converts this channel to a `Sink`.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.toQueue = toQueue;
const toSink = sink.channelToSink;
/**
 * Converts this channel to a `Stream`.
 *
 * @since 1.0.0
 * @category destructors
 */
exports.toSink = toSink;
const toStream = stream.channelToStream;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.toStream = toStream;
const unit = core.unit;
/**
 * Makes a channel from an effect that returns a channel in case of success.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.unit = unit;
const unwrap = channel.unwrap;
/**
 * Makes a channel from a managed that returns a channel in case of success.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.unwrap = unwrap;
const unwrapScoped = channel.unwrapScoped;
/**
 * Updates a service in the context of this channel.
 *
 * @since 1.0.0
 * @category context
 */
exports.unwrapScoped = unwrapScoped;
const updateService = channel.updateService;
/**
 * Writes a single value to the channel.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.updateService = updateService;
const write = core.write;
/**
 * Writes a sequence of values to the channel.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.write = write;
const writeAll = channel.writeAll;
/**
 * Writes a `Chunk` of values to the channel.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.writeAll = writeAll;
const writeChunk = channel.writeChunk;
/**
 * Returns a new channel that is the sequential composition of this channel
 * and the specified channel. The returned channel terminates with a tuple of
 * the terminal values of both channels.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.writeChunk = writeChunk;
const zip = channel.zip;
/**
 * Returns a new channel that is the sequential composition of this channel
 * and the specified channel. The returned channel terminates with the
 * terminal value of this channel.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zip = zip;
const zipLeft = channel.zipLeft;
/**
 * Returns a new channel that is the sequential composition of this channel
 * and the specified channel. The returned channel terminates with the
 * terminal value of that channel.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipLeft = zipLeft;
const zipRight = channel.zipRight;
/**
 * Creates a new channel which runs in parallel this and the other channel and
 * when both succeeds finishes with a tuple of both channel's done value.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipRight = zipRight;
const zipPar = channel.zipPar;
/**
 * Creates a new channel which runs in parallel this and the other channel and
 * when both succeeds finishes with the first one's done value.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipPar = zipPar;
const zipParLeft = channel.zipParLeft;
/**
 * Creates a new channel which runs in parallel this and the other channel and
 * when both succeeds finishes with the second one's done value.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipParLeft = zipParLeft;
const zipParRight = channel.zipParRight;
/**
 * Represents a generic checked exception which occurs when a `Channel` is
 * executed.
 *
 * @since 1.0.0
 * @category errors
 */
exports.zipParRight = zipParRight;
const ChannelException = channel.ChannelException;
/**
 * Returns `true` if the specified value is an `ChannelException`, `false`
 * otherwise.
 *
 * @since 1.0.0
 * @category refinements
 */
exports.ChannelException = ChannelException;
const isChannelException = channel.isChannelException;
exports.isChannelException = isChannelException;
//# sourceMappingURL=Channel.js.map