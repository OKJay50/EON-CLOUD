"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flattenEffectParUnordered = exports.flattenEffectPar = exports.flattenEffect = exports.flattenChunks = exports.flatten = exports.flatMapParSwitchBuffer = exports.flatMapParSwitch = exports.flatMapParBuffer = exports.flatMapPar = exports.flatMap = exports.findEffect = exports.find = exports.finalizer = exports.filterEffect = exports.filter = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.execute = exports.ensuring = exports.empty = exports.either = exports.dropWhileEffect = exports.dropWhile = exports.dropUntilEffect = exports.dropUntil = exports.dropRight = exports.drop = exports.drainFork = exports.drain = exports.done = exports.distributedWithDynamicCallback = exports.distributedWithDynamic = exports.distributedWith = exports.dieSync = exports.dieMessage = exports.die = exports.debounce = exports.crossWith = exports.crossRight = exports.crossLeft = exports.cross = exports.contramapContext = exports.contextWithStream = exports.contextWithEffect = exports.contextWith = exports.context = exports.concatAll = exports.concat = exports.combineChunks = exports.combine = exports.collectWhileSuccess = exports.collectWhileSome = exports.collectWhileRight = exports.collectWhileLeft = exports.collectWhileEffect = exports.collectWhile = exports.collectSuccess = exports.collectSome = exports.collectRight = exports.collectLeft = exports.collectEffect = exports.collect = exports.chunksWith = exports.chunks = exports.channelToStream = exports.changesWithEffect = exports.changesWith = exports.changes = exports.catchSomeCause = exports.catchSome = exports.catchAllCause = exports.catchAll = exports.bufferUnbounded = exports.bufferSliding = exports.bufferDropping = exports.bufferChunksSliding = exports.bufferChunksDropping = exports.bufferChunks = exports.buffer = exports.broadcastedQueuesDynamic = exports.broadcastedQueues = exports.broadcastDynamic = exports.broadcast = exports.branchAfter = exports.asyncScoped = exports.asyncOption = exports.asyncInterrupt = exports.asyncEffect = exports.as = exports.aggregateWithinEither = exports.aggregateWithin = exports.aggregate = exports.acquireRelease = exports.absolve = exports._async = exports.StreamTypeId = exports.StreamImpl = exports.DefaultChunkSize = void 0;
exports.orDieWith = exports.orDie = exports.onError = exports.onDone = exports.never = exports.mkString = exports.mergeWithHaltStrategy = exports.mergeWith = exports.mergeRight = exports.mergeLeft = exports.mergeHaltStrategy = exports.mergeHaltRight = exports.mergeHaltLeft = exports.mergeHaltEither = exports.mergeEither = exports.mergeAllUnbounded = exports.mergeAll = exports.merge = exports.mapErrorCause = exports.mapError = exports.mapEffectParUnordered = exports.mapEffectPar = exports.mapEffect = exports.mapConcatEffect = exports.mapConcatChunkEffect = exports.mapConcatChunk = exports.mapConcat = exports.mapChunksEffect = exports.mapChunks = exports.mapBoth = exports.mapAccumEffect = exports.mapAccum = exports.map = exports.make = exports.logWarningCauseMessage = exports.logWarningCause = exports.logWarning = exports.logTraceCauseMessage = exports.logTraceCause = exports.logTrace = exports.logInfoCauseMessage = exports.logInfoCause = exports.logInfo = exports.logFatalCauseMessage = exports.logFatalCause = exports.logFatal = exports.logErrorCauseMessage = exports.logErrorCause = exports.logError = exports.logDebugCauseMessage = exports.logDebugCause = exports.logDebug = exports.log = exports.iterate = exports.intersperseAffixes = exports.intersperse = exports.interruptWhenDeferred = exports.interruptWhen = exports.interruptAfter = exports.interleaveWith = exports.interleave = exports.identityStream = exports.haltWhenDeferred = exports.haltWhen = exports.haltAfter = exports.groupedWithin = exports.grouped = exports.groupAdjacentBy = exports.fromSchedule = exports.fromQueueWithShutdown = exports.fromQueue = exports.fromPull = exports.fromIteratorSucceed = exports.fromIterableEffect = exports.fromIterable = exports.fromHubWithShutdown = exports.fromHubScopedWithShutdown = exports.fromHubScoped = exports.fromHub = exports.fromEffectOption = exports.fromEffect = exports.fromChunks = exports.fromChunkQueueWithShutdown = exports.fromChunkQueue = exports.fromChunkHubWithShutdown = exports.fromChunkHubScopedWithShutdown = exports.fromChunkHubScoped = exports.fromChunkHub = exports.fromChunk = exports.fromChannel = exports.fromAsyncIterable = exports.forever = exports.flattenTake = exports.flattenParUnboundedBuffer = exports.flattenParUnbounded = exports.flattenParBuffer = exports.flattenPar = exports.flattenIterables = exports.flattenExitOption = exports.flattenExit = void 0;
exports.tapErrorCause = exports.tapError = exports.tap = exports.takeWhile = exports.takeUntilEffect = exports.takeUntil = exports.takeRight = exports.take = exports.sync = exports.suspend = exports.succeed = exports.splitOnChunk = exports.split = exports.someOrFail = exports.someOrElse = exports.some = exports.slidingSize = exports.sliding = exports.scoped = exports.scheduleWith = exports.scheduleEither = exports.schedule = exports.scanReduceEffect = exports.scanReduce = exports.scanEffect = exports.scan = exports.runSum = exports.runScoped = exports.runLast = exports.runIntoQueueScoped = exports.runIntoQueueElementsScoped = exports.runIntoQueue = exports.runIntoHubScoped = exports.runIntoHub = exports.runHead = exports.runForEachWhileScoped = exports.runForEachWhile = exports.runForEachScoped = exports.runForEachChunkScoped = exports.runForEachChunk = exports.runForEach = exports.runFoldWhileScopedEffect = exports.runFoldWhileScoped = exports.runFoldWhileEffect = exports.runFoldWhile = exports.runFoldScopedEffect = exports.runFoldScoped = exports.runFoldEffect = exports.runFold = exports.runDrain = exports.runCount = exports.runCollect = exports.run = exports.rightOrFail = exports.right = exports.retry = exports.repeatWithSchedule = exports.repeatWith = exports.repeatValue = exports.repeatElementsWith = exports.repeatElementsEither = exports.repeatElements = exports.repeatEither = exports.repeatEffectWithSchedule = exports.repeatEffectOption = exports.repeatEffectChunkOption = exports.repeatEffectChunk = exports.repeatEffect = exports.repeat = exports.refineOrDieWith = exports.refineOrDie = exports.rechunk = exports.range = exports.provideSomeLayer = exports.provideServiceStream = exports.provideServiceEffect = exports.provideService = exports.provideLayer = exports.provideContext = exports.prepend = exports.pipeThroughChannelOrFail = exports.pipeThroughChannel = exports.pipeThrough = exports.peel = exports.partitionEitherBuffer = exports.partitionEither = exports.partitionBuffer = exports.partition = exports.paginateEffect = exports.paginateChunkEffect = exports.paginateChunk = exports.paginate = exports.orElseSucceed = exports.orElseOptional = exports.orElseIfEmptyStream = exports.orElseIfEmptyChunk = exports.orElseIfEmpty = exports.orElseFail = exports.orElseEither = exports.orElse = void 0;
exports.zipWithPreviousAndNext = exports.zipWithPrevious = exports.zipWithNext = exports.zipWithIndex = exports.zipWithChunks = exports.zipWith = exports.zipRight = exports.zipLeft = exports.zipLatestWith = exports.zipLatest = exports.zipFlatten = exports.zipAllWith = exports.zipAllSortedByKeyWith = exports.zipAllSortedByKeyRight = exports.zipAllSortedByKeyLeft = exports.zipAllSortedByKey = exports.zipAllRight = exports.zipAllLeft = exports.zipAll = exports.zip = exports.whenEffect = exports.whenCaseEffect = exports.whenCase = exports.when = exports.updateService = exports.unwrapScoped = exports.unwrap = exports.unit = exports.unfoldEffect = exports.unfoldChunkEffect = exports.unfoldChunk = exports.unfold = exports.transduce = exports.toQueueUnbounded = exports.toQueueSlidingCapacity = exports.toQueueSliding = exports.toQueueOfElementsCapacity = exports.toQueueOfElements = exports.toQueueDroppingCapacity = exports.toQueueDropping = exports.toQueueCapacity = exports.toQueue = exports.toPull = exports.toHub = exports.toChannel = exports.timeoutTo = exports.timeoutFailCause = exports.timeoutFail = exports.timeout = exports.tick = exports.throttleShapeEffectBurst = exports.throttleShapeEffect = exports.throttleShapeBurst = exports.throttleShape = exports.throttleEnforceEffectBurst = exports.throttleEnforceEffect = exports.throttleEnforceBurst = exports.throttleEnforce = exports.tapSink = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Context"));
var _Debug = /*#__PURE__*/require("@effect/data/Debug");
var Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Duration"));
var Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equal"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Clock"));
var Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Deferred"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Exit"));
var Fiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Fiber"));
var Hub = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Hub"));
var Layer = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Layer"));
var Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Queue"));
var Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Ref"));
var Runtime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Runtime"));
var Schedule = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Schedule"));
var MergeDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/Channel/MergeDecision"));
var channel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel"));
var channelExecutor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/channelExecutor"));
var MergeStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/mergeStrategy"));
var singleProducerAsyncInput = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/singleProducerAsyncInput"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/core"));
var _sink = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/sink"));
var DebounceState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/debounceState"));
var emit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/emit"));
var haltStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/haltStrategy"));
var Handoff = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/handoff"));
var HandoffSignal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/handoffSignal"));
var pull = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/pull"));
var SinkEndReason = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/sinkEndReason"));
var ZipAllState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/zipAllState"));
var ZipChunksState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream/zipChunksState"));
var _support = /*#__PURE__*/require("@effect/stream/internal/support");
var _take = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/take"));
var HaltStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/Stream/HaltStrategy"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a;
/** @internal */
const StreamSymbolKey = "@effect/stream/Stream";
/** @internal */
const StreamTypeId = /*#__PURE__*/Symbol.for(StreamSymbolKey);
/** @internal */
exports.StreamTypeId = StreamTypeId;
const streamVariance = {
  _R: _ => _,
  _E: _ => _,
  _A: _ => _
};
/** @internal */
class StreamImpl {
  constructor(channel) {
    this.channel = channel;
    this[_a] = streamVariance;
  }
}
exports.StreamImpl = StreamImpl;
_a = StreamTypeId;
/** @internal */
const DefaultChunkSize = 4096;
/** @internal */
exports.DefaultChunkSize = DefaultChunkSize;
const absolve = self => mapEffect(Effect.fromEither)(self);
/** @internal */
exports.absolve = absolve;
const acquireRelease = (acquire, release) => scoped(Effect.acquireRelease(acquire, release));
/** @internal */
exports.acquireRelease = acquireRelease;
const aggregate = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => aggregateWithin(sink, Schedule.forever())(self));
/** @internal */
exports.aggregate = aggregate;
const aggregateWithin = /*#__PURE__*/(0, _Function.dual)(3, (self, sink, schedule) => collectRight(aggregateWithinEither(sink, schedule)(self)));
/** @internal */
exports.aggregateWithin = aggregateWithin;
const aggregateWithinEither = /*#__PURE__*/(0, _Function.dual)(3, (self, sink, schedule) => {
  const layer = Effect.all(Handoff.make(), Ref.make(SinkEndReason.SchedulEnd), Ref.make(Chunk.empty()), Schedule.driver(schedule), Ref.make(false), Ref.make(false));
  return flatMap(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = core.readWithCause(input => core.flatMap(() => handoffProducer)(core.fromEffect(Effect.when(() => Chunk.isNonEmpty(input))(Handoff.offer(HandoffSignal.emit(input))(handoff)))), cause => core.fromEffect(Handoff.offer(HandoffSignal.halt(cause))(handoff)), () => core.fromEffect(Handoff.offer(HandoffSignal.end(SinkEndReason.UpstreamEnd))(handoff)));
    const handoffConsumer = channel.unwrap(Effect.flatMap(leftovers => {
      if (Chunk.isNonEmpty(leftovers)) {
        return Effect.zipRight(Effect.succeed(core.flatMap(() => handoffConsumer)(core.write(leftovers))))(Ref.set(consumed, true));
      }
      return Effect.map(signal => {
        switch (signal._tag) {
          case HandoffSignal.OP_EMIT:
            {
              return core.flatMap(bool => bool ? core.unit() : handoffConsumer)(channel.zipRight(core.fromEffect(Ref.get(endAfterEmit)))(channel.zipRight(core.write(signal.elements))(core.fromEffect(Ref.set(consumed, true)))));
            }
          case HandoffSignal.OP_HALT:
            {
              return core.failCause(signal.cause);
            }
          case HandoffSignal.OP_END:
            {
              if (signal.reason._tag === SinkEndReason.OP_SCHEDULE_END) {
                return channel.unwrap(Effect.map(bool => bool ? core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, SinkEndReason.SchedulEnd))) : core.flatMap(() => handoffConsumer)(core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, SinkEndReason.SchedulEnd)))))(Ref.get(consumed)));
              }
              return core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, signal.reason)));
            }
        }
      })(Handoff.take(handoff));
    })(Ref.getAndSet(sinkLeftovers, Chunk.empty())));
    const timeout = lastB => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope) => {
      const forkSink = Effect.zipRight(Effect.forkIn(scope)(channelExecutor.run(core.collectElements(channel.pipeToOrFail(_sink.toChannel(sink))(handoffConsumer)))))(Effect.zipRight(Ref.set(endAfterEmit, false))(Ref.set(consumed, false)));
      const handleSide = (leftovers, b, c) => channel.unwrap(Effect.zipRight(Effect.map(reason => {
        switch (reason._tag) {
          case SinkEndReason.OP_SCHEDULE_END:
            {
              return channel.unwrap(Effect.map(([wasConsumed, sinkFiber, scheduleFiber]) => {
                const toWrite = Option.match(() => Chunk.of(Either.right(b)), c => Chunk.make(Either.right(b), Either.left(c)))(c);
                if (wasConsumed) {
                  return core.flatMap(() => scheduledAggregator(sinkFiber, scheduleFiber, scope))(core.write(toWrite));
                }
                return scheduledAggregator(sinkFiber, scheduleFiber, scope);
              })(Effect.all(Ref.get(consumed), forkSink, Effect.forkIn(scope)(timeout(Option.some(b))))));
            }
          case SinkEndReason.OP_UPSTREAM_END:
            {
              return channel.unwrap(Effect.map(wasConsumed => wasConsumed ? core.write(Chunk.of(Either.right(b))) : core.unit())(Ref.get(consumed)));
            }
        }
      })(Ref.get(sinkEndReason)))(Ref.set(sinkLeftovers, Chunk.flatten(leftovers))));
      return channel.unwrap(Effect.raceWith(Fiber.join(scheduleFiber), (sinkExit, _) => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Effect.done(sinkExit)))(Fiber.interrupt(scheduleFiber)), (scheduleExit, _) => Effect.matchCauseEffect(cause => Either.match(() => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.end(SinkEndReason.SchedulEnd))(handoff))), cause => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.halt(cause))(handoff))))(Cause.failureOrCause(cause)), c => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.some(c)))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.end(SinkEndReason.SchedulEnd))(handoff))))(Effect.done(scheduleExit)))(Fiber.join(sinkFiber)));
    };
    return unwrapScoped(Effect.zipRight(Effect.flatMap(sinkFiber => Effect.flatMap(scheduleFiber => Effect.map(scope => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope)))(Effect.scope()))(Effect.forkScoped(timeout(Option.none()))))(Effect.forkScoped(channelExecutor.run(core.collectElements(channel.pipeToOrFail(_sink.toChannel(sink))(handoffConsumer))))))(Effect.forkScoped(channelExecutor.run(core.pipeTo(handoffProducer)(toChannel(self))))));
  })(fromEffect(layer));
});
/** @internal */
exports.aggregateWithinEither = aggregateWithinEither;
const as = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => map(() => value)(self));
/** @internal */
exports.as = as;
const _async = (register, outputBuffer = 16) => asyncOption(cb => {
  register(cb);
  return Option.none();
}, outputBuffer);
/** @internal */
exports._async = _async;
const asyncEffect = (register, outputBuffer = 16) => fromChannel(channel.unwrapScoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.map(() => {
  const loop = channel.unwrap(Effect.match(maybeError => channel.zipRight(Option.match(core.unit, core.fail)(maybeError))(core.fromEffect(Queue.shutdown(output))), chunk => core.flatMap(() => loop)(core.write(chunk)))(Effect.flatMap(_take.done)(Queue.take(output))));
  return loop;
})(register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {
  if (Exit.isFailure(exit)) {
    if (!Cause.isInterrupted(exit.cause)) {
      throw Cause.squash(exit.cause);
    }
  }
})))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue)))));
/** @internal */
exports.asyncEffect = asyncEffect;
const asyncInterrupt = (register, outputBuffer = 16) => unwrapScoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.map(Either.match(canceler => {
  const loop = channel.unwrap(Effect.match(maybeError => channel.zipRight(Option.match(core.unit, core.fail)(maybeError))(core.fromEffect(Queue.shutdown(output))), chunk => core.flatMap(() => loop)(core.write(chunk)))(Effect.flatMap(_take.done)(Queue.take(output))));
  return ensuring(canceler)(fromChannel(loop));
}, stream => unwrap(Effect.as(stream)(Queue.shutdown(output)))))(Effect.sync(() => register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {
  if (Exit.isFailure(exit)) {
    if (!Cause.isInterrupted(exit.cause)) {
      throw Cause.squash(exit.cause);
    }
  }
}))))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue))));
/** @internal */
exports.asyncInterrupt = asyncInterrupt;
const asyncOption = (register, outputBuffer = 16) => asyncInterrupt(emit => Either.fromOption(Effect.unit)(register(emit)), outputBuffer);
/** @internal */
exports.asyncOption = asyncOption;
const asyncScoped = (register, outputBuffer = 16) => flatMap(repeatEffectChunkOption)(scoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.flatMap(ref => Effect.map(isDone => isDone ? pull.end() : Effect.onError(() => Effect.zipRight(Queue.shutdown(output))(Ref.set(ref, true)))(Effect.flatMap(_take.done)(Queue.take(output))))(Ref.get(ref)))(Effect.zipRight(Ref.make(false))(register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {
  if (Exit.isFailure(exit)) {
    if (!Cause.isInterrupted(exit.cause)) {
      throw Cause.squash(exit.cause);
    }
  }
}))))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue)))));
/** @internal */
exports.asyncScoped = asyncScoped;
const branchAfter = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => suspend(() => {
  const bufferring = acc => core.readWith(input => {
    const nextSize = acc.length + input.length;
    if (nextSize >= n) {
      const [b1, b2] = Chunk.splitAt(n - acc.length)(input);
      return running(Chunk.concat(b1)(acc), b2);
    }
    return bufferring(Chunk.concat(input)(acc));
  }, core.fail, () => running(acc, Chunk.empty()));
  const running = (prefix, leftover) => core.pipeTo(toChannel(f(prefix)))(toChannel(prepend(leftover)));
  return new StreamImpl(channel.pipeToOrFail(bufferring(Chunk.empty()))(toChannel(self)));
}));
/** @internal */
exports.branchAfter = branchAfter;
const broadcast = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, n, maximumLag) => Effect.map(tuple => tuple.map(queue => flattenTake(fromQueueWithShutdown(queue))))(broadcastedQueues(n, maximumLag)(self)).traced(trace));
/** @internal */
exports.broadcast = broadcast;
const broadcastDynamic = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, maximumLag) => Effect.map(effect => flattenTake(flatMap(fromQueue)(scoped(effect))))(broadcastedQueuesDynamic(maximumLag)(self)).traced(trace));
/** @internal */
exports.broadcastDynamic = broadcastDynamic;
const broadcastedQueues = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, n, maximumLag) => Effect.flatMap(hub => Effect.tap(() => Effect.forkScoped(runIntoHubScoped(hub)(self)))(Effect.map(chunk => Chunk.toReadonlyArray(chunk))(Effect.collectAll(Array.from({
  length: n
}, () => Hub.subscribe(hub))))))(Hub.bounded(maximumLag)).traced(trace));
/** @internal */
exports.broadcastedQueues = broadcastedQueues;
const broadcastedQueuesDynamic = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, maximumLag) => Effect.map(Hub.subscribe)(toHub(maximumLag)(self)).traced(trace));
/** @internal */
exports.broadcastedQueuesDynamic = broadcastedQueuesDynamic;
const buffer = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = toQueueOfElementsCapacity(self, capacity);
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue => {
    const process = core.flatMap(Exit.match(cause => Option.match(core.unit, core.failCause)(Cause.flipCauseOption(cause)), value => core.flatMap(() => process)(core.write(Chunk.of(value)))))(core.fromEffect(Queue.take(queue)));
    return process;
  })(queue)));
});
/** @internal */
exports.buffer = buffer;
const bufferChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = toQueueCapacity(capacity)(self);
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue => {
    const process = core.flatMap(_take.match(core.unit, core.failCause, value => core.flatMap(() => process)(core.write(value))))(core.fromEffect(Queue.take(queue)));
    return process;
  })(queue)));
});
/** @internal */
exports.bufferChunks = bufferChunks;
const bufferChunksDropping = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(self)));
});
/** @internal */
exports.bufferChunksDropping = bufferChunksDropping;
const bufferChunksSliding = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(self)));
});
/** @internal */
exports.bufferChunksSliding = bufferChunksSliding;
const bufferDropping = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(rechunk(1)(self))));
});
/** @internal */
exports.bufferDropping = bufferDropping;
const bufferSliding = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(rechunk(1)(self))));
});
/** @internal */
exports.bufferSliding = bufferSliding;
const bufferUnbounded = self => {
  const queue = toQueueUnbounded(self);
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue => {
    const process = core.flatMap(_take.match(core.unit, core.failCause, value => core.flatMap(() => process)(core.write(value))))(core.fromEffect(Queue.take(queue)));
    return process;
  })(queue)));
};
/** @internal */
exports.bufferUnbounded = bufferUnbounded;
const bufferSignal = (scoped, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = take => core.fromEffect(Effect.asUnit(Effect.flatMap(deferred => Effect.zipRight(Deferred.await(deferred))(Effect.zipRight(Ref.set(ref, deferred))(Queue.offer(queue, [take, deferred]))))(Effect.zipRight(Deferred.make())(Effect.tap(Deferred.await)(Ref.get(ref))))));
    return core.readWithCause(input => core.flatMap(() => producer(queue, ref))(core.fromEffect(Effect.asUnit(Effect.flatMap(deferred => Effect.flatMap(added => Effect.when(() => added)(Ref.set(ref, deferred)))(Queue.offer(queue, [_take.chunk(input), deferred])))(Deferred.make())))), error => terminate(_take.failCause(error)), () => terminate(_take.end));
  };
  const consumer = queue => {
    const process = core.flatMap(([take, deferred]) => channel.zipRight(_take.match(core.unit, core.failCause, value => core.flatMap(() => process)(core.write(value)))(take))(core.fromEffect(Deferred.succeed(deferred, void 0))))(core.fromEffect(Queue.take(queue)));
    return process;
  };
  return channel.unwrapScoped(Effect.flatMap(queue => Effect.flatMap(start => Effect.as(consumer(queue))(Effect.flatMap(ref => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(queue, ref))(bufferChannel))))(Ref.make(start))))(Effect.tap(start => Deferred.succeed(start, void 0))(Deferred.make())))(scoped));
};
/** @internal */
const catchAll = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAllCause(cause => Either.match(f, failCause)(Cause.failureOrCause(cause)))(self));
/** @internal */
exports.catchAll = catchAll;
const catchAllCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(core.catchAllCause(cause => toChannel(f(cause)))(toChannel(self))));
/** @internal */
exports.catchAllCause = catchAllCause;
const catchSome = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => catchAll(error => Option.getOrElse(() => fail(error))(pf(error)))(self));
/** @internal */
exports.catchSome = catchSome;
const catchSomeCause = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => catchAllCause(cause => Option.getOrElse(() => failCause(cause))(pf(cause)))(self));
/** @internal */
exports.catchSomeCause = catchSomeCause;
const changes = self => changesWith((x, y) => Equal.equals(y)(x))(self);
/** @internal */
exports.changes = changes;
const changesWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const writer = last => core.readWithCause(input => {
    const [newLast, newChunk] = Chunk.reduce([last, Chunk.empty()], ([option, outputs], output) => {
      if (Option.isSome(option) && f(option.value, output)) {
        return [Option.some(output), outputs];
      }
      return [Option.some(output), Chunk.append(output)(outputs)];
    })(input);
    return core.flatMap(() => writer(newLast))(core.write(newChunk));
  }, core.failCause, core.unit);
  return new StreamImpl(core.pipeTo(writer(Option.none()))(toChannel(self)));
});
/** @internal */
exports.changesWith = changesWith;
const changesWithEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const writer = last => core.readWithCause(input => core.flatMap(([newLast, newChunk]) => core.flatMap(() => writer(newLast))(core.write(newChunk)))(core.fromEffect(Effect.reduce([last, Chunk.empty()], ([option, outputs], output) => {
    if (Option.isSome(option)) {
      return Effect.map(bool => bool ? [Option.some(output), outputs] : [Option.some(output), Chunk.append(output)(outputs)])(f(option.value, output));
    }
    return Effect.succeed([Option.some(output), Chunk.append(output)(outputs)]);
  })(input))), core.failCause, core.unit);
  return new StreamImpl(core.pipeTo(writer(Option.none()))(toChannel(self)));
});
/** @internal */
exports.changesWithEffect = changesWithEffect;
const chunks = self => mapChunks(Chunk.of)(self);
/** @internal */
exports.chunks = chunks;
const chunksWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flattenChunks(f(chunks(self))));
/** @internal */
exports.chunksWith = chunksWith;
const collect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => mapChunks(Chunk.filterMap(pf))(self));
/** @internal */
exports.collect = collect;
const collectEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => suspend(() => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause(input => loop(input[Symbol.iterator]()), core.failCause, core.succeed);
    } else {
      return channel.unwrap(Option.match(() => Effect.sync(() => loop(iterator)), Effect.map(a2 => core.flatMap(() => loop(iterator))(core.write(Chunk.of(a2)))))(pf(next.value)));
    }
  };
  return new StreamImpl(core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(toChannel(self)));
}));
/** @internal */
exports.collectEffect = collectEffect;
const collectLeft = self => collect(either => Either.isLeft(either) ? Option.some(either.left) : Option.none())(self);
/** @internal */
exports.collectLeft = collectLeft;
const collectSome = self => collect(option => Option.isSome(option) ? Option.some(option.value) : Option.none())(self);
/** @internal */
exports.collectSome = collectSome;
const collectSuccess = self => collect(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none())(self);
/** @internal */
exports.collectSuccess = collectSuccess;
const collectRight = self => collect(either => Either.isRight(either) ? Option.some(either.right) : Option.none())(self);
/** @internal */
exports.collectRight = collectRight;
const collectWhile = pf => {
  return self => {
    const loop = core.readWith(input => {
      const mapped = Chunk.filterMapWhile(pf)(input);
      if (mapped.length === input.length) {
        return core.flatMap(() => loop)(core.write(mapped));
      }
      return core.write(mapped);
    }, core.fail, core.succeed);
    return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
  };
};
/** @internal */
exports.collectWhile = collectWhile;
const collectWhileLeft = self => collectWhile(either => Either.isLeft(either) ? Option.some(either.left) : Option.none())(self);
/** @internal */
exports.collectWhileLeft = collectWhileLeft;
const collectWhileSome = self => collectWhile(option => Option.isSome(option) ? Option.some(option.value) : Option.none())(self);
/** @internal */
exports.collectWhileSome = collectWhileSome;
const collectWhileRight = self => collectWhile(either => Either.isRight(either) ? Option.some(either.right) : Option.none())(self);
/** @internal */
exports.collectWhileRight = collectWhileRight;
const collectWhileSuccess = self => collectWhile(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none())(self);
/** @internal */
exports.collectWhileSuccess = collectWhileSuccess;
const collectWhileEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => suspend(() => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause(input => loop(input[Symbol.iterator]()), core.failCause, core.succeed);
    } else {
      return channel.unwrap(Option.match(() => Effect.succeed(core.unit()), Effect.map(a2 => core.flatMap(() => loop(iterator))(core.write(Chunk.of(a2)))))(pf(next.value)));
    }
  };
  return new StreamImpl(channel.pipeToOrFail(loop(Chunk.empty()[Symbol.iterator]()))(toChannel(self)));
}));
/** @internal */
exports.collectWhileEffect = collectWhileEffect;
const combine = /*#__PURE__*/(0, _Function.dual)(4, (self, that, s, f) => {
  const producer = (handoff, latch) => channel.zipRight(core.readWithCause(input => core.flatMap(() => producer(handoff, latch))(core.fromEffect(Handoff.offer(Exit.succeed(input))(handoff))), cause => core.fromEffect(Handoff.offer(Exit.failCause(Cause.map(Option.some)(cause)))(handoff)), () => core.flatMap(() => producer(handoff, latch))(core.fromEffect(Handoff.offer(Exit.fail(Option.none()))(handoff)))))(core.fromEffect(Handoff.take(latch)));
  return new StreamImpl(channel.unwrapScoped(Effect.gen(function* ($) {
    const left = yield* $(Handoff.make());
    const right = yield* $(Handoff.make());
    const latchL = yield* $(Handoff.make());
    const latchR = yield* $(Handoff.make());
    yield* $(Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left, latchL))(channel.concatMap(channel.writeChunk)(toChannel(self))))));
    yield* $(Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right, latchR))(channel.concatMap(channel.writeChunk)(toChannel(that))))));
    const pullLeft = Effect.zipRight(Effect.flatMap(Effect.done)(Handoff.take(left)))(Handoff.offer(void 0)(latchL));
    const pullRight = Effect.zipRight(Effect.flatMap(Effect.done)(Handoff.take(right)))(Handoff.offer(void 0)(latchR));
    return toChannel(unfoldEffect(s, s => Effect.flatMap(exit => Effect.unsome(Effect.done(exit)))(f(s, pullLeft, pullRight))));
  })));
});
/** @internal */
exports.combine = combine;
const combineChunks = /*#__PURE__*/(0, _Function.dual)(4, (self, that, s, f) => {
  const producer = (handoff, latch) => channel.zipRight(core.readWithCause(input => core.flatMap(() => producer(handoff, latch))(core.fromEffect(Handoff.offer(_take.chunk(input))(handoff))), cause => core.fromEffect(Handoff.offer(_take.failCause(cause))(handoff)), () => core.flatMap(() => producer(handoff, latch))(core.fromEffect(Handoff.offer(_take.end)(handoff)))))(core.fromEffect(Handoff.take(latch)));
  return new StreamImpl(channel.unwrapScoped(Effect.map(([left, right, latchL, latchR]) => {
    const pullLeft = Effect.zipRight(Effect.flatMap(_take.done)(Handoff.take(left)))(Handoff.offer(void 0)(latchL));
    const pullRight = Effect.zipRight(Effect.flatMap(_take.done)(Handoff.take(right)))(Handoff.offer(void 0)(latchR));
    return toChannel(unfoldChunkEffect(s, s => Effect.flatMap(exit => Effect.unsome(Effect.done(exit)))(f(s, pullLeft, pullRight))));
  })(Effect.tap(([_, right, __, latchR]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right, latchR))(toChannel(that)))))(Effect.tap(([left, _, latchL]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left, latchL))(toChannel(self)))))(Effect.all(Handoff.make(), Handoff.make(), Handoff.make(), Handoff.make()))))));
});
/** @internal */
exports.combineChunks = combineChunks;
const concat = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new StreamImpl(channel.zipRight(toChannel(that))(toChannel(self))));
/** @internal */
exports.concat = concat;
const concatAll = streams => suspend(() => Chunk.reduce(empty, (x, y) => concat(y)(x))(streams));
/** @internal */
exports.concatAll = concatAll;
const cross = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => crossWith(that, (a, a2) => [a, a2])(self));
/** @internal */
exports.cross = cross;
const crossLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => crossWith(that, (a, _) => a)(self));
/** @internal */
exports.crossLeft = crossLeft;
const crossRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => flatMap(self, () => that));
/** @internal */
exports.crossRight = crossRight;
const crossWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => flatMap(a => map(b => f(a, b))(that))(self));
/** @internal */
exports.crossWith = crossWith;
const debounce = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => unwrap(Effect.flatMap(input => Effect.transplant(grafter => Effect.map(handoff => {
  const enqueue = last => Effect.map(fiber => consumer(DebounceState.previous(fiber)))(grafter(Effect.fork(Effect.as(last)(Clock.sleep(duration)))));
  const producer = core.readWithCause(input => Option.match(() => producer, last => core.flatMap(() => producer)(core.fromEffect(Handoff.offer(HandoffSignal.emit(Chunk.of(last)))(handoff))))(Chunk.last(input)), cause => core.fromEffect(Handoff.offer(HandoffSignal.halt(cause))(handoff)), () => core.fromEffect(Handoff.offer(HandoffSignal.end(SinkEndReason.UpstreamEnd))(handoff)));
  const consumer = state => {
    switch (state._tag) {
      case DebounceState.OP_NOT_STARTED:
        {
          return channel.unwrap(Effect.map(signal => {
            switch (signal._tag) {
              case HandoffSignal.OP_EMIT:
                {
                  return channel.unwrap(enqueue(signal.elements));
                }
              case HandoffSignal.OP_HALT:
                {
                  return core.failCause(signal.cause);
                }
              case HandoffSignal.OP_END:
                {
                  return core.unit();
                }
            }
          })(Handoff.take(handoff)));
        }
      case DebounceState.OP_PREVIOUS:
        {
          return channel.unwrap(Effect.raceWith(Handoff.take(handoff), (leftExit, current) => Exit.match(cause => Effect.as(core.failCause(cause))(Fiber.interrupt(current)), chunk => Effect.succeed(core.flatMap(() => consumer(DebounceState.current(current)))(core.write(chunk))))(leftExit), (rightExit, previous) => Exit.match(cause => Effect.as(core.failCause(cause))(Fiber.interrupt(previous)), signal => {
            switch (signal._tag) {
              case HandoffSignal.OP_EMIT:
                {
                  return Effect.zipRight(enqueue(signal.elements))(Fiber.interrupt(previous));
                }
              case HandoffSignal.OP_HALT:
                {
                  return Effect.as(core.failCause(signal.cause))(Fiber.interrupt(previous));
                }
              case HandoffSignal.OP_END:
                {
                  return Effect.map(chunk => channel.zipRight(core.unit())(core.write(chunk)))(Fiber.join(previous));
                }
            }
          })(rightExit))(Fiber.join(state.fiber)));
        }
      case DebounceState.OP_CURRENT:
        {
          return channel.unwrap(Effect.map(signal => {
            switch (signal._tag) {
              case HandoffSignal.OP_EMIT:
                {
                  return channel.unwrap(enqueue(signal.elements));
                }
              case HandoffSignal.OP_HALT:
                {
                  return core.failCause(signal.cause);
                }
              case HandoffSignal.OP_END:
                {
                  return core.unit();
                }
            }
          })(Fiber.join(state.fiber)));
        }
    }
  };
  const debounceChannel = channel.unwrapScoped(Effect.as(core.embedInput(input)(consumer(DebounceState.notStarted)))(Effect.forkScoped(channelExecutor.run(core.pipeTo(producer)(channel.fromInput(input))))));
  return new StreamImpl(core.pipeTo(debounceChannel)(toChannel(self)));
})(Handoff.make())))(singleProducerAsyncInput.make())));
/** @internal */
exports.debounce = debounce;
const die = defect => fromEffect(Effect.die(defect));
/** @internal */
exports.die = die;
const dieSync = evaluate => fromEffect(Effect.dieSync(evaluate));
/** @internal */
exports.dieSync = dieSync;
const dieMessage = message => fromEffect(Effect.dieMessage(message));
/** @internal */
exports.dieMessage = dieMessage;
const distributedWith = /*#__PURE__*/(0, _Function.dual)(4, (self, n, maximumLag, decide) => Effect.flatMap(deferred => Effect.flatMap(next => Effect.flatMap(entries => {
  const [mappings, queues] = Chunk.reduceRight([new Map(), Chunk.empty()], ([mappings, queues], [mapping, queue]) => [mappings.set(mapping[0], mapping[1]), Chunk.prepend(queue)(queues)])(entries);
  return Effect.as(Array.from(queues))(Deferred.succeed(deferred, a => Effect.map(decide(a), f => key => f(mappings.get(key)))));
})(Effect.collectAll(Chunk.map(id => Effect.map(next, ([key, queue]) => [[key, id], queue]))(Chunk.range(0, n - 1)))))(distributedWithDynamic(maximumLag, a => Effect.flatMap(Deferred.await(deferred), f => f(a)))(self)))(Deferred.make()));
/** @internal */
exports.distributedWith = distributedWith;
const distributedWithDynamicId = {
  ref: 0
};
const newDistributedWithDynamicId = () => {
  const current = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current + 1;
  return current;
};
/** @internal */
const distributedWithDynamic = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, maximumLag, decide) => distributedWithDynamicCallback(self, maximumLag, decide, () => Effect.unit()).traced(trace));
exports.distributedWithDynamic = distributedWithDynamic;
const distributedWithDynamicCallback = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, maximumLag, decide, done) => Effect.flatMap(queuesRef => Effect.gen(function* ($) {
  const offer = a => Effect.asUnit(Effect.flatMap(shouldProcess => Effect.flatMap(queues => Effect.flatMap(ids => {
    if (Chunk.isNonEmpty(ids)) {
      return Ref.update(queuesRef, map => {
        for (const id of ids) {
          map.delete(id);
        }
        return map;
      });
    }
    return Effect.unit();
  })(Effect.reduce(Chunk.empty(), (acc, [id, queue]) => {
    if (shouldProcess(id)) {
      return Effect.matchCauseEffect(cause =>
      // Ignore all downstream queues that were shut
      // down and remove them later
      Cause.isInterrupted(cause) ? Effect.succeed(Chunk.prepend(id)(acc)) : Effect.failCause(cause), () => Effect.succeed(acc))(Queue.offer(queue, Exit.succeed(a)));
    }
    return Effect.succeed(acc);
  })(queues.entries())))(Ref.get(queuesRef)))(decide(a)));
  const queuesLock = yield* $(Effect.makeSemaphore(1));
  const newQueue = yield* $(Ref.make(Effect.flatMap(queue => {
    const id = newDistributedWithDynamicId();
    return Effect.as([id, queue])(Ref.update(queuesRef, map => map.set(id, queue)));
  })(Queue.bounded(maximumLag))));
  const finalize = endTake =>
  // Make sure that no queues are currently being added
  queuesLock.withPermits(1)(Effect.asUnit(Effect.zipRight(done(endTake))(Effect.zipRight(Effect.flatMap(map => Effect.forEach(queue => Effect.catchSomeCause(cause => Cause.isInterrupted(cause) ? Option.some(Effect.unit()) : Option.none())(Queue.offer(queue, endTake)))(Chunk.fromIterable(map.values())))(Ref.get(queuesRef)))(Ref.set(newQueue, Effect.flatMap(queue => {
    const id = newDistributedWithDynamicId();
    return Effect.as([id, queue])(Ref.update(queuesRef, map => map.set(id, queue)));
  })(Effect.tap(queue => Queue.offer(queue, endTake))(
  // All newly created queues should end immediately
  Queue.bounded(1))))))));
  yield* $(Effect.forkScoped(Effect.matchCauseEffect(cause => finalize(Exit.failCause(Cause.map(Option.some)(cause))), () => finalize(Exit.fail(Option.none())))(runForEachScoped(offer)(self))));
  return queuesLock.withPermits(1)(Effect.flatten(Ref.get(newQueue)));
}))(Effect.acquireRelease(Ref.make(new Map()), (ref, _) => Effect.flatMap(queues => Effect.forEach(Queue.shutdown)(queues.values()))(Ref.get(ref)))).traced(trace));
/** @internal */
exports.distributedWithDynamicCallback = distributedWithDynamicCallback;
const done = exit => fromEffect(Effect.done(exit));
/** @internal */
exports.done = done;
const drain = self => new StreamImpl(channel.drain(toChannel(self)));
/** @internal */
exports.drain = drain;
const drainFork = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => flatMap(backgroundDied => crossRight(interruptWhenDeferred(backgroundDied)(self))(scoped(Effect.forkScoped(Effect.catchAllCause(cause => Deferred.failCause(backgroundDied, cause))(runForEachScoped(() => Effect.unit())(that))))))(fromEffect(Deferred.make())));
/** @internal */
exports.drainFork = drainFork;
const drop = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const loop = r => core.readWith(input => {
    const dropped = Chunk.drop(r)(input);
    const leftover = Math.max(0, r - input.length);
    const more = Chunk.isEmpty(input) || leftover > 0;
    if (more) {
      return loop(leftover);
    }
    return channel.zipRight(channel.identityChannel())(core.write(dropped));
  }, core.fail, core.unit);
  return new StreamImpl(channel.pipeToOrFail(loop(n))(toChannel(self)));
});
/** @internal */
exports.drop = drop;
const dropRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend(() => {
    const queue = new _support.RingBuffer(n);
    const reader = core.readWith(input => {
      const outputs = Chunk.filterMap(elem => {
        const head = queue.head();
        queue.put(elem);
        return head;
      })(input);
      return core.flatMap(() => reader)(core.write(outputs));
    }, core.fail, core.unit);
    return new StreamImpl(channel.pipeToOrFail(reader)(toChannel(self)));
  });
});
/** @internal */
exports.dropRight = dropRight;
const dropUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => drop(1)(dropWhile(a => !predicate(a))(self)));
/** @internal */
exports.dropUntil = dropUntil;
const dropUntilEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith(input => channel.unwrap(Effect.map(leftover => {
    const more = Chunk.isEmpty(leftover);
    if (more) {
      return core.suspend(() => loop);
    }
    return channel.zipRight(channel.identityChannel())(core.write(leftover));
  })(Effect.dropUntil(predicate)(input))), core.fail, core.unit);
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
exports.dropUntilEffect = dropUntilEffect;
const dropWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith(input => {
    const output = Chunk.dropWhile(predicate)(input);
    if (Chunk.isEmpty(output)) {
      return core.suspend(() => loop);
    }
    return channel.zipRight(channel.identityChannel())(core.write(output));
  }, core.fail, core.succeedNow);
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
exports.dropWhile = dropWhile;
const dropWhileEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith(input => channel.unwrap(Effect.map(leftover => {
    const more = Chunk.isEmpty(leftover);
    if (more) {
      return core.suspend(() => loop);
    }
    return channel.zipRight(channel.identityChannel())(core.write(leftover));
  })(Effect.dropWhile(predicate)(input))), core.fail, core.unit);
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
exports.dropWhileEffect = dropWhileEffect;
const either = self => catchAll(error => make(Either.left(error)))(map(Either.right)(self));
/** @internal */
exports.either = either;
const empty = /*#__PURE__*/new StreamImpl( /*#__PURE__*/core.write( /*#__PURE__*/Chunk.empty()));
/** @internal */
exports.empty = empty;
const ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new StreamImpl(channel.ensuring(finalizer)(toChannel(self))));
/** @internal */
exports.ensuring = ensuring;
const context = () => fromEffect(Effect.context());
/** @internal */
exports.context = context;
const contextWith = f => map(f)(context());
/** @internal */
exports.contextWith = contextWith;
const contextWithEffect = f => mapEffect(f)(context());
/** @internal */
exports.contextWithEffect = contextWithEffect;
const contextWithStream = f => flatMap(f)(context());
/** @internal */
exports.contextWithStream = contextWithStream;
const execute = effect => drain(fromEffect(effect));
/** @internal */
exports.execute = execute;
const fail = error => fromEffectOption(Effect.fail(Option.some(error)));
/** @internal */
exports.fail = fail;
const failSync = evaluate => fromEffectOption(Effect.failSync(() => Option.some(evaluate())));
/** @internal */
exports.failSync = failSync;
const failCause = cause => fromEffect(Effect.failCause(cause));
/** @internal */
exports.failCause = failCause;
const failCauseSync = evaluate => fromEffect(Effect.failCauseSync(evaluate));
/** @internal */
exports.failCauseSync = failCauseSync;
const filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => mapChunks(self, Chunk.filter(predicate)));
/** @internal */
exports.filter = filter;
const filterEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause(input => loop(input[Symbol.iterator]()), core.failCause, core.succeed);
    } else {
      return channel.unwrap(Effect.map(bool => bool ? core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value))) : loop(iterator))(f(next.value)));
    }
  };
  return new StreamImpl(core.suspend(() => core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(toChannel(self))));
});
/** @internal */
exports.filterEffect = filterEffect;
const finalizer = finalizer => acquireRelease(Effect.unit(), () => finalizer);
/** @internal */
exports.finalizer = finalizer;
const find = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith(input => Option.match(() => loop, n => core.write(Chunk.of(n)))(Chunk.findFirst(predicate)(input)), core.fail, core.unit);
  return new StreamImpl(core.pipeTo(loop)(toChannel(self)));
});
/** @internal */
exports.find = find;
const findEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith(input => channel.unwrap(Effect.map(Option.match(() => loop, n => core.write(Chunk.of(n))))(Effect.find(predicate)(input))), core.fail, core.unit);
  return new StreamImpl(core.pipeTo(loop)(toChannel(self)));
});
/** @internal */
exports.findEffect = findEffect;
const flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.concatMap(as => Chunk.reduce(core.unit(), (left, right) => channel.zipRight(right)(left))(Chunk.map(a => toChannel(f(a)))(as)))(toChannel(self))));
/** @internal */
exports.flatMap = flatMap;
const flatMapPar = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => flatMapParBuffer(self, n, 16, f));
/** @internal */
exports.flatMapPar = flatMapPar;
const flatMapParBuffer = /*#__PURE__*/(0, _Function.dual)(4, (self, n, bufferSize, f) => new StreamImpl(channel.mergeMapBuffer(out => toChannel(f(out)), n, bufferSize)(channel.concatMap(channel.writeChunk)(toChannel(self)))));
/** @internal */
exports.flatMapParBuffer = flatMapParBuffer;
const flatMapParSwitch = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => flatMapParSwitchBuffer(self, n, 16, f));
/** @internal */
exports.flatMapParSwitch = flatMapParSwitch;
const flatMapParSwitchBuffer = /*#__PURE__*/(0, _Function.dual)(4, (self, n, bufferSize, f) => new StreamImpl(channel.mergeMapBufferStrategy(out => toChannel(f(out)), n, bufferSize, MergeStrategy.BufferSliding())(channel.concatMap(channel.writeChunk)(toChannel(self)))));
/** @internal */
exports.flatMapParSwitchBuffer = flatMapParSwitchBuffer;
const flatten = self => flatMap(_Function.identity)(self);
/** @internal */
exports.flatten = flatten;
const flattenChunks = self => {
  const flatten = core.readWithCause(chunks => core.flatMap(() => flatten)(channel.writeChunk(chunks)), core.failCause, core.unit);
  return new StreamImpl(core.pipeTo(flatten)(toChannel(self)));
};
/** @internal */
exports.flattenChunks = flattenChunks;
const flattenEffect = self => mapEffect(_Function.identity)(self);
/** @internal */
exports.flattenEffect = flattenEffect;
const flattenExit = self => mapEffect(Effect.done)(self);
/** @internal */
exports.flattenExit = flattenExit;
const flattenExitOption = self => {
  const processChunk = (chunk, cont) => {
    const [toEmit, rest] = Chunk.splitWhere(exit => !Exit.isSuccess(exit))(chunk);
    const next = Option.match(() => cont, Exit.match(cause => Option.match(core.unit, core.failCause)(Cause.flipCauseOption(cause)), core.unit))(Chunk.head(rest));
    return core.flatMap(() => next)(core.write(Chunk.filterMap(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none())(toEmit)));
  };
  const process = core.readWithCause(chunk => processChunk(chunk, process), cause => core.failCause(cause), () => core.unit());
  return new StreamImpl(core.pipeTo(process)(toChannel(self)));
};
/** @internal */
exports.flattenExitOption = flattenExitOption;
const flattenIterables = self => flattenChunks(map(Chunk.fromIterable)(self));
/** @internal */
exports.flattenIterables = flattenIterables;
const flattenPar = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => flattenParBuffer(self, n, 16));
/** @internal */
exports.flattenPar = flattenPar;
const flattenParBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, n, bufferSize) => flatMapParBuffer(self, n, bufferSize, _Function.identity));
/** @internal */
exports.flattenParBuffer = flattenParBuffer;
const flattenParUnbounded = self => flattenParUnboundedBuffer(self, 16);
/** @internal */
exports.flattenParUnbounded = flattenParUnbounded;
const flattenParUnboundedBuffer = /*#__PURE__*/(0, _Function.dual)(2, (self, bufferSize) => flatMapParBuffer(self, Number.POSITIVE_INFINITY, bufferSize, _Function.identity));
/** @internal */
exports.flattenParUnboundedBuffer = flattenParUnboundedBuffer;
const flattenTake = self => flattenChunks(flattenExitOption(map(take => take.exit)(self)));
/** @internal */
exports.flattenTake = flattenTake;
const forever = self => new StreamImpl(channel.repeated(toChannel(self)));
/** @internal */
exports.forever = forever;
const fromAsyncIterable = (iterable, onError) => unwrapScoped(Effect.map(iterator => repeatEffectOption(Effect.flatMap(result => result.done ? Effect.fail(Option.none()) : Effect.succeed(result.value))(Effect.tryCatchPromise(() => iterator.next(), reason => Option.some(onError(reason))))))(Effect.acquireRelease(Effect.sync(() => iterable[Symbol.asyncIterator]()), iterator => iterator.return ? Effect.promise(() => iterator.return()) : Effect.unit())));
/** @internal */
exports.fromAsyncIterable = fromAsyncIterable;
const fromChannel = channel => new StreamImpl(channel);
/** @internal */
exports.fromChannel = fromChannel;
const toChannel = stream => Context.isGenericTag(stream) ? toChannel(fromEffect(stream)) : stream.channel;
/** @internal */
exports.toChannel = toChannel;
const fromChunk = chunk => new StreamImpl(Chunk.isEmpty(chunk) ? core.unit() : core.write(chunk));
/** @internal */
exports.fromChunk = fromChunk;
const fromChunkHub = hub => flatMap(fromChunkQueue)(scoped(Hub.subscribe(hub)));
/** @internal */
exports.fromChunkHub = fromChunkHub;
const fromChunkHubScoped = hub => Effect.map(fromChunkQueue)(Hub.subscribe(hub));
/** @internal */
exports.fromChunkHubScoped = fromChunkHubScoped;
const fromChunkHubWithShutdown = hub => ensuring(Hub.shutdown(hub))(fromChunkHub(hub));
/** @internal */
exports.fromChunkHubWithShutdown = fromChunkHubWithShutdown;
const fromChunkHubScopedWithShutdown = hub => Effect.map(ensuring(Hub.shutdown(hub)))(fromChunkHubScoped(hub));
/** @internal */
exports.fromChunkHubScopedWithShutdown = fromChunkHubScopedWithShutdown;
const fromChunkQueue = queue => repeatEffectChunkOption(Effect.catchAllCause(cause => Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause))(Queue.isShutdown(queue)))(Queue.take(queue)));
/** @internal */
exports.fromChunkQueue = fromChunkQueue;
const fromChunkQueueWithShutdown = queue => ensuring(Queue.shutdown(queue))(fromChunkQueue(queue));
/** @internal */
exports.fromChunkQueueWithShutdown = fromChunkQueueWithShutdown;
const fromChunks = (...chunks) => flatMap(fromChunk)(fromIterable(chunks));
/** @internal */
exports.fromChunks = fromChunks;
const fromEffect = effect => fromEffectOption(Effect.mapError(Option.some)(effect));
/** @internal */
exports.fromEffect = fromEffect;
const fromEffectOption = effect => new StreamImpl(channel.unwrap(Effect.match(Option.match(core.unit, core.fail), a => core.write(Chunk.of(a)))(effect)));
/** @internal */
exports.fromEffectOption = fromEffectOption;
const fromHub = (hub, maxChunkSize = DefaultChunkSize) => flatMap(queue => fromQueue(queue, maxChunkSize))(scoped(Hub.subscribe(hub)));
/** @internal */
exports.fromHub = fromHub;
const fromHubScoped = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => (hub, maxChunkSize = DefaultChunkSize) => Effect.suspend(() => Effect.map(queue => fromQueueWithShutdown(queue, maxChunkSize))(Hub.subscribe(hub))).traced(trace));
/** @internal */
exports.fromHubScoped = fromHubScoped;
const fromHubWithShutdown = (hub, maxChunkSize = DefaultChunkSize) => ensuring(Hub.shutdown(hub))(fromHub(hub, maxChunkSize));
/** @internal */
exports.fromHubWithShutdown = fromHubWithShutdown;
const fromHubScopedWithShutdown = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => (hub, maxChunkSize = DefaultChunkSize) => Effect.map(ensuring(Hub.shutdown(hub)))(fromHubScoped(hub, maxChunkSize)).traced(trace));
/** @internal */
exports.fromHubScopedWithShutdown = fromHubScopedWithShutdown;
const fromIterable = iterable => suspend(() => Chunk.isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
/** @internal */
exports.fromIterable = fromIterable;
const fromIterableEffect = effect => unwrap(Effect.map(fromIterable)(effect));
/** @internal */
exports.fromIterableEffect = fromIterableEffect;
const fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return unwrap(Effect.sync(() => {
    let builder = [];
    const loop = iterator => channel.unwrap(Effect.sync(() => {
      let next = iterator.next();
      if (maxChunkSize === 1) {
        if (next.done) {
          return core.unit();
        }
        return core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value)));
      }
      builder = [];
      let count = 0;
      while (count < maxChunkSize && !next.done) {
        builder.push(next.value);
        next = iterator.next();
        count = count + 1;
      }
      if (count > 0) {
        return core.flatMap(() => loop(iterator))(core.write(Chunk.unsafeFromArray(builder)));
      }
      return core.unit();
    }));
    return new StreamImpl(loop(iterator));
  }));
};
/** @internal */
exports.fromIteratorSucceed = fromIteratorSucceed;
const fromPull = effect => unwrapScoped(Effect.map(repeatEffectChunkOption)(effect));
/** @internal */
exports.fromPull = fromPull;
const fromQueue = (queue, maxChunkSize = DefaultChunkSize) => repeatEffectChunkOption(Effect.catchAllCause(cause => Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause))(Queue.isShutdown(queue)))(Queue.takeBetween(queue, 1, maxChunkSize)));
/** @internal */
exports.fromQueue = fromQueue;
const fromQueueWithShutdown = (queue, maxChunkSize = DefaultChunkSize) => ensuring(Queue.shutdown(queue))(fromQueue(queue, maxChunkSize));
/** @internal */
exports.fromQueueWithShutdown = fromQueueWithShutdown;
const fromSchedule = schedule => unwrap(Effect.map(driver => repeatEffectOption(driver.next(void 0)))(Schedule.driver(schedule)));
/** @internal */
exports.fromSchedule = fromSchedule;
const groupAdjacentBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const go = (input, state) => Chunk.reduce([Chunk.empty(), state], ([outputs, option], a) => {
    if (Option.isSome(option)) {
      const key = option.value[0];
      const aggregated = option.value[1];
      const key2 = f(a);
      if (Equal.equals(key2)(key)) {
        return [outputs, Option.some([key, Chunk.append(a)(aggregated)])];
      }
      return [Chunk.append(option.value)(outputs), Option.some([key2, Chunk.of(a)])];
    }
    return [outputs, Option.some([f(a), Chunk.of(a)])];
  })(input);
  const chunkAdjacent = buffer => core.readWithCause(input => {
    const [outputs, newBuffer] = go(input, buffer);
    return core.flatMap(() => chunkAdjacent(newBuffer))(core.write(outputs));
  }, core.failCause, () => Option.match(core.unit, output => core.write(Chunk.of(output)))(buffer));
  return new StreamImpl(channel.pipeToOrFail(chunkAdjacent(Option.none()))(toChannel(self)));
});
/** @internal */
exports.groupAdjacentBy = groupAdjacentBy;
const grouped = /*#__PURE__*/(0, _Function.dual)(2, (self, chunkSize) => chunks(rechunk(chunkSize)(self)));
/** @internal */
exports.grouped = grouped;
const groupedWithin = /*#__PURE__*/(0, _Function.dual)(3, (self, chunkSize, duration) => aggregateWithin(_sink.collectAllN(chunkSize), Schedule.spaced(duration))(self));
/** @internal */
exports.groupedWithin = groupedWithin;
const haltWhen = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => {
  const writer = fiber => channel.unwrap(Effect.map(Option.match(() => core.readWith(input => core.flatMap(() => writer(fiber))(core.write(input)), core.fail, core.unit), Exit.match(core.failCause, core.unit)))(Fiber.poll(fiber)));
  return new StreamImpl(channel.unwrapScoped(Effect.map(fiber => core.pipeTo(writer(fiber))(toChannel(self)))(Effect.forkScoped(effect))));
});
/** @internal */
exports.haltWhen = haltWhen;
const haltAfter = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => haltWhen(Clock.sleep(duration))(self));
/** @internal */
exports.haltAfter = haltAfter;
const haltWhenDeferred = /*#__PURE__*/(0, _Function.dual)(2, (self, deferred) => {
  const writer = channel.unwrap(Effect.map(Option.match(() => core.readWith(input => core.flatMap(() => writer)(core.write(input)), core.fail, core.unit), effect => channel.unwrap(Effect.match(core.fail, core.unit)(effect))))(Deferred.poll(deferred)));
  return new StreamImpl(core.pipeTo(writer)(toChannel(self)));
});
/** @internal */
exports.haltWhenDeferred = haltWhenDeferred;
const identityStream = () => new StreamImpl(channel.identityChannel());
/** @internal */
exports.identityStream = identityStream;
const interleave = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => interleaveWith(that, forever(make(true, false)))(self));
/** @internal */
exports.interleave = interleave;
const interleaveWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, decider) => {
  const producer = handoff => core.readWithCause(value => core.flatMap(() => producer(handoff))(core.fromEffect(Handoff.offer(_take.of(value))(handoff))), cause => core.fromEffect(Handoff.offer(_take.failCause(cause))(handoff)), () => core.fromEffect(Handoff.offer(_take.end)(handoff)));
  return new StreamImpl(channel.unwrapScoped(Effect.map(([left, right]) => {
    const process = (leftDone, rightDone) => core.readWithCause(bool => {
      if (bool && !leftDone) {
        return core.flatMap(_take.match(() => rightDone ? core.unit() : process(true, rightDone), core.failCause, chunk => core.flatMap(() => process(leftDone, rightDone))(core.write(chunk))))(core.fromEffect(Handoff.take(left)));
      }
      if (!bool && !rightDone) {
        return core.flatMap(_take.match(() => leftDone ? core.unit() : process(leftDone, true), core.failCause, chunk => core.flatMap(() => process(leftDone, rightDone))(core.write(chunk))))(core.fromEffect(Handoff.take(right)));
      }
      return process(leftDone, rightDone);
    }, core.failCause, core.unit);
    return core.pipeTo(process(false, false))(channel.concatMap(channel.writeChunk)(toChannel(decider)));
  })(Effect.tap(([_, right]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right))(channel.concatMap(channel.writeChunk)(toChannel(that))))))(Effect.tap(([left]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left))(channel.concatMap(channel.writeChunk)(toChannel(self))))))(Effect.zip(Handoff.make())(Handoff.make()))))));
});
/** @internal */
exports.interleaveWith = interleaveWith;
const intersperse = /*#__PURE__*/(0, _Function.dual)(2, (self, element) => new StreamImpl(channel.pipeToOrFail(core.suspend(() => {
  const writer = isFirst => core.readWithCause(chunk => {
    const builder = [];
    let flagResult = isFirst;
    for (const output of chunk) {
      if (flagResult) {
        flagResult = false;
        builder.push(output);
      } else {
        builder.push(element);
        builder.push(output);
      }
    }
    return core.flatMap(() => writer(flagResult))(core.write(Chunk.unsafeFromArray(builder)));
  }, core.failCause, core.unit);
  return writer(true);
}))(toChannel(self))));
/** @internal */
exports.intersperse = intersperse;
const intersperseAffixes = /*#__PURE__*/(0, _Function.dual)(4, (self, start, middle, end) => concat(make(end))(concat(intersperse(middle)(self))(make(start))));
/** @internal */
exports.intersperseAffixes = intersperseAffixes;
const interruptAfter = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => interruptWhen(Clock.sleep(duration))(self));
/** @internal */
exports.interruptAfter = interruptAfter;
const interruptWhen = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => new StreamImpl(channel.interruptWhen(effect)(toChannel(self))));
/** @internal */
exports.interruptWhen = interruptWhen;
const interruptWhenDeferred = /*#__PURE__*/(0, _Function.dual)(2, (self, deferred) => new StreamImpl(channel.interruptWhenDeferred(deferred)(toChannel(self))));
/** @internal */
exports.interruptWhenDeferred = interruptWhenDeferred;
const iterate = (value, next) => unfold(value, a => Option.some([a, next(a)]));
/** @internal */
exports.iterate = iterate;
const log = message => fromEffect(Effect.log(message));
/** @internal */
exports.log = log;
const logDebug = message => fromEffect(Effect.logDebug(message));
/** @internal */
exports.logDebug = logDebug;
const logDebugCause = cause => fromEffect(Effect.logDebugCause(cause));
/** @internal */
exports.logDebugCause = logDebugCause;
const logDebugCauseMessage = (message, cause) => fromEffect(Effect.logDebugCauseMessage(message, cause));
/** @internal */
exports.logDebugCauseMessage = logDebugCauseMessage;
const logError = message => fromEffect(Effect.logError(message));
/** @internal */
exports.logError = logError;
const logErrorCause = cause => fromEffect(Effect.logErrorCause(cause));
/** @internal */
exports.logErrorCause = logErrorCause;
const logErrorCauseMessage = (message, cause) => fromEffect(Effect.logErrorCauseMessage(message, cause));
/** @internal */
exports.logErrorCauseMessage = logErrorCauseMessage;
const logFatal = message => fromEffect(Effect.logFatal(message));
/** @internal */
exports.logFatal = logFatal;
const logFatalCause = cause => fromEffect(Effect.logFatalCause(cause));
/** @internal */
exports.logFatalCause = logFatalCause;
const logFatalCauseMessage = (message, cause) => fromEffect(Effect.logFatalCauseMessage(message, cause));
/** @internal */
exports.logFatalCauseMessage = logFatalCauseMessage;
const logInfo = message => fromEffect(Effect.logInfo(message));
/** @internal */
exports.logInfo = logInfo;
const logInfoCause = cause => fromEffect(Effect.logInfoCause(cause));
/** @internal */
exports.logInfoCause = logInfoCause;
const logInfoCauseMessage = (message, cause) => fromEffect(Effect.logInfoCauseMessage(message, cause));
/** @internal */
exports.logInfoCauseMessage = logInfoCauseMessage;
const logWarning = message => fromEffect(Effect.logWarning(message));
/** @internal */
exports.logWarning = logWarning;
const logWarningCause = cause => fromEffect(Effect.logWarningCause(cause));
/** @internal */
exports.logWarningCause = logWarningCause;
const logWarningCauseMessage = (message, cause) => fromEffect(Effect.logWarningCauseMessage(message, cause));
/** @internal */
exports.logWarningCauseMessage = logWarningCauseMessage;
const logTrace = message => fromEffect(Effect.logTrace(message));
/** @internal */
exports.logTrace = logTrace;
const logTraceCause = cause => fromEffect(Effect.logTraceCause(cause));
/** @internal */
exports.logTraceCause = logTraceCause;
const logTraceCauseMessage = (message, cause) => fromEffect(Effect.logTraceCauseMessage(message, cause));
/** @internal */
exports.logTraceCauseMessage = logTraceCauseMessage;
const make = (...as) => fromIterable(as);
/** @internal */
exports.make = make;
const map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapOut(Chunk.map(f))(toChannel(self))));
/** @internal */
exports.map = map;
const mapAccum = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => {
  const accumulator = s => core.readWith(input => {
    const [nextS, chunk] = Chunk.mapAccum(s, f)(input);
    return core.flatMap(() => accumulator(nextS))(core.write(chunk));
  }, core.fail, core.unit);
  return new StreamImpl(core.pipeTo(accumulator(s))(toChannel(self)));
});
/** @internal */
exports.mapAccum = mapAccum;
const mapAccumEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => suspend(() => {
  const accumulator = s => core.readWith(input => channel.unwrap(Effect.suspend(() => {
    const outputs = [];
    const emit = output => Effect.sync(() => {
      outputs.push(output);
    });
    return Effect.match(error => {
      if (outputs.length !== 0) {
        return channel.zipRight(core.fail(error))(core.write(Chunk.unsafeFromArray(outputs)));
      }
      return core.fail(error);
    }, s => core.flatMap(() => accumulator(s))(core.write(Chunk.unsafeFromArray(outputs))))(Effect.reduce(s, (s, a) => Effect.flatMap(([s, a]) => Effect.as(s)(emit(a)))(f(s, a)))(input));
  })), core.fail, core.unit);
  return new StreamImpl(channel.pipeToOrFail(accumulator(s))(toChannel(self)));
}));
/** @internal */
exports.mapAccumEffect = mapAccumEffect;
const mapBoth = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => map(g)(mapError(f)(self)));
/** @internal */
exports.mapBoth = mapBoth;
const mapChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapOut(f)(toChannel(self))));
/** @internal */
exports.mapChunks = mapChunks;
const mapChunksEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapOutEffect(f)(toChannel(self))));
/** @internal */
exports.mapChunksEffect = mapChunksEffect;
const mapConcat = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapConcatChunk(a => Chunk.fromIterable(f(a)))(self));
/** @internal */
exports.mapConcat = mapConcat;
const mapConcatChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapChunks(Chunk.flatMap(f))(self));
/** @internal */
exports.mapConcatChunk = mapConcatChunk;
const mapConcatChunkEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapConcatChunk(_Function.identity)(mapEffect(f)(self)));
/** @internal */
exports.mapConcatChunkEffect = mapConcatChunkEffect;
const mapConcatEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapConcatChunk(_Function.identity)(mapEffect(a => Effect.map(Chunk.fromIterable)(f(a)))(self)));
/** @internal */
exports.mapConcatEffect = mapConcatEffect;
const mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause(elem => loop(elem[Symbol.iterator]()), core.failCause, core.succeed);
    } else {
      const value = next.value;
      return channel.unwrap(Effect.map(f(value), a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator))));
    }
  };
  return new StreamImpl(core.pipeTo(core.suspend(() => loop(Chunk.empty()[Symbol.iterator]())))(toChannel(self)));
});
/** @internal */
exports.mapEffect = mapEffect;
const mapEffectPar = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => new StreamImpl(channel.mapOut(Chunk.of)(channel.mapOutEffectPar(f, n)(channel.concatMap(channel.writeChunk)(toChannel(self))))));
/** @internal */
exports.mapEffectPar = mapEffectPar;
const flattenEffectPar = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => new StreamImpl(channel.mapOut(Chunk.of)(channel.mapOutEffectPar(_Function.identity, n)(channel.concatMap(channel.writeChunk)(toChannel(self))))));
/** @internal */
exports.flattenEffectPar = flattenEffectPar;
const flattenEffectParUnordered = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => flatMapPar(self, n, a => fromEffect(a)));
/** @internal */
exports.flattenEffectParUnordered = flattenEffectParUnordered;
const mapEffectParUnordered = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => flatMapPar(self, n, a => fromEffect(f(a))));
/** @internal */
exports.mapEffectParUnordered = mapEffectParUnordered;
const mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapError(f)(toChannel(self))));
/** @internal */
exports.mapError = mapError;
const mapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapErrorCause(f)(toChannel(self))));
/** @internal */
exports.mapErrorCause = mapErrorCause;
const merge = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeHaltStrategy(self, that, HaltStrategy.Both));
/** @internal */
exports.merge = merge;
const mergeHaltStrategy = /*#__PURE__*/(0, _Function.dual)(3, (self, that, strategy) => mergeWithHaltStrategy(self, that, _Function.identity, _Function.identity, strategy));
/** @internal */
exports.mergeHaltStrategy = mergeHaltStrategy;
const mergeAll = (n, bufferSize = 16) => {
  return (...streams) => flattenParBuffer(n, bufferSize)(fromIterable(streams));
};
/** @internal */
exports.mergeAll = mergeAll;
const mergeAllUnbounded = (bufferSize = 16) => {
  return (...streams) => flattenParBuffer(Number.POSITIVE_INFINITY, bufferSize)(fromIterable(streams));
};
/** @internal */
exports.mergeAllUnbounded = mergeAllUnbounded;
const mergeHaltEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeHaltStrategy(self, that, haltStrategy.Either));
/** @internal */
exports.mergeHaltEither = mergeHaltEither;
const mergeHaltLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeHaltStrategy(self, that, haltStrategy.Left));
/** @internal */
exports.mergeHaltLeft = mergeHaltLeft;
const mergeHaltRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeHaltStrategy(self, that, haltStrategy.Right));
/** @internal */
exports.mergeHaltRight = mergeHaltRight;
const mergeEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeWith(self, that, Either.left, Either.right));
/** @internal */
exports.mergeEither = mergeEither;
const mergeLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => merge(drain(that))(self));
/** @internal */
exports.mergeLeft = mergeLeft;
const mergeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => merge(that)(drain(self)));
/** @internal */
exports.mergeRight = mergeRight;
const mergeWith = /*#__PURE__*/(0, _Function.dual)(4, (self, that, left, right) => mergeWithHaltStrategy(self, that, left, right, HaltStrategy.Both));
/** @internal */
exports.mergeWith = mergeWith;
const mergeWithHaltStrategy = /*#__PURE__*/(0, _Function.dual)(5, (self, that, left, right, strategy) => {
  const handler = terminate => exit => terminate || !Exit.isSuccess(exit) ? MergeDecision.Done(Effect.done(exit)) : MergeDecision.Await(Effect.done);
  return new StreamImpl(channel.mergeWith(toChannel(map(self, left)), toChannel(map(that, right)), handler(strategy._tag === "Either" || strategy._tag === "Left"), handler(strategy._tag === "Either" || strategy._tag === "Right")));
});
/** @internal */
exports.mergeWithHaltStrategy = mergeWithHaltStrategy;
const mkString = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.mkString())(self).traced(trace));
/** @internal */
exports.mkString = mkString;
const never = () => fromEffect(Effect.never());
/** @internal */
exports.never = never;
const onError = /*#__PURE__*/(0, _Function.dual)(2, (self, cleanup) => catchAllCause(cause => fromEffect(Effect.zipRight(Effect.failCause(cause))(cleanup(cause))))(self));
/** @internal */
exports.onError = onError;
const onDone = /*#__PURE__*/(0, _Function.dual)(2, (self, cleanup) => new StreamImpl(core.ensuringWith(exit => Exit.isSuccess(exit) ? cleanup() : Effect.unit())(toChannel(self))));
/** @internal */
exports.onDone = onDone;
const orDie = self => orDieWith(_Function.identity)(self);
/** @internal */
exports.orDie = orDie;
const orDieWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.orDieWith(f)(toChannel(self))));
/** @internal */
exports.orDieWith = orDieWith;
const orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new StreamImpl(channel.orElse(() => toChannel(that()))(toChannel(self))));
/** @internal */
exports.orElse = orElse;
const orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => orElse(() => map(Either.right)(that()))(map(Either.left)(self)));
/** @internal */
exports.orElseEither = orElseEither;
const orElseFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => orElse(() => failSync(error))(self));
/** @internal */
exports.orElseFail = orElseFail;
const orElseIfEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, element) => orElseIfEmptyChunk(() => Chunk.of(element()))(self));
/** @internal */
exports.orElseIfEmpty = orElseIfEmpty;
const orElseIfEmptyChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, chunk) => orElseIfEmptyStream(() => new StreamImpl(core.write(chunk())))(self));
/** @internal */
exports.orElseIfEmptyChunk = orElseIfEmptyChunk;
const orElseIfEmptyStream = /*#__PURE__*/(0, _Function.dual)(2, (self, stream) => {
  const writer = core.readWith(input => {
    if (Chunk.isEmpty(input)) {
      return core.suspend(() => writer);
    }
    return channel.zipRight(channel.identityChannel())(core.write(input));
  }, core.fail, () => core.suspend(() => toChannel(stream())));
  return new StreamImpl(core.pipeTo(writer)(toChannel(self)));
});
/** @internal */
exports.orElseIfEmptyStream = orElseIfEmptyStream;
const orElseOptional = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => catchAll(Option.match(that, error => fail(Option.some(error))))(self));
/** @internal */
exports.orElseOptional = orElseOptional;
const orElseSucceed = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => orElse(() => sync(value))(self));
/** @internal */
exports.orElseSucceed = orElseSucceed;
const paginate = (s, f) => paginateChunk(s, s => {
  const page = f(s);
  return [Chunk.of(page[0]), page[1]];
});
/** @internal */
exports.paginate = paginate;
const paginateChunk = (s, f) => {
  const loop = s => {
    const page = f(s);
    return Option.match(() => channel.zipRight(core.unit())(core.write(page[0])), s => core.flatMap(() => loop(s))(core.write(page[0])))(page[1]);
  };
  return new StreamImpl(core.suspend(() => loop(s)));
};
/** @internal */
exports.paginateChunk = paginateChunk;
const paginateChunkEffect = (s, f) => {
  const loop = s => channel.unwrap(Effect.map(([chunk, option]) => Option.match(() => channel.zipRight(core.unit())(core.write(chunk)), s => core.flatMap(() => loop(s))(core.write(chunk)))(option))(f(s)));
  return new StreamImpl(core.suspend(() => loop(s)));
};
/** @internal */
exports.paginateChunkEffect = paginateChunkEffect;
const paginateEffect = (s, f) => paginateChunkEffect(s, s => Effect.map(([a, s]) => [Chunk.of(a), s])(f(s)));
/** @internal */
exports.paginateEffect = paginateEffect;
const peel = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, sink) => {
  const OP_EMIT = "Emit";
  const OP_HALT = "Halt";
  const OP_END = "End";
  return Effect.flatten(Effect.flatMap(deferred => Effect.map(handoff => {
    const consumer = _sink.foldSink(error => _sink.zipRight(_sink.fail(error))(_sink.fromEffect(Deferred.fail(deferred, error))), ([z, leftovers]) => {
      const loop = core.readWithCause(elements => core.flatMap(() => loop)(core.fromEffect(Handoff.offer({
        _tag: OP_EMIT,
        elements
      })(handoff))), cause => channel.zipRight(core.failCause(cause))(core.fromEffect(Handoff.offer({
        _tag: OP_HALT,
        cause
      })(handoff))), _ => channel.zipRight(core.unit())(core.fromEffect(Handoff.offer({
        _tag: OP_END
      })(handoff))));
      return _sink.fromChannel(channel.zipRight(loop)(channel.zipRight(core.fromEffect(Handoff.offer({
        _tag: OP_EMIT,
        elements: leftovers
      })(handoff)))(core.fromEffect(Deferred.succeed(deferred, z)))));
    })(_sink.collectLeftover(sink));
    const producer = channel.unwrap(Effect.map(signal => {
      switch (signal._tag) {
        case OP_EMIT:
          {
            return core.flatMap(() => producer)(core.write(signal.elements));
          }
        case OP_HALT:
          {
            return core.failCause(signal.cause);
          }
        case OP_END:
          {
            return core.unit();
          }
      }
    })(Handoff.take(handoff)));
    return Effect.map(z => [z, new StreamImpl(producer)])(Effect.zipRight(Deferred.await(deferred))(Effect.forkScoped(run(consumer)(tapErrorCause(cause => Deferred.failCause(deferred, cause))(self)))));
  })(Handoff.make()))(Deferred.make())).traced(trace);
});
/** @internal */
exports.peel = peel;
const partition = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => partitionBuffer(self, predicate, 16));
/** @internal */
exports.partition = partition;
const partitionBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, bufferSize) => partitionEitherBuffer(a => predicate(a) ? Effect.succeed(Either.left(a)) : Effect.succeed(Either.right(a)), bufferSize)(self));
/** @internal */
exports.partitionBuffer = partitionBuffer;
const partitionEither = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => partitionEitherBuffer(self, predicate, 16));
/** @internal */
exports.partitionEither = partitionEither;
const partitionEitherBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, bufferSize) => Effect.flatMap(([queue1, queue2]) => Effect.succeed([collectLeft(flattenExitOption(fromQueueWithShutdown(queue1))), collectRight(flattenExitOption(fromQueueWithShutdown(queue2)))]))(distributedWith(2, bufferSize, Either.match(() => Effect.succeed(n => n === 0), () => Effect.succeed(n => n === 1)))(mapEffect(predicate)(self))));
/** @internal */
exports.partitionEitherBuffer = partitionEitherBuffer;
const pipeThrough = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => new StreamImpl(channel.pipeToOrFail(_sink.toChannel(sink))(toChannel(self))));
/** @internal */
exports.pipeThrough = pipeThrough;
const pipeThroughChannel = /*#__PURE__*/(0, _Function.dual)(2, (self, channel) => new StreamImpl(core.pipeTo(channel)(toChannel(self))));
/** @internal */
exports.pipeThroughChannel = pipeThroughChannel;
const pipeThroughChannelOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, chan) => new StreamImpl(channel.pipeToOrFail(chan)(toChannel(self))));
/** @internal */
exports.pipeThroughChannelOrFail = pipeThroughChannelOrFail;
const prepend = values => new StreamImpl(channel.zipRight(channel.identityChannel())(core.write(values)));
/** @internal */
exports.prepend = prepend;
const provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => new StreamImpl(core.provideContext(context)(toChannel(self))));
/** @internal */
exports.provideContext = provideContext;
const provideLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) => new StreamImpl(channel.unwrapScoped(Effect.map(env => core.provideContext(env)(toChannel(self)))(Layer.build(layer)))));
/** @internal */
exports.provideLayer = provideLayer;
const provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, resource) => provideServiceEffect(self, tag, Effect.succeed(resource)));
/** @internal */
exports.provideService = provideService;
const provideServiceEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, effect) => provideServiceStream(self, tag, fromEffect(effect)));
/** @internal */
exports.provideServiceEffect = provideServiceEffect;
const provideServiceStream = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, stream) => contextWithStream(env => flatMap(stream, service => provideContext(Context.add(env, tag, service))(self))));
/** @internal */
exports.provideServiceStream = provideServiceStream;
const contramapContext = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contextWithStream(env => provideContext(f(env))(self)));
/** @internal */
exports.contramapContext = contramapContext;
const provideSomeLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) => // @ts-expect-error
provideLayer(Layer.merge(layer)(Layer.context()))(self));
/** @internal */
exports.provideSomeLayer = provideSomeLayer;
const range = (min, max, chunkSize = DefaultChunkSize) => suspend(() => {
  if (min >= max) {
    return empty;
  }
  const go = (min, max, chunkSize) => {
    const remaining = max - min;
    if (remaining > chunkSize) {
      return core.flatMap(() => go(min + chunkSize, max, chunkSize))(core.write(Chunk.range(min, min + chunkSize - 1)));
    }
    return core.write(Chunk.range(min, min + remaining - 1));
  };
  return new StreamImpl(go(min, max, chunkSize));
});
/** @internal */
exports.range = range;
const rechunk = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => suspend(() => {
  const target = Math.max(n, 1);
  const process = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(core.pipeTo(process)(toChannel(self)));
}));
/** @internal */
exports.rechunk = rechunk;
const rechunkProcess = (rechunker, target) => core.readWithCause(chunk => {
  if (chunk.length === target && rechunker.isEmpty()) {
    return core.flatMap(() => rechunkProcess(rechunker, target))(core.write(chunk));
  }
  if (chunk.length > 0) {
    const chunks = [];
    let result = undefined;
    let index = 0;
    while (index < chunk.length) {
      while (index < chunk.length && result === undefined) {
        result = rechunker.write(Chunk.unsafeGet(index)(chunk));
        index = index + 1;
      }
      if (result !== undefined) {
        chunks.push(result);
        result = undefined;
      }
    }
    return core.flatMap(() => rechunkProcess(rechunker, target))(channel.writeAll(...chunks));
  }
  return core.suspend(() => rechunkProcess(rechunker, target));
}, cause => channel.zipRight(core.failCause(cause))(rechunker.emitIfNotEmpty()), () => rechunker.emitIfNotEmpty());
/** @internal */
class StreamRechunker {
  constructor(n) {
    this.n = n;
    this.builder = [];
    this.pos = 0;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = Chunk.unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return undefined;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return core.write(Chunk.unsafeFromArray(this.builder));
    }
    return core.unit();
  }
}
/** @internal */
const refineOrDie = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => refineOrDieWith(pf, _Function.identity)(self));
/** @internal */
exports.refineOrDie = refineOrDie;
const refineOrDieWith = /*#__PURE__*/(0, _Function.dual)(3, (self, pf, f) => new StreamImpl(channel.catchAll(error => Option.match(() => core.failCause(Cause.die(f(error))), core.fail)(pf(error)))(toChannel(self))));
/** @internal */
exports.refineOrDieWith = refineOrDieWith;
const repeat = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => collectRight(repeatEither(schedule)(self)));
/** @internal */
exports.repeat = repeat;
const repeatEffect = effect => repeatEffectOption(Effect.mapError(Option.some)(effect));
/** @internal */
exports.repeatEffect = repeatEffect;
const repeatEffectChunk = effect => repeatEffectChunkOption(Effect.mapError(Option.some)(effect));
/** @internal */
exports.repeatEffectChunk = repeatEffectChunk;
const repeatEffectChunkOption = effect => unfoldChunkEffect(effect, effect => Effect.catchAll(Option.match(Effect.succeedNone, Effect.fail))(Effect.map(chunk => Option.some([chunk, effect]))(effect)));
/** @internal */
exports.repeatEffectChunkOption = repeatEffectChunkOption;
const repeatEffectOption = effect => repeatEffectChunkOption(Effect.map(Chunk.of)(effect));
/** @internal */
exports.repeatEffectOption = repeatEffectOption;
const repeatEither = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => repeatWith(schedule, a => Either.right(a), Either.left)(self));
/** @internal */
exports.repeatEither = repeatEither;
const repeatElements = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => collectRight(repeatElementsEither(schedule)(self)));
/** @internal */
exports.repeatElements = repeatElements;
const repeatElementsEither = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => repeatElementsWith(schedule, a => Either.right(a), Either.left)(self));
/** @internal */
exports.repeatElementsEither = repeatElementsEither;
const repeatElementsWith = /*#__PURE__*/(0, _Function.dual)(4, (self, schedule, f, g) => {
  const driver = channel.unwrap(Effect.map(driver => {
    const feed = input => Option.match(() => loop, a => channel.zipRight(step(Chunk.drop(1)(input), a))(core.write(Chunk.of(f(a)))))(Chunk.head(input));
    const step = (input, a) => {
      const advance = Effect.as(core.flatMap(() => step(input, a))(core.write(Chunk.of(f(a)))))(driver.next(a));
      const reset = Effect.flatMap(b => Effect.map(() => channel.zipRight(feed(input))(core.write(Chunk.of(g(b)))))(driver.reset()))(Effect.orDie(driver.last()));
      return channel.unwrap(Effect.orElse(() => reset)(advance));
    };
    const loop = core.readWith(feed, core.fail, core.unit);
    return loop;
  })(Schedule.driver(schedule)));
  return new StreamImpl(core.pipeTo(driver)(toChannel(self)));
});
/** @internal */
exports.repeatElementsWith = repeatElementsWith;
const repeatValue = value => new StreamImpl(channel.repeated(core.write(Chunk.of(value))));
/** @internal */
exports.repeatValue = repeatValue;
const repeatWith = /*#__PURE__*/(0, _Function.dual)(4, (self, schedule, f, g) => {
  return unwrap(Effect.map(driver => {
    const scheduleOutput = Effect.map(g)(Effect.orDie(driver.last()));
    const process = toChannel(map(f)(self));
    const loop = channel.unwrap(Effect.match(core.unit, () => channel.zipRight(channel.unwrap(Effect.map(c => core.flatMap(() => loop)(core.write(Chunk.of(c))))(scheduleOutput)))(process))(driver.next(void 0)));
    return new StreamImpl(channel.zipRight(loop)(process));
  })(Schedule.driver(schedule)));
});
/**
 * Repeats the value using the provided schedule.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.repeatWith = repeatWith;
const repeatWithSchedule = (value, schedule) => repeatEffectWithSchedule(Effect.succeed(value), schedule);
/** @internal */
exports.repeatWithSchedule = repeatWithSchedule;
const repeatEffectWithSchedule = (effect, schedule) => flatMap(([a, driver]) => concat(unfoldEffect(a, s => Effect.matchEffect(Effect.succeed, () => Effect.map(nextA => Option.some([nextA, nextA]))(effect))(driver.next(s))))(succeed(a)))(fromEffect(Effect.zip(Schedule.driver(schedule))(effect)));
/** @internal */
exports.repeatEffectWithSchedule = repeatEffectWithSchedule;
const retry = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => unwrap(Effect.map(driver => {
  const loop = catchAll(error => unwrap(Effect.matchEffect(() => Effect.fail(error), () => Effect.succeed(tap(() => driver.reset())(loop)))(driver.next(error))))(self);
  return loop;
})(Schedule.driver(schedule))));
/** @internal */
exports.retry = retry;
const right = self => rightOrFail(() => Option.none())(mapError(Option.some)(self));
/** @internal */
exports.right = right;
const rightOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => mapEffect(Either.match(() => Effect.failSync(error), Effect.succeed))(self));
/** @internal */
exports.rightOrFail = rightOrFail;
const run = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, sink) => channel.runDrain(channel.pipeToOrFail(_sink.toChannel(sink))(toChannel(self))).traced(trace));
/** @internal */
exports.run = run;
const runCollect = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.collectAll())(self).traced(trace));
/** @internal */
exports.runCollect = runCollect;
const runCount = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.count())(self).traced(trace));
/** @internal */
exports.runCount = runCount;
const runDrain = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.drain())(self).traced(trace));
/** @internal */
exports.runDrain = runDrain;
const runFold = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, s, f) => Effect.scoped(runFoldWhileScoped(s, _Function.constTrue, f)(self)).traced(trace));
/** @internal */
exports.runFold = runFold;
const runFoldEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, s, f) => Effect.scoped(runFoldWhileScopedEffect(s, _Function.constTrue, f)(self)).traced(trace));
/** @internal */
exports.runFoldEffect = runFoldEffect;
const runFoldScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, s, f) => runFoldWhileScoped(s, _Function.constTrue, f)(self).traced(trace));
/** @internal */
exports.runFoldScoped = runFoldScoped;
const runFoldScopedEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, s, f) => runFoldWhileScopedEffect(s, _Function.constTrue, f)(self).traced(trace));
/** @internal */
exports.runFoldScopedEffect = runFoldScopedEffect;
const runFoldWhile = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, s, cont, f) => Effect.scoped(runFoldWhileScoped(s, cont, f)(self)).traced(trace));
/** @internal */
exports.runFoldWhile = runFoldWhile;
const runFoldWhileEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, s, cont, f) => Effect.scoped(runFoldWhileScopedEffect(s, cont, f)(self)).traced(trace));
/** @internal */
exports.runFoldWhileEffect = runFoldWhileEffect;
const runFoldWhileScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, s, cont, f) => runScoped(_sink.fold(s, cont, f))(self).traced(trace));
/** @internal */
exports.runFoldWhileScoped = runFoldWhileScoped;
const runFoldWhileScopedEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, s, cont, f) => runScoped(_sink.foldEffect(s, cont, f))(self).traced(trace));
/** @internal */
exports.runFoldWhileScopedEffect = runFoldWhileScopedEffect;
const runForEach = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => run(_sink.forEach(f))(self).traced(trace));
/** @internal */
exports.runForEach = runForEach;
const runForEachChunk = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => run(_sink.forEachChunk(f))(self).traced(trace));
/** @internal */
exports.runForEachChunk = runForEachChunk;
const runForEachChunkScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => runScoped(_sink.forEachChunk(f))(self).traced(trace));
/** @internal */
exports.runForEachChunkScoped = runForEachChunkScoped;
const runForEachScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => runScoped(_sink.forEach(f))(self).traced(trace));
/** @internal */
exports.runForEachScoped = runForEachScoped;
const runForEachWhile = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => run(_sink.forEachWhile(f))(self).traced(trace));
/** @internal */
exports.runForEachWhile = runForEachWhile;
const runForEachWhileScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => runScoped(_sink.forEachWhile(f))(self).traced(trace));
/** @internal */
exports.runForEachWhileScoped = runForEachWhileScoped;
const runHead = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.head())(self).traced(trace));
/** @internal */
exports.runHead = runHead;
const runIntoHub = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, hub) => runIntoQueue(hub)(self).traced(trace));
/** @internal */
exports.runIntoHub = runIntoHub;
const runIntoHubScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, hub) => runIntoQueueScoped(hub)(self).traced(trace));
/** @internal */
exports.runIntoHubScoped = runIntoHubScoped;
const runIntoQueue = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, queue) => Effect.scoped(runIntoQueueScoped(queue)(self)).traced(trace));
/** @internal */
exports.runIntoQueue = runIntoQueue;
const runIntoQueueElementsScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, queue) => {
  const writer = core.readWithCause(input => core.flatMap(() => writer)(Chunk.reduce(core.unit(), (acc, a) => channel.zipRight(core.write(Exit.succeed(a)))(acc))(input)), cause => core.write(Exit.failCause(Cause.map(Option.some)(cause))), () => core.write(Exit.fail(Option.none())));
  return Effect.asUnit(channelExecutor.runScoped(channel.drain(channel.mapOutEffect(exit => Queue.offer(queue, exit))(core.pipeTo(writer)(toChannel(self)))))).traced(trace);
});
/** @internal */
exports.runIntoQueueElementsScoped = runIntoQueueElementsScoped;
const runIntoQueueScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, queue) => {
  const writer = core.readWithCause(input => core.flatMap(() => writer)(core.write(_take.chunk(input))), cause => core.write(_take.failCause(cause)), () => core.write(_take.end));
  return Effect.asUnit(channelExecutor.runScoped(channel.drain(channel.mapOutEffect(take => Queue.offer(queue, take))(core.pipeTo(writer)(toChannel(self)))))).traced(trace);
});
/** @internal */
exports.runIntoQueueScoped = runIntoQueueScoped;
const runLast = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.last())(self).traced(trace));
/** @internal */
exports.runLast = runLast;
const runScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, sink) => channelExecutor.runScoped(channel.drain(channel.pipeToOrFail(_sink.toChannel(sink))(toChannel(self)))).traced(trace));
/** @internal */
exports.runScoped = runScoped;
const runSum = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.sum())(self).traced(trace));
/** @internal */
exports.runSum = runSum;
const scan = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => scanEffect(s, (s, a) => Effect.succeed(f(s, a)))(self));
/** @internal */
exports.scan = scan;
const scanReduce = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => scanReduceEffect((a2, a) => Effect.succeed(f(a2, a)))(self));
/** @internal */
exports.scanReduce = scanReduce;
const scanReduceEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapAccumEffect(Option.none(), (option, a) => {
  switch (option._tag) {
    case "None":
      {
        return Effect.succeed([Option.some(a), a]);
      }
    case "Some":
      {
        return Effect.map(b => [Option.some(b), b])(f(option.value, a));
      }
  }
})(self));
/** @internal */
exports.scanReduceEffect = scanReduceEffect;
const schedule = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => collectRight(scheduleEither(schedule)(self)));
/** @internal */
exports.schedule = schedule;
const scheduleEither = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => scheduleWith(schedule, a => Either.right(a), Either.left)(self));
/** @internal */
exports.scheduleEither = scheduleEither;
const scheduleWith = /*#__PURE__*/(0, _Function.dual)(4, (self, schedule, f, g) => {
  const loop = (driver, iterator) => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause(chunk => loop(driver, chunk[Symbol.iterator]()), core.failCause, core.succeedNow);
    }
    return channel.unwrap(Effect.matchEffect(() => Effect.zipLeft(driver.reset())(Effect.map(b => core.flatMap(() => loop(driver, iterator))(core.write(Chunk.make(f(next.value), g(b)))))(Effect.orDie(driver.last()))), () => Effect.succeed(core.flatMap(() => loop(driver, iterator))(core.write(Chunk.of(f(next.value))))))(driver.next(next.value)));
  };
  return new StreamImpl(core.flatMap(driver => core.pipeTo(loop(driver, Chunk.empty()[Symbol.iterator]()))(toChannel(self)))(core.fromEffect(Schedule.driver(schedule))));
});
/** @internal */
exports.scheduleWith = scheduleWith;
const scanEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => new StreamImpl(core.flatMap(() => toChannel(mapAccumEffect(s, (s, a) => Effect.map(s => [s, s])(f(s, a)))(self)))(core.write(Chunk.of(s)))));
/** @internal */
exports.scanEffect = scanEffect;
const scoped = effect => new StreamImpl(channel.ensuring(channel.scoped(Effect.map(Chunk.of)(effect)), Effect.unit()));
/** @internal */
exports.scoped = scoped;
const some = self => someOrFail(() => Option.none())(mapError(Option.some)(self));
/** @internal */
exports.some = some;
const someOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, fallback) => map(Option.getOrElse(fallback))(self));
/** @internal */
exports.someOrElse = someOrElse;
const someOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => mapEffect(Option.match(() => Effect.failSync(error), Effect.succeed))(self));
/** @internal */
exports.someOrFail = someOrFail;
const sliding = /*#__PURE__*/(0, _Function.dual)(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
/** @internal */
exports.sliding = sliding;
const slidingSize = /*#__PURE__*/(0, _Function.dual)(3, (self, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die(Cause.IllegalArgumentException("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(core.suspend(() => {
    const queue = new _support.RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result = Chunk.isEmpty(items) ? Chunk.empty() : Chunk.of(items);
        return core.flatMap(() => channelEnd)(core.write(result));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = Chunk.takeRight(leftovers)(queue.toChunk());
      const result = Chunk.isEmpty(lastItems) ? Chunk.empty() : Chunk.of(lastItems);
      return core.flatMap(() => channelEnd)(core.write(result));
    };
    const reader = queueSize => core.readWithCause(input => core.flatMap(() => reader(queueSize + input.length))(core.write(Chunk.filterMap(([element, index]) => {
      queue.put(element);
      const currentIndex = queueSize + index + 1;
      if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
        return Option.none();
      }
      return Option.some(queue.toChunk());
    })(Chunk.zipWithIndex(input)))), cause => emitOnStreamEnd(queueSize, core.failCause(cause)), () => emitOnStreamEnd(queueSize, core.unit()));
    return core.pipeTo(reader(0))(toChannel(self));
  }));
});
/** @internal */
exports.slidingSize = slidingSize;
const split = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const split = (leftovers, input) => {
    const [chunk, remaining] = Chunk.splitWhere(predicate)(Chunk.concat(input)(leftovers));
    if (Chunk.isEmpty(chunk) || Chunk.isEmpty(remaining)) {
      return loop(Chunk.concat(Chunk.drop(1)(remaining))(chunk));
    }
    return core.flatMap(() => split(Chunk.empty(), Chunk.drop(1)(remaining)))(core.write(Chunk.of(chunk)));
  };
  const loop = leftovers => core.readWith(input => split(leftovers, input), core.fail, () => {
    if (Chunk.isEmpty(leftovers)) {
      return core.unit();
    }
    if (Option.isNone(Chunk.findFirst(predicate)(leftovers))) {
      return channel.zipRight(core.unit())(core.write(Chunk.of(leftovers)));
    }
    return channel.zipRight(core.unit())(split(Chunk.empty(), leftovers));
  });
  return new StreamImpl(core.pipeTo(loop(Chunk.empty()))(toChannel(self)));
});
/** @internal */
exports.split = split;
const splitOnChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, delimiter) => {
  const next = (leftover, delimiterIndex) => core.readWithCause(inputChunk => {
    let buffer;
    const [carry, delimiterCursor] = Chunk.reduce([Option.getOrElse(() => Chunk.empty())(leftover), delimiterIndex], ([carry, delimiterCursor], a) => {
      const concatenated = Chunk.append(a)(carry);
      if (delimiterCursor < delimiter.length && Equal.equals(a, Chunk.unsafeGet(delimiterCursor)(delimiter))) {
        if (delimiterCursor + 1 === delimiter.length) {
          if (buffer === undefined) {
            buffer = [];
          }
          buffer.push(Chunk.take(concatenated.length - delimiter.length)(concatenated));
          return [Chunk.empty(), 0];
        }
        return [concatenated, delimiterCursor + 1];
      }
      return [concatenated, Equal.equals(a, Chunk.unsafeGet(0)(delimiter)) ? 1 : 0];
    })(inputChunk);
    const output = buffer === undefined ? Chunk.empty() : Chunk.unsafeFromArray(buffer);
    return core.flatMap(() => next(Chunk.isNonEmpty(carry) ? Option.some(carry) : Option.none(), delimiterCursor))(core.write(output));
  }, cause => Option.match(() => core.failCause(cause), chunk => channel.zipRight(core.failCause(cause))(core.write(Chunk.of(chunk))))(leftover), done => Option.match(() => core.succeed(done), chunk => channel.zipRight(core.succeed(done))(core.write(Chunk.of(chunk))))(leftover));
  return new StreamImpl(core.pipeTo(next(Option.none(), 0))(toChannel(self)));
});
/** @internal */
exports.splitOnChunk = splitOnChunk;
const succeed = value => fromChunk(Chunk.of(value));
/** @internal */
exports.succeed = succeed;
const sync = evaluate => suspend(() => fromChunk(Chunk.of(evaluate())));
/** @internal */
exports.sync = sync;
const suspend = stream => new StreamImpl(core.suspend(() => toChannel(stream())));
/** @internal */
exports.suspend = suspend;
const take = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  if (!Number.isInteger(n)) {
    return die(Cause.IllegalArgumentException(`${n} must be an integer`));
  }
  const loop = n => core.readWith(input => {
    const taken = Chunk.take(Math.min(n, Number.POSITIVE_INFINITY))(input);
    const leftover = Math.max(0, n - taken.length);
    const more = leftover > 0;
    if (more) {
      return core.flatMap(() => loop(leftover))(core.write(taken));
    }
    return core.write(taken);
  }, core.fail, core.succeed);
  return new StreamImpl(channel.pipeToOrFail(0 < n ? loop(n) : core.unit())(toChannel(self)));
});
/** @internal */
exports.take = take;
const takeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  if (n <= 0) {
    return empty;
  }
  return new StreamImpl(channel.unwrap(Effect.map(queue => {
    const reader = core.readWith(input => {
      for (const element of input) {
        queue.put(element);
      }
      return reader;
    }, core.fail, () => channel.zipRight(core.unit())(core.write(queue.toChunk())));
    return core.pipeTo(reader)(toChannel(self));
  })(Effect.succeed(new _support.RingBuffer(n)))));
});
/** @internal */
exports.takeRight = takeRight;
const takeUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith(input => {
    const taken = Chunk.takeWhile(a => !predicate(a))(input);
    const last = Chunk.take(1)(Chunk.drop(taken.length)(input));
    if (Chunk.isEmpty(last)) {
      return core.flatMap(() => loop)(core.write(taken));
    }
    return core.write(Chunk.concat(last)(taken));
  }, core.fail, core.succeed);
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
exports.takeUntil = takeUntil;
const takeUntilEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause(elem => loop(elem[Symbol.iterator]()), core.failCause, core.succeed);
    }
    return channel.unwrap(Effect.map(bool => bool ? core.write(Chunk.of(next.value)) : core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value))))(predicate(next.value)));
  };
  return new StreamImpl(core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(toChannel(self)));
});
/** @internal */
exports.takeUntilEffect = takeUntilEffect;
const takeWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith(input => {
    const taken = Chunk.takeWhile(predicate)(input);
    const more = taken.length === input.length;
    if (more) {
      return core.flatMap(() => loop)(core.write(taken));
    }
    return core.write(taken);
  }, core.fail, core.succeed);
  return new StreamImpl(channel.pipeToOrFail(loop)(toChannel(self)));
});
/** @internal */
exports.takeWhile = takeWhile;
const tap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapEffect(self, a => Effect.as(f(a), a)));
/** @internal */
exports.tap = tap;
const tapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAll(error => fromEffect(Effect.zipRight(Effect.fail(error))(f(error))))(self));
/** @internal */
exports.tapError = tapError;
const tapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAllCause(cause => fromEffect(Effect.zipRight(Effect.failCause(cause))(f(cause))))(self));
/** @internal */
exports.tapErrorCause = tapErrorCause;
const tapSink = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => flatMap(queue => {
  const right = flattenTake(fromQueue(queue, 1));
  const loop = core.readWithCause(chunk => core.flatMap(() => loop)(channel.zipRight(core.write(chunk))(core.fromEffect(Queue.offer(queue, _take.chunk(chunk))))), cause => core.fromEffect(Queue.offer(queue, _take.failCause(cause))), () => core.fromEffect(Queue.offer(queue, _take.end)));
  return mergeHaltStrategy(execute(run(sink)(right)), haltStrategy.Both)(new StreamImpl(core.pipeTo(loop)(toChannel(self))));
})(fromEffect(Queue.bounded(1))));
/** @internal */
exports.tapSink = tapSink;
const throttleEnforce = /*#__PURE__*/(0, _Function.dual)(4, (self, costFn, units, duration) => throttleEnforceBurst(self, costFn, units, duration, 0));
/** @internal */
exports.throttleEnforce = throttleEnforce;
const throttleEnforceBurst = /*#__PURE__*/(0, _Function.dual)(5, (self, costFn, units, duration, burst) => throttleEnforceEffectBurst(self, chunk => Effect.succeed(costFn(chunk)), units, duration, burst));
/** @internal */
exports.throttleEnforceBurst = throttleEnforceBurst;
const throttleEnforceEffect = /*#__PURE__*/(0, _Function.dual)(4, (self, costFn, units, duration) => throttleEnforceEffectBurst(self, costFn, units, duration, 0));
/** @internal */
exports.throttleEnforceEffect = throttleEnforceEffect;
const throttleEnforceEffectBurst = /*#__PURE__*/(0, _Function.dual)(5, (self, costFn, units, duration, burst) => {
  const loop = (tokens, timestampMillis) => core.readWithCause(input => channel.unwrap(Effect.map(([weight, currentTimeMillis]) => {
    const elapsed = currentTimeMillis - timestampMillis;
    const cycles = elapsed / duration.millis;
    const sum = tokens + cycles * units;
    const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
    const available = sum < 0 ? max : Math.min(sum, max);
    if (weight <= available) {
      return core.flatMap(() => loop(available - weight, currentTimeMillis))(core.write(input));
    }
    return loop(available, currentTimeMillis);
  })(Effect.zip(Clock.currentTimeMillis())(costFn(input)))), core.failCause, core.unit);
  const throttled = channel.unwrap(Effect.map(currentTimeMillis => loop(units, currentTimeMillis))(Clock.currentTimeMillis()));
  return new StreamImpl(channel.pipeToOrFail(throttled)(toChannel(self)));
});
/** @internal */
exports.throttleEnforceEffectBurst = throttleEnforceEffectBurst;
const throttleShape = /*#__PURE__*/(0, _Function.dual)(4, (self, costFn, units, duration) => throttleShapeBurst(self, costFn, units, duration, 0));
/** @internal */
exports.throttleShape = throttleShape;
const throttleShapeBurst = /*#__PURE__*/(0, _Function.dual)(5, (self, costFn, units, duration, burst) => throttleShapeEffectBurst(self, chunk => Effect.succeed(costFn(chunk)), units, duration, burst));
/** @internal */
exports.throttleShapeBurst = throttleShapeBurst;
const throttleShapeEffect = /*#__PURE__*/(0, _Function.dual)(4, (self, costFn, units, duration) => throttleShapeEffectBurst(self, costFn, units, duration, 0));
/** @internal */
exports.throttleShapeEffect = throttleShapeEffect;
const throttleShapeEffectBurst = /*#__PURE__*/(0, _Function.dual)(5, (self, costFn, units, duration, burst) => {
  const loop = (tokens, timestampMillis) => core.readWithCause(input => channel.unwrap(Effect.map(([weight, currentTimeMillis]) => {
    const elapsed = currentTimeMillis - timestampMillis;
    const cycles = elapsed / duration.millis;
    const sum = tokens + cycles * units;
    const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
    const available = sum < 0 ? max : Math.min(sum, max);
    const remaining = available - weight;
    const waitCycles = remaining >= 0 ? 0 : -remaining / units;
    const delay = Duration.millis(Math.max(0, waitCycles * duration.millis));
    if (Duration.greaterThan(Duration.zero)(delay)) {
      return core.flatMap(() => loop(remaining, currentTimeMillis))(channel.zipRight(core.write(input))(core.fromEffect(Clock.sleep(delay))));
    }
    return core.flatMap(() => loop(remaining, currentTimeMillis))(core.write(input));
  })(Effect.zip(Clock.currentTimeMillis())(costFn(input)))), core.failCause, core.unit);
  const throttled = channel.unwrap(Effect.map(currentTimeMillis => loop(units, currentTimeMillis))(Clock.currentTimeMillis()));
  return new StreamImpl(channel.pipeToOrFail(throttled)(toChannel(self)));
});
/** @internal */
exports.throttleShapeEffectBurst = throttleShapeEffectBurst;
const tick = interval => repeatWithSchedule(void 0, Schedule.spaced(interval));
/** @internal */
exports.tick = tick;
const timeout = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => fromPull(Effect.map(Effect.timeoutFail(() => Option.none(), duration))(toPull(self))));
/** @internal */
exports.timeout = timeout;
const timeoutFail = /*#__PURE__*/(0, _Function.dual)(3, (self, error, duration) => timeoutTo(duration, failSync(error))(self));
/** @internal */
exports.timeoutFail = timeoutFail;
const timeoutFailCause = /*#__PURE__*/(0, _Function.dual)(3, (self, cause, duration) => fromPull(Effect.map(Effect.timeoutFailCause(() => Cause.map(Option.some)(cause()), duration))(toPull(self))));
/** @internal */
exports.timeoutFailCause = timeoutFailCause;
const timeoutTo = /*#__PURE__*/(0, _Function.dual)(3, (self, duration, that) => {
  const StreamTimeout = Cause.RuntimeException("Stream Timeout");
  return catchSomeCause(annotatedCause => {
    const cause = Cause.unannotate(annotatedCause);
    return Cause.isDieType(cause) && Cause.isRuntimeException(cause.defect) && cause.defect.message !== undefined && cause.defect.message === "Stream Timeout" ? Option.some(that) : Option.none();
  })(timeoutFailCause(() => Cause.die(StreamTimeout), duration)(self));
});
/** @internal */
exports.timeoutTo = timeoutTo;
const toHub = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(hub => Effect.forkScoped(runIntoHubScoped(hub)(self)))(Effect.acquireRelease(Hub.bounded(capacity), hub => Hub.shutdown(hub))).traced(trace));
/** @internal */
exports.toHub = toHub;
const toPull = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => Effect.map(pull => Effect.flatMap(Either.match(() => Effect.fail(Option.none()), Effect.succeed))(Effect.mapError(Option.some)(pull)))(channel.toPull(toChannel(self))).traced(trace));
/** @internal */
exports.toPull = toPull;
const toQueue = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => toQueueCapacity(self, 2).traced(trace));
/** @internal */
exports.toQueue = toQueue;
const toQueueCapacity = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(queue => Effect.forkScoped(runIntoQueueScoped(queue)(self)))(Effect.acquireRelease(Queue.bounded(capacity), queue => Queue.shutdown(queue))).traced(trace));
/** @internal */
exports.toQueueCapacity = toQueueCapacity;
const toQueueDropping = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => toQueueDroppingCapacity(self, 2).traced(trace));
/** @internal */
exports.toQueueDropping = toQueueDropping;
const toQueueDroppingCapacity = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(queue => Effect.forkScoped(runIntoQueueScoped(queue)(self)))(Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue))).traced(trace));
/** @internal */
exports.toQueueDroppingCapacity = toQueueDroppingCapacity;
const toQueueOfElements = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => toQueueOfElementsCapacity(self, 2).traced(trace));
/** @internal */
exports.toQueueOfElements = toQueueOfElements;
const toQueueOfElementsCapacity = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(queue => Effect.forkScoped(runIntoQueueElementsScoped(queue)(self)))(Effect.acquireRelease(Queue.bounded(capacity), queue => Queue.shutdown(queue))).traced(trace));
/** @internal */
exports.toQueueOfElementsCapacity = toQueueOfElementsCapacity;
const toQueueSliding = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => toQueueSlidingCapacity(self, 2).traced(trace));
/** @internal */
exports.toQueueSliding = toQueueSliding;
const toQueueSlidingCapacity = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(queue => Effect.forkScoped(runIntoQueueScoped(queue)(self)))(Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue))).traced(trace));
/** @internal */
exports.toQueueSlidingCapacity = toQueueSlidingCapacity;
const toQueueUnbounded = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => Effect.tap(queue => Effect.forkScoped(runIntoQueueScoped(queue)(self)))(Effect.acquireRelease(Queue.unbounded(), queue => Queue.shutdown(queue))).traced(trace));
/** @internal */
exports.toQueueUnbounded = toQueueUnbounded;
const transduce = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => {
  const newChannel = core.suspend(() => {
    const leftovers = {
      ref: Chunk.empty()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer = core.suspend(() => {
      const leftover = leftovers.ref;
      if (Chunk.isEmpty(leftover)) {
        return core.readWith(input => core.flatMap(() => buffer)(core.write(input)), core.fail, core.succeedNow);
      }
      leftovers.ref = Chunk.empty();
      return core.flatMap(() => buffer)(channel.writeChunk(leftover));
    });
    const concatAndGet = chunk => {
      const leftover = leftovers.ref;
      const concatenated = Chunk.concat(Chunk.filter(chunk => chunk.length !== 0)(chunk))(leftover);
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = core.readWith(input => core.flatMap(() => upstreamMarker)(core.write(input)), core.fail, done => channel.zipRight(core.succeedNow(done))(core.sync(() => {
      upstreamDone.ref = true;
    })));
    const transducer = core.flatMap(([leftover, z]) => core.flatMap(([done, newLeftovers]) => {
      const nextChannel = done && Chunk.isEmpty(newLeftovers) ? core.unit() : transducer;
      return core.flatMap(() => nextChannel)(core.write(Chunk.of(z)));
    })(core.succeed([upstreamDone.ref, concatAndGet(leftover)])))(core.collectElements(_sink.toChannel(sink)));
    return channel.pipeToOrFail(transducer)(core.pipeTo(buffer)(core.pipeTo(upstreamMarker)(toChannel(self))));
  });
  return new StreamImpl(newChannel);
});
/** @internal */
exports.transduce = transduce;
const unfold = (s, f) => unfoldChunk(s, s => Option.map(([a, s]) => [Chunk.of(a), s])(f(s)));
/** @internal */
exports.unfold = unfold;
const unfoldChunk = (s, f) => {
  const loop = s => Option.match(core.unit, ([chunk, s]) => core.flatMap(() => loop(s))(core.write(chunk)))(f(s));
  return new StreamImpl(core.suspend(() => loop(s)));
};
/** @internal */
exports.unfoldChunk = unfoldChunk;
const unfoldChunkEffect = (s, f) => suspend(() => {
  const loop = s => channel.unwrap(Effect.map(Option.match(core.unit, ([chunk, s]) => core.flatMap(() => loop(s))(core.write(chunk))))(f(s)));
  return new StreamImpl(loop(s));
});
/** @internal */
exports.unfoldChunkEffect = unfoldChunkEffect;
const unfoldEffect = (s, f) => unfoldChunkEffect(s, s => Effect.map(Option.map(([a, s]) => [Chunk.of(a), s]))(f(s)));
/** @internal */
exports.unfoldEffect = unfoldEffect;
const unit = () => succeed(void 0);
/** @internal */
exports.unit = unit;
const unwrap = effect => flatten(fromEffect(effect));
/** @internal */
exports.unwrap = unwrap;
const unwrapScoped = effect => flatten(scoped(effect));
/** @internal */
exports.unwrapScoped = unwrapScoped;
const updateService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, f) => contramapContext(context => Context.add(tag, f(Context.unsafeGet(tag)(context)))(context))(self));
/** @internal */
exports.updateService = updateService;
const when = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => whenEffect(Effect.sync(predicate))(self));
/** @internal */
exports.when = when;
const whenCase = (evaluate, pf) => whenCaseEffect(pf)(Effect.sync(evaluate));
/** @internal */
exports.whenCase = whenCase;
const whenCaseEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => flatMap(a => Option.getOrElse(() => empty)(pf(a)))(fromEffect(self)));
/** @internal */
exports.whenCaseEffect = whenCaseEffect;
const whenEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => flatMap(bool => bool ? self : empty)(fromEffect(effect)));
/** @internal */
exports.whenEffect = whenEffect;
const zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (a, a2) => [a, a2])(self));
/** @internal */
exports.zip = zip;
const zipFlatten = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (a, a2) => [...a, a2])(self));
/** @internal */
exports.zipFlatten = zipFlatten;
const zipAll = /*#__PURE__*/(0, _Function.dual)(4, (self, that, defaultLeft, defaultRight) => zipAllWith(that, a => [a, defaultRight], a2 => [defaultLeft, a2], (a, a2) => [a, a2])(self));
/** @internal */
exports.zipAll = zipAll;
const zipAllLeft = /*#__PURE__*/(0, _Function.dual)(3, (self, that, defaultLeft) => zipAllWith(that, _Function.identity, () => defaultLeft, a => a)(self));
/** @internal */
exports.zipAllLeft = zipAllLeft;
const zipAllRight = /*#__PURE__*/(0, _Function.dual)(3, (self, that, defaultRight) => zipAllWith(that, () => defaultRight, _Function.identity, (_, a2) => a2)(self));
/** @internal */
exports.zipAllRight = zipAllRight;
const zipAllSortedByKey = /*#__PURE__*/(0, _Function.dual)(5, (self, that, defaultLeft, defaultRight, order) => zipAllSortedByKeyWith(self, that, a => [a, defaultRight], a2 => [defaultLeft, a2], (a, a2) => [a, a2], order));
/** @internal */
exports.zipAllSortedByKey = zipAllSortedByKey;
const zipAllSortedByKeyLeft = /*#__PURE__*/(0, _Function.dual)(4, (self, that, defaultLeft, order) => zipAllSortedByKeyWith(self, that, _Function.identity, () => defaultLeft, a => a, order));
/** @internal */
exports.zipAllSortedByKeyLeft = zipAllSortedByKeyLeft;
const zipAllSortedByKeyRight = /*#__PURE__*/(0, _Function.dual)(4, (self, that, defaultRight, order) => zipAllSortedByKeyWith(self, that, () => defaultRight, _Function.identity, (_, a2) => a2, order));
/** @internal */
exports.zipAllSortedByKeyRight = zipAllSortedByKeyRight;
const zipAllSortedByKeyWith = /*#__PURE__*/(0, _Function.dual)(6, (self, that, left, right, both, order) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipAllState.OP_DRAIN_LEFT:
        {
          return Effect.match(Exit.fail, leftChunk => Exit.succeed([Chunk.map(([k, a]) => [k, left(a)])(leftChunk), ZipAllState.DrainLeft]))(pullLeft);
        }
      case ZipAllState.OP_DRAIN_RIGHT:
        {
          return Effect.match(Exit.fail, rightChunk => Exit.succeed([Chunk.map(([k, a2]) => [k, right(a2)])(rightChunk), ZipAllState.DrainRight]))(pullRight);
        }
      case ZipAllState.OP_PULL_BOTH:
        {
          return Effect.matchEffect(error => Effect.succeed(Exit.fail(Option.some(error))), ([leftOption, rightOption]) => {
            if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
              if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                return pull(ZipAllState.PullBoth, pullLeft, pullRight);
              }
              if (Chunk.isEmpty(leftOption.value)) {
                return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(rightOption.value)) {
                return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(merge(leftOption.value, rightOption.value)));
            }
            if (Option.isSome(leftOption) && Option.isNone(rightOption)) {
              if (Chunk.isEmpty(leftOption.value)) {
                return pull(ZipAllState.DrainLeft, pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed([Chunk.map(([k, a]) => [k, left(a)])(leftOption.value), ZipAllState.DrainLeft]));
            }
            if (Option.isNone(leftOption) && Option.isSome(rightOption)) {
              if (Chunk.isEmpty(rightOption.value)) {
                return pull(ZipAllState.DrainRight, pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed([Chunk.map(([k, a2]) => [k, right(a2)])(rightOption.value), ZipAllState.DrainRight]));
            }
            return Effect.succeed(Exit.fail(Option.none()));
          })(Effect.zipPar(Effect.unsome(pullRight))(Effect.unsome(pullLeft)));
        }
      case ZipAllState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(Option.match(() => Effect.succeed(Exit.succeed([Chunk.map(([k, a2]) => [k, right(a2)])(state.rightChunk), ZipAllState.DrainRight])), error => Effect.succeed(Exit.fail(Option.some(error)))), leftChunk => Chunk.isEmpty(leftChunk) ? pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(leftChunk, state.rightChunk))))(pullLeft);
        }
      case ZipAllState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(Option.match(() => Effect.succeed(Exit.succeed([Chunk.map(([k, a]) => [k, left(a)])(state.leftChunk), ZipAllState.DrainLeft])), error => Effect.succeed(Exit.fail(Option.some(error)))), rightChunk => Chunk.isEmpty(rightChunk) ? pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(state.leftChunk, rightChunk))))(pullRight);
        }
    }
  };
  const merge = (leftChunk, rightChunk) => {
    const hasNext = (chunk, index) => index < chunk.length - 1;
    const builder = [];
    let state = undefined;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);
    let rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop = true;
    while (loop) {
      const compare = order.compare(k1, k2);
      if (compare === 0) {
        builder.push([k1, both(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);
          rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = ZipAllState.PullRight(Chunk.drop(leftIndex + 1)(leftChunk));
          loop = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = ZipAllState.PullLeft(Chunk.drop(rightIndex + 1)(rightChunk));
          loop = false;
        } else {
          state = ZipAllState.PullBoth;
          loop = false;
        }
      } else if (compare < 0) {
        builder.push([k1, left(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);
            rightBuilder.push(rightTuple);
          }
          state = ZipAllState.PullLeft(Chunk.unsafeFromArray(rightBuilder));
          loop = false;
        }
      } else {
        builder.push([k2, right(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);
            leftBuilder.push(leftTuple);
          }
          state = ZipAllState.PullRight(Chunk.unsafeFromArray(leftBuilder));
          loop = false;
        }
      }
    }
    return [Chunk.unsafeFromArray(builder), state];
  };
  return combineChunks(that, ZipAllState.PullBoth, pull)(self);
});
/** @internal */
exports.zipAllSortedByKeyWith = zipAllSortedByKeyWith;
const zipAllWith = /*#__PURE__*/(0, _Function.dual)(5, (self, that, left, right, both) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipAllState.OP_DRAIN_LEFT:
        {
          return Effect.matchEffect(error => Effect.succeed(Exit.fail(error)), leftChunk => Effect.succeed(Exit.succeed([Chunk.map(left)(leftChunk), ZipAllState.DrainLeft])))(pullLeft);
        }
      case ZipAllState.OP_DRAIN_RIGHT:
        {
          return Effect.matchEffect(error => Effect.succeed(Exit.fail(error)), rightChunk => Effect.succeed(Exit.succeed([Chunk.map(right)(rightChunk), ZipAllState.DrainRight])))(pullRight);
        }
      case ZipAllState.OP_PULL_BOTH:
        {
          return Effect.matchEffect(error => Effect.succeed(Exit.fail(Option.some(error))), ([leftOption, rightOption]) => {
            if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
              if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                return pull(ZipAllState.PullBoth, pullLeft, pullRight);
              }
              if (Chunk.isEmpty(leftOption.value)) {
                return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(rightOption.value)) {
                return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value, both)));
            }
            if (Option.isSome(leftOption) && Option.isNone(rightOption)) {
              return Effect.succeed(Exit.succeed([Chunk.map(left)(leftOption.value), ZipAllState.DrainLeft]));
            }
            if (Option.isNone(leftOption) && Option.isSome(rightOption)) {
              return Effect.succeed(Exit.succeed([Chunk.map(right)(rightOption.value), ZipAllState.DrainRight]));
            }
            return Effect.succeed(Exit.fail(Option.none()));
          })(Effect.zipPar(Effect.unsome(pullRight))(Effect.unsome(pullLeft)));
        }
      case ZipAllState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(Option.match(() => Effect.succeed(Exit.succeed([Chunk.map(right)(state.rightChunk), ZipAllState.DrainRight])), error => Effect.succeed(Exit.fail(Option.some(error)))), leftChunk => {
            if (Chunk.isEmpty(leftChunk)) {
              return pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (Chunk.isEmpty(state.rightChunk)) {
              return pull(ZipAllState.PullRight(leftChunk), pullLeft, pullRight);
            }
            return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk, both)));
          })(pullLeft);
        }
      case ZipAllState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(Option.match(() => Effect.succeed(Exit.succeed([Chunk.map(left)(state.leftChunk), ZipAllState.DrainLeft])), error => Effect.succeed(Exit.fail(Option.some(error)))), rightChunk => {
            if (Chunk.isEmpty(rightChunk)) {
              return pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (Chunk.isEmpty(state.leftChunk)) {
              return pull(ZipAllState.PullLeft(rightChunk), pullLeft, pullRight);
            }
            return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk, both)));
          })(pullRight);
        }
    }
  };
  const zip = (leftChunk, rightChunk, f) => {
    const [output, either] = zipChunks(leftChunk, rightChunk, f);
    switch (either._tag) {
      case "Left":
        {
          if (Chunk.isEmpty(either.left)) {
            return [output, ZipAllState.PullBoth];
          }
          return [output, ZipAllState.PullRight(either.left)];
        }
      case "Right":
        {
          if (Chunk.isEmpty(either.right)) {
            return [output, ZipAllState.PullBoth];
          }
          return [output, ZipAllState.PullLeft(either.right)];
        }
    }
  };
  return combineChunks(that, ZipAllState.PullBoth, pull)(self);
});
/** @internal */
exports.zipAllWith = zipAllWith;
const zipLatest = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipLatestWith(that, (a, a2) => [a, a2])(self));
/** @internal */
exports.zipLatest = zipLatest;
const zipLatestWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {
  const pullNonEmpty = pull => Effect.flatMap(chunk => Chunk.isEmpty(chunk) ? pullNonEmpty(pull) : Effect.succeed(chunk))(pull);
  return fromPull(Effect.flatMap(([left, right]) => toPull(flatMap(([l, r, leftFirst]) => flatMap(latest => concat(flatMap(fromChunk)(mapEffect(Either.match(leftChunk => Ref.modify(latest, ([_, rightLatest]) => [Chunk.map(a => f(a, rightLatest))(leftChunk), [Chunk.unsafeLast(leftChunk), rightLatest]]), rightChunk => Ref.modify(latest, ([leftLatest, _]) => [Chunk.map(a2 => f(leftLatest, a2))(rightChunk), [leftLatest, Chunk.unsafeLast(rightChunk)]])))(mergeEither(repeatEffectOption(right))(repeatEffectOption(left)))))(fromChunk(leftFirst ? Chunk.map(a2 => f(Chunk.unsafeLast(l), a2))(r) : Chunk.map(a => f(a, Chunk.unsafeLast(r)))(l))))(fromEffect(Ref.make([Chunk.unsafeLast(l), Chunk.unsafeLast(r)]))))(fromEffectOption(Effect.raceWith(right, (leftDone, rightFiber) => Effect.zipWith(Fiber.join(rightFiber), (l, r) => [l, r, true])(Effect.done(leftDone)), (rightDone, leftFiber) => Effect.zipWith(Fiber.join(leftFiber), (l, r) => [r, l, false])(Effect.done(rightDone)))(left)))))(Effect.zip(Effect.map(pullNonEmpty)(toPull(that)))(Effect.map(pullNonEmpty)(toPull(self)))));
});
/** @internal */
exports.zipLatestWith = zipLatestWith;
const zipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithChunks(that, (left, right) => {
  if (left.length > right.length) {
    return [Chunk.take(right.length)(left), Either.left(Chunk.take(right.length)(left))];
  }
  return [left, Either.right(Chunk.drop(left.length)(right))];
})(self));
/** @internal */
exports.zipLeft = zipLeft;
const zipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithChunks(that, (left, right) => {
  if (left.length > right.length) {
    return [right, Either.left(Chunk.take(right.length)(left))];
  }
  return [Chunk.take(left.length)(right), Either.right(Chunk.drop(left.length)(right))];
})(self));
/** @internal */
exports.zipRight = zipRight;
const zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => zipWithChunks(that, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))(self));
/** @internal */
exports.zipWith = zipWith;
const zipWithChunks = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipChunksState.OP_PULL_BOTH:
        {
          return Effect.matchEffect(error => Effect.succeed(Exit.fail(Option.some(error))), ([leftOption, rightOption]) => {
            if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
              if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                return pull(ZipChunksState.PullBoth, pullLeft, pullRight);
              }
              if (Chunk.isEmpty(leftOption.value)) {
                return pull(ZipChunksState.PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(rightOption.value)) {
                return pull(ZipChunksState.PullRight(leftOption.value), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value)));
            }
            return Effect.succeed(Exit.fail(Option.none()));
          })(Effect.zipPar(Effect.unsome(pullRight))(Effect.unsome(pullLeft)));
        }
      case ZipChunksState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(error => Effect.succeed(Exit.fail(error)), leftChunk => {
            if (Chunk.isEmpty(leftChunk)) {
              return pull(ZipChunksState.PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (Chunk.isEmpty(state.rightChunk)) {
              return pull(ZipChunksState.PullRight(leftChunk), pullLeft, pullRight);
            }
            return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk)));
          })(pullLeft);
        }
      case ZipChunksState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(error => Effect.succeed(Exit.fail(error)), rightChunk => {
            if (Chunk.isEmpty(rightChunk)) {
              return pull(ZipChunksState.PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (Chunk.isEmpty(state.leftChunk)) {
              return pull(ZipChunksState.PullLeft(rightChunk), pullLeft, pullRight);
            }
            return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk)));
          })(pullRight);
        }
    }
  };
  const zip = (leftChunk, rightChunk) => {
    const [output, either] = f(leftChunk, rightChunk);
    switch (either._tag) {
      case "Left":
        {
          if (Chunk.isEmpty(either.left)) {
            return [output, ZipChunksState.PullBoth];
          }
          return [output, ZipChunksState.PullRight(either.left)];
        }
      case "Right":
        {
          if (Chunk.isEmpty(either.right)) {
            return [output, ZipChunksState.PullBoth];
          }
          return [output, ZipChunksState.PullLeft(either.right)];
        }
    }
  };
  return combineChunks(that, ZipChunksState.PullBoth, pull)(self);
});
/** @internal */
exports.zipWithChunks = zipWithChunks;
const zipWithIndex = self => mapAccum(0, (index, a) => [index + 1, [a, index]])(self);
/** @internal */
exports.zipWithIndex = zipWithIndex;
const zipWithNext = self => {
  const process = last => core.readWithCause(input => {
    const [newLast, chunk] = Chunk.mapAccum(last, (prev, curr) => [Option.some(curr), Option.map(a => [a, curr])(prev)])(input);
    const output = Chunk.filterMap(option => Option.isSome(option) ? Option.some([option.value[0], Option.some(option.value[1])]) : Option.none())(chunk);
    return core.flatMap(() => process(newLast))(core.write(output));
  }, core.failCause, () => Option.match(core.unit, value => channel.zipRight(core.unit())(core.write(Chunk.of([value, Option.none()]))))(last));
  return new StreamImpl(channel.pipeToOrFail(process(Option.none()))(toChannel(self)));
};
/** @internal */
exports.zipWithNext = zipWithNext;
const zipWithPrevious = self => mapAccum(Option.none(), (prev, curr) => [Option.some(curr), [prev, curr]])(self);
/** @internal */
exports.zipWithPrevious = zipWithPrevious;
const zipWithPreviousAndNext = self => map(([[prev, curr], next]) => [prev, curr, Option.map(tuple => tuple[1])(next)])(zipWithNext(zipWithPrevious(self)));
/** @internal */
exports.zipWithPreviousAndNext = zipWithPreviousAndNext;
const zipChunks = (left, right, f) => {
  if (left.length > right.length) {
    return [Chunk.zipWith(right, f)(Chunk.take(right.length)(left)), Either.left(Chunk.drop(right.length)(left))];
  }
  return [Chunk.zipWith(Chunk.take(left.length)(right), f)(left), Either.right(Chunk.drop(left.length)(right))];
};
// Circular with Channel
/** @internal */
const channelToStream = self => {
  return new StreamImpl(self);
};
exports.channelToStream = channelToStream;
//# sourceMappingURL=stream.js.map