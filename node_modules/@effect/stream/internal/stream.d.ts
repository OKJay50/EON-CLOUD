import * as Option from "@effect/data/Option";
import type { Predicate } from "@effect/data/Predicate";
import * as Effect from "@effect/io/Effect";
import * as Exit from "@effect/io/Exit";
import * as Queue from "@effect/io/Queue";
import * as Schedule from "@effect/io/Schedule";
import type * as Scope from "@effect/io/Scope";
import type * as Stream from "@effect/stream/Stream";
export declare const distributedWithDynamicCallback: (<E, A, _>(maximumLag: number, decide: (a: A) => Effect.Effect<never, never, Predicate<number>>, done: (exit: Exit.Exit<Option.Option<E>, never>) => Effect.Effect<never, never, _>) => <R>(self: Stream.Stream<R, E, A>) => Effect.Effect<Scope.Scope | R, never, Effect.Effect<never, never, readonly [number, Queue.Dequeue<Exit.Exit<Option.Option<E>, A>>]>>) & (<R_1, E_1, A_1, __1>(self: Stream.Stream<R_1, E_1, A_1>, maximumLag: number, decide: (a: A_1) => Effect.Effect<never, never, Predicate<number>>, done: (exit: Exit.Exit<Option.Option<E_1>, never>) => Effect.Effect<never, never, __1>) => Effect.Effect<Scope.Scope | R_1, never, Effect.Effect<never, never, readonly [number, Queue.Dequeue<Exit.Exit<Option.Option<E_1>, A_1>>]>>);
/**
 * Repeats the value using the provided schedule.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const repeatWithSchedule: <R, A, _>(value: A, schedule: Schedule.Schedule<R, A, _>) => Stream.Stream<R, never, A>;
//# sourceMappingURL=stream.d.ts.map