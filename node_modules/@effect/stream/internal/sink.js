"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = exports.logWarningCauseMessage = exports.logWarningCause = exports.logWarning = exports.logTraceCauseMessage = exports.logTraceCause = exports.logTrace = exports.logInfoCauseMessage = exports.logInfoCause = exports.logInfo = exports.logFatalCauseMessage = exports.logFatalCause = exports.logFatal = exports.logErrorCauseMessage = exports.logErrorCause = exports.logError = exports.logDebugCauseMessage = exports.logDebugCause = exports.logDebug = exports.log = exports.leftover = exports.last = exports.ignoreLeftover = exports.head = exports.fromQueueWithShutdown = exports.fromQueue = exports.fromPush = exports.fromHubWithShutdown = exports.fromHub = exports.fromEffect = exports.fromChannel = exports.forEachWhile = exports.forEachChunkWhile = exports.forEachChunk = exports.forEach = exports.foldWeightedEffect = exports.foldWeightedDecomposeEffect = exports.foldWeightedDecompose = exports.foldWeighted = exports.foldUntilEffect = exports.foldUntil = exports.foldSink = exports.foldLeftEffect = exports.foldLeftChunksEffect = exports.foldLeftChunks = exports.foldLeft = exports.foldEffect = exports.foldChunksEffect = exports.foldChunks = exports.fold = exports.flatMap = exports.findEffect = exports.filterInputEffect = exports.filterInput = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.every = exports.ensuringWith = exports.ensuring = exports.dropWhileEffect = exports.dropWhile = exports.dropUntilEffect = exports.dropUntil = exports.drop = exports.drain = exports.dimapEffect = exports.dimapChunksEffect = exports.dimapChunks = exports.dimap = exports.dieSync = exports.dieMessage = exports.die = exports.count = exports.contramapEffect = exports.contramapChunksEffect = exports.contramapChunks = exports.contramap = exports.contextWithSink = exports.contextWithEffect = exports.contextWith = exports.context = exports.collectLeftover = exports.collectAllWhileWith = exports.collectAllWhileEffect = exports.collectAllWhile = exports.collectAllUntilEffect = exports.collectAllUntil = exports.collectAllToSetN = exports.collectAllToSet = exports.collectAllToMapN = exports.collectAllToMap = exports.collectAllN = exports.collectAllFrom = exports.collectAll = exports.channelToSink = exports.as = exports.SinkTypeId = exports.SinkImpl = void 0;
exports.zipWithPar = exports.zipWith = exports.zipRight = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeft = exports.zip = exports.withDuration = exports.unwrapScoped = exports.unwrap = exports.toChannel = exports.timed = exports.take = exports.sync = exports.suspend = exports.summarized = exports.sum = exports.succeed = exports.splitWhere = exports.some = exports.serviceWithSink = exports.serviceWithEffect = exports.serviceWith = exports.service = exports.refineOrDieWith = exports.refineOrDie = exports.raceWithCapacity = exports.raceWith = exports.raceBothCapacity = exports.raceBoth = exports.race = exports.provideContext = exports.orElse = exports.never = exports.mkString = exports.mapLeftover = exports.mapError = exports.mapEffect = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Context"));
var Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Duration"));
var Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/HashMap"));
var HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/HashSet"));
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var ReadonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Clock"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Exit"));
var Hub = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Hub"));
var Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Queue"));
var Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Ref"));
var channel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel"));
var mergeDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/mergeDecision"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/core"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a;
/** @internal */
const SinkSymbolKey = "@effect/stream/Sink";
/** @internal */
const SinkTypeId = /*#__PURE__*/Symbol.for(SinkSymbolKey);
/** @internal */
exports.SinkTypeId = SinkTypeId;
const sinkVariance = {
  _R: _ => _,
  _E: _ => _,
  _In: _ => _,
  _L: _ => _,
  _Z: _ => _
};
/** @internal */
class SinkImpl {
  constructor(channel) {
    this.channel = channel;
    this[_a] = sinkVariance;
  }
}
exports.SinkImpl = SinkImpl;
_a = SinkTypeId;
/** @internal */
const as = /*#__PURE__*/(0, _Function.dual)(2, (self, z) => map(() => z)(self));
/** @internal */
exports.as = as;
const collectAll = () => new SinkImpl(collectAllLoop(Chunk.empty()));
/** @internal */
exports.collectAll = collectAll;
const collectAllLoop = acc => core.readWithCause(chunk => collectAllLoop(Chunk.concat(chunk)(acc)), core.failCause, () => core.succeed(acc));
/** @internal */
const collectAllN = n => {
  return flatMap(builder => foldUntil(builder, n, (chunk, input) => Chunk.append(input)(chunk)))(fromEffect(Effect.sync(() => Chunk.empty())));
};
/** @internal */
exports.collectAllN = collectAllN;
const collectAllFrom = self => collectAllWhileWith(Chunk.empty(), _Function.constTrue, (chunk, z) => Chunk.append(z)(chunk))(self);
/** @internal */
exports.collectAllFrom = collectAllFrom;
const collectAllToMap = (key, merge) => {
  return foldLeftChunks(HashMap.empty(), (map, chunk) => Chunk.reduce(map, (map, input) => {
    const k = key(input);
    const v = HashMap.has(k)(map) ? merge(HashMap.unsafeGet(k)(map), input) : input;
    return HashMap.set(k, v)(map);
  })(chunk));
};
/** @internal */
exports.collectAllToMap = collectAllToMap;
const collectAllToMapN = (n, key, merge) => {
  return foldWeighted(HashMap.empty(), n, (acc, input) => HashMap.has(key(input))(acc) ? 0 : 1, (acc, input) => {
    const k = key(input);
    const v = HashMap.has(k)(acc) ? merge(HashMap.unsafeGet(k)(acc), input) : input;
    return HashMap.set(k, v)(acc);
  });
};
/** @internal */
exports.collectAllToMapN = collectAllToMapN;
const collectAllToSet = () => foldLeftChunks(HashSet.empty(), (acc, chunk) => Chunk.reduce(acc, (acc, input) => HashSet.add(input)(acc))(chunk));
/** @internal */
exports.collectAllToSet = collectAllToSet;
const collectAllToSetN = n => foldWeighted(HashSet.empty(), n, (acc, input) => HashSet.has(input)(acc) ? 0 : 1, (acc, input) => HashSet.add(input)(acc));
/** @internal */
exports.collectAllToSetN = collectAllToSetN;
const collectAllUntil = p => {
  return map(tuple => tuple[0])(fold([Chunk.empty(), true], tuple => tuple[1], ([chunk, _], input) => [Chunk.append(input)(chunk), !p(input)]));
};
/** @internal */
exports.collectAllUntil = collectAllUntil;
const collectAllUntilEffect = p => {
  return map(tuple => tuple[0])(foldEffect([Chunk.empty(), true], tuple => tuple[1], ([chunk, _], input) => Effect.map(bool => [Chunk.append(input)(chunk), !bool])(p(input))));
};
/** @internal */
exports.collectAllUntilEffect = collectAllUntilEffect;
const collectAllWhile = predicate => fromChannel(collectAllWhileReader(predicate, Chunk.empty()));
/** @internal */
exports.collectAllWhile = collectAllWhile;
const collectAllWhileReader = (predicate, done) => core.readWith(input => {
  const [collected, leftovers] = ReadonlyArray.span(predicate)(Chunk.toReadonlyArray(input));
  if (leftovers.length === 0) {
    return collectAllWhileReader(predicate, Chunk.concat(Chunk.unsafeFromArray(collected))(done));
  }
  return channel.zipRight(core.succeed(Chunk.concat(Chunk.unsafeFromArray(collected))(done)))(core.write(Chunk.unsafeFromArray(leftovers)));
}, core.fail, () => core.succeed(done));
/** @internal */
const collectAllWhileEffect = predicate => fromChannel(collectAllWhileEffectReader(predicate, Chunk.empty()));
/** @internal */
exports.collectAllWhileEffect = collectAllWhileEffect;
const collectAllWhileEffectReader = (predicate, done) => core.readWith(input => core.flatMap(collected => {
  const leftovers = Chunk.drop(collected.length)(input);
  if (Chunk.isEmpty(leftovers)) {
    return collectAllWhileEffectReader(predicate, Chunk.concat(collected)(done));
  }
  return channel.zipRight(core.succeed(Chunk.concat(collected)(done)))(core.write(leftovers));
})(core.fromEffect(Effect.takeWhile(predicate)(input))), core.fail, () => core.succeed(done));
/** @internal */
const collectAllWhileWith = /*#__PURE__*/(0, _Function.dual)(4, (self, z, p, f) => {
  const refs = Effect.zip(Ref.make(false))(Ref.make(Chunk.empty()));
  const newChannel = core.flatMap(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = core.readWith(input => core.flatMap(() => upstreamMarker)(core.write(input)), core.fail, done => channel.as(done)(core.fromEffect(Ref.set(upstreamDoneRef, true))));
    return core.pipeTo(collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, z, p, f))(core.pipeTo(channel.bufferChunk(leftoversRef))(upstreamMarker));
  })(core.fromEffect(refs));
  return new SinkImpl(newChannel);
});
/** @internal */
exports.collectAllWhileWith = collectAllWhileWith;
const collectAllWhileWithLoop = (self, leftoversRef, upstreamDoneRef, currentResult, p, f) => {
  return channel.foldChannel(core.fail, ([leftovers, doneValue]) => p(doneValue) ? core.flatMap(() => core.flatMap(upstreamDone => {
    const accumulatedResult = f(currentResult, doneValue);
    return upstreamDone ? channel.as(accumulatedResult)(core.write(Chunk.flatten(leftovers))) : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f);
  })(core.fromEffect(Ref.get(upstreamDoneRef))))(core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers)))) : channel.as(currentResult)(core.write(Chunk.flatten(leftovers))))(channel.doneCollect(toChannel(self)));
};
/** @internal */
const collectLeftover = self => new SinkImpl(channel.map(([chunks, z]) => [z, Chunk.flatten(chunks)])(core.collectElements(toChannel(self))));
/** @internal */
exports.collectLeftover = collectLeftover;
const contramap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contramapChunks(Chunk.map(f))(self));
/** @internal */
exports.contramap = contramap;
const contramapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contramapChunksEffect(Effect.forEach(f))(self));
/** @internal */
exports.contramapEffect = contramapEffect;
const contramapChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = core.readWith(chunk => core.flatMap(() => loop)(core.write(f(chunk))), core.fail, core.succeed);
  return new SinkImpl(core.pipeTo(toChannel(self))(loop));
});
/** @internal */
exports.contramapChunks = contramapChunks;
const contramapChunksEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = core.readWith(chunk => core.flatMap(() => loop)(core.flatMap(core.write)(core.fromEffect(f(chunk)))), core.fail, core.succeed);
  return new SinkImpl(channel.pipeToOrFail(toChannel(self))(loop));
});
/** @internal */
exports.contramapChunksEffect = contramapChunksEffect;
const count = () => foldLeft(0, (s, _) => s + 1);
/** @internal */
exports.count = count;
const die = defect => failCause(Cause.die(defect));
/** @internal */
exports.die = die;
const dieMessage = message => failCause(Cause.die(Cause.RuntimeException(message)));
/** @internal */
exports.dieMessage = dieMessage;
const dieSync = evaluate => failCauseSync(() => Cause.die(evaluate()));
/** @internal */
exports.dieSync = dieSync;
const dimap = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => map(g)(contramap(f)(self)));
/** @internal */
exports.dimap = dimap;
const dimapEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => mapEffect(g)(contramapEffect(f)(self)));
/** @internal */
exports.dimapEffect = dimapEffect;
const dimapChunks = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => map(g)(contramapChunks(f)(self)));
/** @internal */
exports.dimapChunks = dimapChunks;
const dimapChunksEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => mapEffect(g)(contramapChunksEffect(f)(self)));
/** @internal */
exports.dimapChunksEffect = dimapChunksEffect;
const drain = () => new SinkImpl(channel.drain(channel.identityChannel()));
/** @internal */
exports.drain = drain;
const drop = n => suspend(() => new SinkImpl(dropLoop(n)));
/** @internal */
exports.drop = drop;
const dropLoop = n => core.readWith(input => {
  const dropped = Chunk.drop(n)(input);
  const leftover = Math.max(n - input.length, 0);
  const more = Chunk.isEmpty(input) || leftover > 0;
  if (more) {
    return dropLoop(leftover);
  }
  return channel.zipRight(channel.identityChannel())(core.write(dropped));
}, core.fail, core.unit);
/** @internal */
const dropUntil = predicate => new SinkImpl(channel.pipeToOrFail(toChannel(drop(1)))(toChannel(dropWhile(input => !predicate(input)))));
/** @internal */
exports.dropUntil = dropUntil;
const dropUntilEffect = predicate => suspend(() => new SinkImpl(dropUntilEffectReader(predicate)));
/** @internal */
exports.dropUntilEffect = dropUntilEffect;
const dropUntilEffectReader = predicate => core.readWith(input => channel.unwrap(Effect.map(leftover => {
  const more = Chunk.isEmpty(leftover);
  return more ? dropUntilEffectReader(predicate) : channel.zipRight(channel.identityChannel())(core.write(leftover));
})(Effect.dropUntil(predicate)(input))), core.fail, core.unit);
/** @internal */
const dropWhile = predicate => new SinkImpl(dropWhileReader(predicate));
/** @internal */
exports.dropWhile = dropWhile;
const dropWhileReader = predicate => core.readWith(input => {
  const out = Chunk.dropWhile(predicate)(input);
  if (Chunk.isEmpty(out)) {
    return dropWhileReader(predicate);
  }
  return channel.zipRight(channel.identityChannel())(core.write(out));
}, core.fail, core.succeedNow);
/** @internal */
const dropWhileEffect = predicate => suspend(() => new SinkImpl(dropWhileEffectReader(predicate)));
/** @internal */
exports.dropWhileEffect = dropWhileEffect;
const dropWhileEffectReader = predicate => core.readWith(input => channel.unwrap(Effect.map(leftover => {
  const more = Chunk.isEmpty(leftover);
  return more ? dropWhileEffectReader(predicate) : channel.zipRight(channel.identityChannel())(core.write(leftover));
})(Effect.dropWhile(predicate)(input))), core.fail, core.unit);
/** @internal */
const ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new SinkImpl(channel.ensuring(finalizer)(toChannel(self))));
/** @internal */
exports.ensuring = ensuring;
const ensuringWith = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new SinkImpl(core.ensuringWith(finalizer)(toChannel(self))));
/** @internal */
exports.ensuringWith = ensuringWith;
const context = () => fromEffect(Effect.context());
/** @internal */
exports.context = context;
const contextWith = f => map(f)(context());
/** @internal */
exports.contextWith = contextWith;
const contextWithEffect = f => mapEffect(f)(context());
/** @internal */
exports.contextWithEffect = contextWithEffect;
const contextWithSink = f => new SinkImpl(channel.unwrap(Effect.contextWith(context => toChannel(f(context)))));
/** @internal */
exports.contextWithSink = contextWithSink;
const every = predicate => fold(true, _Function.identity, (acc, input) => acc && predicate(input));
/** @internal */
exports.every = every;
const fail = e => new SinkImpl(core.fail(e));
/** @internal */
exports.fail = fail;
const failSync = evaluate => new SinkImpl(core.failSync(evaluate));
/** @internal */
exports.failSync = failSync;
const failCause = cause => new SinkImpl(core.failCause(cause));
/** @internal */
exports.failCause = failCause;
const failCauseSync = evaluate => new SinkImpl(core.failCauseSync(evaluate));
/** @internal */
exports.failCauseSync = failCauseSync;
const filterInput = f => {
  return self => contramapChunks(Chunk.filter(f))(self);
};
/** @internal */
exports.filterInput = filterInput;
const filterInputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contramapChunksEffect(Effect.filter(f))(self));
/** @internal */
exports.filterInputEffect = filterInputEffect;
const findEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const newChannel = core.flatMap(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = core.readWith(input => core.flatMap(() => upstreamMarker)(core.write(input)), core.fail, done => channel.as(done)(core.fromEffect(Ref.set(upstreamDoneRef, true))));
    const loop = channel.foldChannel(core.fail, ([leftovers, doneValue]) => core.flatMap(satisfied => channel.zipRight(core.flatMap(upstreamDone => {
      if (satisfied) {
        return channel.as(Option.some(doneValue))(core.write(Chunk.flatten(leftovers)));
      }
      if (upstreamDone) {
        return channel.as(Option.none())(core.write(Chunk.flatten(leftovers)));
      }
      return loop;
    })(core.fromEffect(Ref.get(upstreamDoneRef))))(core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers)))))(core.fromEffect(f(doneValue))))(core.collectElements(toChannel(self)));
    return core.pipeTo(loop)(core.pipeTo(channel.bufferChunk(leftoversRef))(upstreamMarker));
  })(core.fromEffect(Effect.zip(Ref.make(false))(Ref.make(Chunk.empty()))));
  return new SinkImpl(newChannel);
});
/** @internal */
exports.findEffect = findEffect;
const fold = (s, contFn, f) => suspend(() => new SinkImpl(foldReader(s, contFn, f)));
/** @internal */
exports.fold = fold;
const foldReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return core.succeedNow(s);
  }
  return core.readWith(input => {
    const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
    if (Chunk.isNonEmpty(leftovers)) {
      return channel.as(nextS)(core.write(leftovers));
    }
    return foldReader(nextS, contFn, f);
  }, core.fail, () => core.succeedNow(s));
};
/** @internal */
const foldChunkSplit = (s, chunk, contFn, f, index, length) => {
  if (index === length) {
    return [s, Chunk.empty()];
  }
  const s1 = f(s, Chunk.unsafeGet(index)(chunk));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk, contFn, f, index + 1, length);
  }
  return [s1, Chunk.drop(index + 1)(chunk)];
};
/** @internal */
const foldSink = /*#__PURE__*/(0, _Function.dual)(3, (self, onFailure, onSuccess) => {
  const newChannel = channel.foldChannel(error => toChannel(onFailure(error)), ([leftovers, z]) => core.suspend(() => {
    const leftoversRef = {
      ref: Chunk.filter(Chunk.isNonEmpty)(leftovers)
    };
    const refReader =
    // This cast is safe because of the L1 >: L <: In1 bound. It follows that
    // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
    core.flatMap(chunk => channel.writeChunk(chunk))(core.sync(() => {
      const ref = leftoversRef.ref;
      leftoversRef.ref = Chunk.empty();
      return ref;
    }));
    const passthrough = channel.identityChannel();
    const continuationSink = core.pipeTo(toChannel(onSuccess(z)))(channel.zipRight(passthrough)(refReader));
    return core.flatMap(([newLeftovers, z1]) => channel.as(z1)(channel.zipRight(channel.writeChunk(newLeftovers))(core.flatMap(channel.writeChunk)(core.succeed(leftoversRef.ref)))))(core.collectElements(continuationSink));
  }))(core.collectElements(toChannel(self)));
  return new SinkImpl(newChannel);
});
/** @internal */
exports.foldSink = foldSink;
const foldChunks = (s, contFn, f) => suspend(() => new SinkImpl(foldChunksReader(s, contFn, f)));
/** @internal */
exports.foldChunks = foldChunks;
const foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return core.succeedNow(s);
  }
  return core.readWith(input => foldChunksReader(f(s, input), contFn, f), core.fail, () => core.succeedNow(s));
};
/** @internal */
const foldChunksEffect = (s, contFn, f) => suspend(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)));
/** @internal */
exports.foldChunksEffect = foldChunksEffect;
const foldChunksEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return core.succeedNow(s);
  }
  return core.readWith(input => core.flatMap(s => foldChunksEffectReader(s, contFn, f))(core.fromEffect(f(s, input))), core.fail, () => core.succeedNow(s));
};
/** @internal */
const foldEffect = (s, contFn, f) => suspend(() => new SinkImpl(foldEffectReader(s, contFn, f)));
/** @internal */
exports.foldEffect = foldEffect;
const foldEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return core.succeedNow(s);
  }
  return core.readWith(input => core.flatMap(([nextS, leftovers]) => Option.match(() => foldEffectReader(nextS, contFn, f), leftover => channel.as(nextS)(core.write(leftover)))(leftovers))(core.fromEffect(foldChunkSplitEffect(s, input, contFn, f))), core.fail, () => core.succeedNow(s));
};
/** @internal */
const foldChunkSplitEffect = (s, chunk, contFn, f) => foldChunkSplitEffectInternal(s, chunk, 0, chunk.length, contFn, f);
/** @internal */
const foldChunkSplitEffectInternal = (s, chunk, index, length, contFn, f) => {
  if (index === length) {
    return Effect.succeed([s, Option.none()]);
  }
  return Effect.flatMap(s1 => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk, index + 1, length, contFn, f) : Effect.succeed([s1, Option.some(Chunk.drop(index + 1)(chunk))]))(f(s, Chunk.unsafeGet(index)(chunk)));
};
/** @internal */
const foldLeft = (s, f) => ignoreLeftover(fold(s, _Function.constTrue, f));
/** @internal */
exports.foldLeft = foldLeft;
const foldLeftChunks = (s, f) => foldChunks(s, _Function.constTrue, f);
/** @internal */
exports.foldLeftChunks = foldLeftChunks;
const foldLeftChunksEffect = (s, f) => ignoreLeftover(foldChunksEffect(s, _Function.constTrue, f));
/** @internal */
exports.foldLeftChunksEffect = foldLeftChunksEffect;
const foldLeftEffect = (s, f) => foldEffect(s, _Function.constTrue, f);
/** @internal */
exports.foldLeftEffect = foldLeftEffect;
const foldUntil = (s, max, f) => map(tuple => tuple[0])(fold([s, 0], tuple => tuple[1] < max, ([output, count], input) => [f(output, input), count + 1]));
/** @internal */
exports.foldUntil = foldUntil;
const foldUntilEffect = (s, max, f) => map(tuple => tuple[0])(foldEffect([s, 0], tuple => tuple[1] < max, ([output, count], input) => Effect.map(s => [s, count + 1])(f(output, input))));
/** @internal */
exports.foldUntilEffect = foldUntilEffect;
const foldWeighted = (s, max, costFn, f) => foldWeightedDecompose(s, max, costFn, Chunk.of, f);
/** @internal */
exports.foldWeighted = foldWeighted;
const foldWeightedDecompose = (s, max, costFn, decompose, f) => suspend(() => new SinkImpl(foldWeightedDecomposeLoop(s, 0, false, max, costFn, decompose, f)));
/** @internal */
exports.foldWeightedDecompose = foldWeightedDecompose;
const foldWeightedDecomposeLoop = (s, cost, dirty, max, costFn, decompose, f) => core.readWith(input => {
  const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(input, 0, s, cost, dirty, max, costFn, decompose, f);
  if (Chunk.isNonEmpty(leftovers)) {
    return channel.zipRight(core.succeedNow(nextS))(core.write(leftovers));
  }
  if (cost > max) {
    return core.succeedNow(nextS);
  }
  return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max, costFn, decompose, f);
}, core.fail, () => core.succeedNow(s));
/** @internal */
const foldWeightedDecomposeFold = (input, index, s, cost, dirty, max, costFn, decompose, f) => {
  if (index === input.length) {
    return [s, cost, dirty, Chunk.empty()];
  }
  const elem = Chunk.unsafeGet(index)(input);
  const total = cost + costFn(s, elem);
  if (total <= max) {
    return foldWeightedDecomposeFold(input, index + 1, f(s, elem), total, true, max, costFn, decompose, f);
  }
  const decomposed = decompose(elem);
  if (decomposed.length <= 1 && !dirty) {
    // If `elem` cannot be decomposed, we need to cross the `max` threshold. To
    // minimize "injury", we only allow this when we haven't added anything else
    // to the aggregate (dirty = false).
    return [f(s, elem), total, true, Chunk.drop(index + 1)(input)];
  }
  if (decomposed.length <= 1 && dirty) {
    // If the state is dirty and `elem` cannot be decomposed, we stop folding
    // and include `elem` in the leftovers.
    return [s, cost, dirty, Chunk.drop(index)(input)];
  }
  // `elem` got decomposed, so we will recurse with the decomposed elements pushed
  // into the chunk we're processing and see if we can aggregate further.
  const next = Chunk.concat(Chunk.drop(index + 1)(input))(decomposed);
  return foldWeightedDecomposeFold(next, 0, s, cost, dirty, max, costFn, decompose, f);
};
/** @internal */
const foldWeightedDecomposeEffect = (s, max, costFn, decompose, f) => suspend(() => new SinkImpl(foldWeightedDecomposeEffectLoop(s, max, costFn, decompose, f, 0, false)));
/** @internal */
exports.foldWeightedDecomposeEffect = foldWeightedDecomposeEffect;
const foldWeightedEffect = (s, max, costFn, f) => foldWeightedDecomposeEffect(s, max, costFn, input => Effect.succeed(Chunk.of(input)), f);
/** @internal */
exports.foldWeightedEffect = foldWeightedEffect;
const foldWeightedDecomposeEffectLoop = (s, max, costFn, decompose, f, cost, dirty) => core.readWith(input => core.flatMap(([nextS, nextCost, nextDirty, leftovers]) => {
  if (Chunk.isNonEmpty(leftovers)) {
    return channel.zipRight(core.succeedNow(nextS))(core.write(leftovers));
  }
  if (cost > max) {
    return core.succeedNow(nextS);
  }
  return foldWeightedDecomposeEffectLoop(nextS, max, costFn, decompose, f, nextCost, nextDirty);
})(core.fromEffect(foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, dirty, cost, 0))), core.fail, () => core.succeedNow(s));
/** @internal */
const foldWeightedDecomposeEffectFold = (s, max, costFn, decompose, f, input, dirty, cost, index) => {
  if (index === input.length) {
    return Effect.succeed([s, cost, dirty, Chunk.empty()]);
  }
  const elem = Chunk.unsafeGet(index)(input);
  return Effect.flatMap(total => {
    if (total <= max) {
      return Effect.flatMap(s => foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, true, total, index + 1))(f(s, elem));
    }
    return Effect.flatMap(decomposed => {
      if (decomposed.length <= 1 && !dirty) {
        // If `elem` cannot be decomposed, we need to cross the `max` threshold. To
        // minimize "injury", we only allow this when we haven't added anything else
        // to the aggregate (dirty = false).
        return Effect.map(s => [s, total, true, Chunk.drop(index + 1)(input)])(f(s, elem));
      }
      if (decomposed.length <= 1 && dirty) {
        // If the state is dirty and `elem` cannot be decomposed, we stop folding
        // and include `elem` in th leftovers.
        return Effect.succeed([s, cost, dirty, Chunk.drop(index)(input)]);
      }
      // `elem` got decomposed, so we will recurse with the decomposed elements pushed
      // into the chunk we're processing and see if we can aggregate further.
      const next = Chunk.concat(Chunk.drop(index + 1)(input))(decomposed);
      return foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, next, dirty, cost, 0);
    })(decompose(elem));
  })(Effect.map(newCost => cost + newCost)(costFn(s, elem)));
};
/** @internal */
const flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => foldSink(fail, f)(self));
/** @internal */
exports.flatMap = flatMap;
const forEach = f => {
  const process = core.readWithCause(input => core.flatMap(() => process)(core.fromEffect(Effect.forEachDiscard(f)(input))), core.failCause, core.unit);
  return new SinkImpl(process);
};
/** @internal */
exports.forEach = forEach;
const forEachChunk = f => {
  const process = core.readWithCause(input => core.flatMap(() => process)(core.fromEffect(f(input))), core.failCause, core.unit);
  return new SinkImpl(process);
};
/** @internal */
exports.forEachChunk = forEachChunk;
const forEachWhile = f => {
  const process = core.readWithCause(input => forEachWhileReader(f, input, 0, input.length, process), core.failCause, core.unit);
  return new SinkImpl(process);
};
/** @internal */
exports.forEachWhile = forEachWhile;
const forEachWhileReader = (f, input, index, length, cont) => {
  if (index === length) {
    return cont;
  }
  return channel.catchAll(error => channel.zipRight(core.fail(error))(core.write(Chunk.drop(index)(input))))(core.flatMap(bool => bool ? forEachWhileReader(f, input, index + 1, length, cont) : core.write(Chunk.drop(index)(input)))(core.fromEffect(f(Chunk.unsafeGet(index)(input)))));
};
/** @internal */
const forEachChunkWhile = f => {
  const reader = core.readWith(input => core.flatMap(cont => cont ? reader : core.unit())(core.fromEffect(f(input))), core.fail, core.unit);
  return new SinkImpl(reader);
};
/** @internal */
exports.forEachChunkWhile = forEachChunkWhile;
const fromChannel = channel => new SinkImpl(channel);
/** @internal */
exports.fromChannel = fromChannel;
const fromEffect = effect => new SinkImpl(core.fromEffect(effect));
/** @internal */
exports.fromEffect = fromEffect;
const fromHub = hub => fromQueue(hub);
/** @internal */
exports.fromHub = fromHub;
const fromHubWithShutdown = hub => fromQueueWithShutdown(hub);
/** @internal */
exports.fromHubWithShutdown = fromHubWithShutdown;
const fromPush = push => new SinkImpl(channel.unwrapScoped(Effect.map(fromPushPull)(push)));
exports.fromPush = fromPush;
const fromPushPull = push => core.readWith(input => channel.foldChannel(([either, leftovers]) => Either.match(error => channel.zipRight(core.fail(error))(core.write(leftovers)), z => channel.zipRight(core.succeedNow(z))(core.write(leftovers)))(either), () => fromPushPull(push))(core.fromEffect(push(Option.some(input)))), core.fail, () => channel.foldChannel(([either, leftovers]) => Either.match(error => channel.zipRight(core.fail(error))(core.write(leftovers)), z => channel.zipRight(core.succeedNow(z))(core.write(leftovers)))(either), () => core.fromEffect(Effect.dieMessage("BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/stream/issues")))(core.fromEffect(push(Option.none()))));
/** @internal */
const fromQueue = queue => forEachChunk(input => Queue.offerAll(queue, input));
/** @internal */
exports.fromQueue = fromQueue;
const fromQueueWithShutdown = queue => unwrapScoped(Effect.map(fromQueue)(Effect.acquireRelease(Effect.succeed(queue), Queue.shutdown)));
/** @internal */
exports.fromQueueWithShutdown = fromQueueWithShutdown;
const head = () => fold(Option.none(), Option.isNone, (option, input) => Option.match(() => Option.some(input), () => option)(option));
/** @internal */
exports.head = head;
const ignoreLeftover = self => new SinkImpl(channel.drain(toChannel(self)));
/** @internal */
exports.ignoreLeftover = ignoreLeftover;
const last = () => foldLeft(Option.none(), (_, input) => Option.some(input));
/** @internal */
exports.last = last;
const leftover = chunk => new SinkImpl(core.suspend(() => core.write(chunk)));
/** @internal */
exports.leftover = leftover;
const log = message => fromEffect(Effect.log(message));
/** @internal */
exports.log = log;
const logDebug = message => fromEffect(Effect.logDebug(message));
/** @internal */
exports.logDebug = logDebug;
const logDebugCause = cause => fromEffect(Effect.logDebugCause(cause));
/** @internal */
exports.logDebugCause = logDebugCause;
const logDebugCauseMessage = (message, cause) => fromEffect(Effect.logDebugCauseMessage(message, cause));
/** @internal */
exports.logDebugCauseMessage = logDebugCauseMessage;
const logError = message => fromEffect(Effect.logError(message));
/** @internal */
exports.logError = logError;
const logErrorCause = cause => fromEffect(Effect.logErrorCause(cause));
/** @internal */
exports.logErrorCause = logErrorCause;
const logErrorCauseMessage = (message, cause) => fromEffect(Effect.logErrorCauseMessage(message, cause));
/** @internal */
exports.logErrorCauseMessage = logErrorCauseMessage;
const logFatal = message => fromEffect(Effect.logFatal(message));
/** @internal */
exports.logFatal = logFatal;
const logFatalCause = cause => fromEffect(Effect.logFatalCause(cause));
/** @internal */
exports.logFatalCause = logFatalCause;
const logFatalCauseMessage = (message, cause) => fromEffect(Effect.logFatalCauseMessage(message, cause));
/** @internal */
exports.logFatalCauseMessage = logFatalCauseMessage;
const logInfo = message => fromEffect(Effect.logInfo(message));
/** @internal */
exports.logInfo = logInfo;
const logInfoCause = cause => fromEffect(Effect.logInfoCause(cause));
/** @internal */
exports.logInfoCause = logInfoCause;
const logInfoCauseMessage = (message, cause) => fromEffect(Effect.logInfoCauseMessage(message, cause));
/** @internal */
exports.logInfoCauseMessage = logInfoCauseMessage;
const logWarning = message => fromEffect(Effect.logWarning(message));
/** @internal */
exports.logWarning = logWarning;
const logWarningCause = cause => fromEffect(Effect.logWarningCause(cause));
/** @internal */
exports.logWarningCause = logWarningCause;
const logWarningCauseMessage = (message, cause) => fromEffect(Effect.logWarningCauseMessage(message, cause));
/** @internal */
exports.logWarningCauseMessage = logWarningCauseMessage;
const logTrace = message => fromEffect(Effect.logTrace(message));
/** @internal */
exports.logTrace = logTrace;
const logTraceCause = cause => fromEffect(Effect.logTraceCause(cause));
/** @internal */
exports.logTraceCause = logTraceCause;
const logTraceCauseMessage = (message, cause) => fromEffect(Effect.logTraceCauseMessage(message, cause));
/** @internal */
exports.logTraceCauseMessage = logTraceCauseMessage;
const map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  return new SinkImpl(channel.map(f)(toChannel(self)));
});
/** @internal */
exports.map = map;
const mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl(channel.mapEffect(f)(toChannel(self))));
/** @internal */
exports.mapEffect = mapEffect;
const mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl(channel.mapError(f)(toChannel(self))));
/** @internal */
exports.mapError = mapError;
const mapLeftover = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl(channel.mapOut(Chunk.map(f))(toChannel(self))));
/** @internal */
exports.mapLeftover = mapLeftover;
const mkString = () => suspend(() => {
  const strings = [];
  return map(() => strings.join(""))(foldLeftChunks(void 0, (_, elems) => Chunk.forEach(elems, elem => {
    strings.push(String(elem));
  })));
});
/** @internal */
exports.mkString = mkString;
const never = () => fromEffect(Effect.never());
/** @internal */
exports.never = never;
const orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new SinkImpl(channel.orElse(() => toChannel(that()))(toChannel(self))));
/** @internal */
exports.orElse = orElse;
const provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => new SinkImpl(core.provideContext(context)(toChannel(self))));
/** @internal */
exports.provideContext = provideContext;
const race = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => map(Either.merge)(raceBoth(that)(self)));
/** @internal */
exports.race = race;
const raceBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => raceBothCapacity(self, that, 16));
/** @internal */
exports.raceBoth = raceBoth;
const raceBothCapacity = /*#__PURE__*/(0, _Function.dual)(3, (self, that, capacity) => {
  return raceWithCapacity(self, that, selfDone => mergeDecision.Done(Effect.map(Either.left)(Effect.done(selfDone))), thatDone => mergeDecision.Done(Effect.map(Either.right)(Effect.done(thatDone))), capacity);
});
/** @internal */
exports.raceBothCapacity = raceBothCapacity;
const raceWith = /*#__PURE__*/(0, _Function.dual)(4, (self, that, leftDone, rightDone) => raceWithCapacity(self, that, leftDone, rightDone, 16));
/** @internal */
exports.raceWith = raceWith;
const raceWithCapacity = /*#__PURE__*/(0, _Function.dual)(5, (self, that, leftDone, rightDone, capacity) => {
  const scoped = Effect.gen(function* ($) {
    const hub = yield* $(Hub.bounded(capacity));
    const channel1 = yield* $(channel.fromHubScoped(hub));
    const channel2 = yield* $(channel.fromHubScoped(hub));
    const reader = channel.toHub(hub);
    const writer = channel.mergeWith(core.pipeTo(toChannel(that))(channel2), leftDone, rightDone)(core.pipeTo(toChannel(self))(channel1));
    const racedChannel = channel.mergeWith(writer, () => mergeDecision.Await(exit => Effect.done(exit)), done => mergeDecision.Done(Effect.done(done)))(reader);
    return new SinkImpl(racedChannel);
  });
  return unwrapScoped(scoped);
});
/** @internal */
exports.raceWithCapacity = raceWithCapacity;
const refineOrDie = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => refineOrDieWith(pf, _Function.identity)(self));
/** @internal */
exports.refineOrDie = refineOrDie;
const refineOrDieWith = /*#__PURE__*/(0, _Function.dual)(3, (self, pf, f) => {
  const newChannel = channel.catchAll(error => Option.match(() => core.failCauseSync(() => Cause.die(f(error))), core.fail)(pf(error)))(toChannel(self));
  return new SinkImpl(newChannel);
});
/** @internal */
exports.refineOrDieWith = refineOrDieWith;
const service = tag => serviceWith(tag, _Function.identity);
/** @internal */
exports.service = service;
const serviceWith = (tag, f) => fromEffect(Effect.map(tag, f));
/** @internal */
exports.serviceWith = serviceWith;
const serviceWithEffect = (tag, f) => fromEffect(Effect.flatMap(tag, f));
/** @internal */
exports.serviceWithEffect = serviceWithEffect;
const serviceWithSink = (tag, f) => new SinkImpl(channel.unwrap(Effect.map(tag, service => toChannel(f(service)))));
/** @internal */
exports.serviceWithSink = serviceWithSink;
const some = predicate => fold(false, bool => !bool, (acc, input) => acc || predicate(input));
/** @internal */
exports.some = some;
const splitWhere = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const newChannel = core.flatMap(ref => core.flatMap(([leftovers, z]) => core.flatMap(leftover => channel.zipRight(core.succeed(z))(core.write(Chunk.concat(Chunk.flatten(leftovers))(leftover))))(core.fromEffect(Ref.get(ref))))(core.collectElements(channel.pipeToOrFail(toChannel(self))(splitWhereSplitter(false, ref, f)))))(core.fromEffect(Ref.make(Chunk.empty())));
  return new SinkImpl(newChannel);
});
/** @internal */
exports.splitWhere = splitWhere;
const splitWhereSplitter = (written, leftovers, f) => core.readWithCause(input => {
  if (Chunk.isEmpty(input)) {
    return splitWhereSplitter(written, leftovers, f);
  }
  if (written) {
    const index = indexWhere(input, f);
    if (index === -1) {
      return channel.zipRight(splitWhereSplitter(true, leftovers, f))(core.write(input));
    }
    const [left, right] = Chunk.splitAt(index)(input);
    return channel.zipRight(core.fromEffect(Ref.set(leftovers, right)))(core.write(left));
  }
  const index = indexWhere(input, f, 1);
  if (index === -1) {
    return channel.zipRight(splitWhereSplitter(true, leftovers, f))(core.write(input));
  }
  const [left, right] = Chunk.splitAt(Math.max(index, 1))(input);
  return channel.zipRight(core.fromEffect(Ref.set(leftovers, right)))(core.write(left));
}, core.failCause, core.succeed);
/** @internal */
const indexWhere = (self, predicate, from = 0) => {
  const iterator = self[Symbol.iterator]();
  let index = 0;
  let result = -1;
  let next;
  while (result < 0 && (next = iterator.next()) && !next.done) {
    const a = next.value;
    if (index >= from && predicate(a)) {
      result = index;
    }
    index = index + 1;
  }
  return result;
};
/** @internal */
const succeed = z => new SinkImpl(core.succeed(z));
/** @internal */
exports.succeed = succeed;
const sum = () => foldLeft(0, (a, b) => a + b);
/** @internal */
exports.sum = sum;
const summarized = /*#__PURE__*/(0, _Function.dual)(3, (self, summary, f) => {
  const newChannel = core.flatMap(start => core.flatMap(done => channel.map(end => [done, f(start, end)])(core.fromEffect(summary)))(toChannel(self)))(core.fromEffect(summary));
  return new SinkImpl(newChannel);
});
/** @internal */
exports.summarized = summarized;
const suspend = evaluate => new SinkImpl(core.suspend(() => toChannel(evaluate())));
/** @internal */
exports.suspend = suspend;
const sync = evaluate => new SinkImpl(core.sync(evaluate));
/** @internal */
exports.sync = sync;
const take = n => flatMap(acc => {
  const [taken, leftover] = Chunk.splitAt(n)(acc);
  return new SinkImpl(channel.zipRight(core.succeedNow(taken))(core.write(leftover)));
})(foldChunks(Chunk.empty(), chunk => chunk.length < n, (acc, chunk) => Chunk.concat(chunk)(acc)));
/** @internal */
exports.take = take;
const timed = () => map(tuple => tuple[1])(withDuration(drain()));
/** @internal */
exports.timed = timed;
const toChannel = self => Context.isGenericTag(self) ? toChannel(fromEffect(self)) : self.channel;
/** @internal */
exports.toChannel = toChannel;
const unwrap = effect => new SinkImpl(channel.unwrap(Effect.map(sink => toChannel(sink))(effect)));
/** @internal */
exports.unwrap = unwrap;
const unwrapScoped = effect => {
  return new SinkImpl(channel.unwrapScoped(Effect.map(sink => toChannel(sink))(effect)));
};
/** @internal */
exports.unwrapScoped = unwrapScoped;
const withDuration = self => summarized(Clock.currentTimeMillis(), (start, end) => Duration.millis(end - start))(self);
/** @internal */
exports.withDuration = withDuration;
const zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (z, z2) => [z, z2])(self));
/** @internal */
exports.zip = zip;
const zipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (z, _) => z)(self));
/** @internal */
exports.zipLeft = zipLeft;
const zipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (_, z2) => z2)(self));
/** @internal */
exports.zipRight = zipRight;
const zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => flatMap(z => map(z2 => f(z, z2))(that))(self));
/** @internal */
exports.zipWith = zipWith;
const zipPar = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithPar(that, (z, z2) => [z, z2])(self));
/** @internal */
exports.zipPar = zipPar;
const zipParLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithPar(that, (z, _) => z)(self));
/** @internal */
exports.zipParLeft = zipParLeft;
const zipParRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithPar(that, (_, z2) => z2)(self));
/** @internal */
exports.zipParRight = zipParRight;
const zipWithPar = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {
  return raceWith(that, Exit.match(cause => mergeDecision.Done(Effect.failCause(cause)), leftZ => mergeDecision.Await(Exit.match(Effect.failCause, rightZ => Effect.succeed(f(leftZ, rightZ))))), Exit.match(cause => mergeDecision.Done(Effect.failCause(cause)), rightZ => mergeDecision.Await(Exit.match(Effect.failCause, leftZ => Effect.succeed(f(leftZ, rightZ))))))(self);
});
// Circular with Channel
/** @internal */
exports.zipWithPar = zipWithPar;
const channelToSink = self => new SinkImpl(self);
exports.channelToSink = channelToSink;
//# sourceMappingURL=sink.js.map