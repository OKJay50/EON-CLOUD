"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapEffectParByKeyBuffer = exports.mapEffectParByKey = exports.make = exports.groupByKeyBuffer = exports.groupByKey = exports.groupByIterable = exports.groupByBuffer = exports.groupBy = exports.first = exports.filter = exports.evaluateBuffer = exports.evaluate = exports.GroupByTypeId = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Deferred"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Exit"));
var Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Queue"));
var Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Ref"));
var channel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel"));
var channelExecutor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/channelExecutor"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/core"));
var stream = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream"));
var take = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/take"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a;
/** @internal */
const GroupBySymbolKey = "@effect/stream/GroupBy";
/** @internal */
const GroupByTypeId = /*#__PURE__*/Symbol.for(GroupBySymbolKey);
/** @internal */
exports.GroupByTypeId = GroupByTypeId;
const groupByVariance = {
  _R: _ => _,
  _E: _ => _,
  _K: _ => _,
  _V: _ => _
};
/** @internal */
const evaluate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => evaluateBuffer(self, f, 16));
/** @internal */
exports.evaluate = evaluate;
const evaluateBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, f, bufferSize) => stream.flatMapParBuffer(self.grouped, Number.POSITIVE_INFINITY, bufferSize, ([key, queue]) => f(key, stream.flattenTake(stream.fromQueueWithShutdown(queue)))));
/** @internal */
exports.evaluateBuffer = evaluateBuffer;
const filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => make(stream.filterEffect(tuple => {
  if (predicate(tuple[0])) {
    return Effect.as(true)(Effect.succeed(tuple));
  }
  return Effect.as(false)(Queue.shutdown(tuple[1]));
})(self.grouped)));
/** @internal */
exports.filter = filter;
const first = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => make(stream.map(tuple => tuple[0])(stream.filterEffect(tuple => {
  const index = tuple[1];
  const queue = tuple[0][1];
  if (index < n) {
    return Effect.as(true)(Effect.succeed(tuple));
  }
  return Effect.as(false)(Queue.shutdown(queue));
})(stream.zipWithIndex(self.grouped)))));
/** @internal */
exports.first = first;
const make = grouped => ({
  [GroupByTypeId]: groupByVariance,
  grouped
});
// Circular with Stream
/** @internal */
exports.make = make;
const groupBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => groupByBuffer(self, f, 16));
/** @internal */
exports.groupBy = groupBy;
const groupByBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, f, bufferSize) => make(stream.unwrapScoped(Effect.gen(function* ($) {
  const decider = yield* $(Deferred.make());
  const output = yield* $(Effect.acquireRelease(Queue.bounded(bufferSize), queue => Queue.shutdown(queue)));
  const ref = yield* $(Ref.make(new Map()));
  const add = yield* $(stream.distributedWithDynamicCallback(bufferSize, ([key, value]) => Effect.flatMap(f => f(key, value))(Deferred.await(decider)), exit => Queue.offer(output, exit))(stream.mapEffect(self, f)));
  yield* $(Deferred.succeed(decider, (key, _) => Effect.flatMap(Option.match(() => Effect.flatMap(([index, queue]) => Effect.zipRight(Effect.as(n => n === index)(Queue.offer(output, Exit.succeed([key, mapDequeue(queue, exit => new take.TakeImpl(Exit.map(tuple => Chunk.of(tuple[1]))(exit)))]))))(Ref.update(ref, map => map.set(key, index))))(add), index => Effect.succeed(n => n === index)))(Effect.map(map => Option.fromNullable(map.get(key)))(Ref.get(ref)))));
  return stream.flattenExitOption(stream.fromQueueWithShutdown(output));
}))));
exports.groupByBuffer = groupByBuffer;
const mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);
class MapDequeue {
  constructor(dequeue, f) {
    this.dequeue = dequeue;
    this.f = f;
    this[_a] = {
      _Out: _ => _
    };
  }
  capacity() {
    return Queue.capacity(this.dequeue);
  }
  size() {
    return Queue.size(this.dequeue);
  }
  awaitShutdown() {
    return Queue.awaitShutdown(this.dequeue);
  }
  isShutdown() {
    return Queue.isShutdown(this.dequeue);
  }
  shutdown() {
    return Queue.shutdown(this.dequeue);
  }
  isFull() {
    return Queue.isFull(this.dequeue);
  }
  isEmpty() {
    return Queue.isEmpty(this.dequeue);
  }
  take() {
    return Effect.map(a => this.f(a))(Queue.take(this.dequeue));
  }
  takeAll() {
    return Effect.map(Chunk.map(a => this.f(a)))(Queue.takeAll(this.dequeue));
  }
  takeUpTo(max) {
    return Effect.map(Chunk.map(a => this.f(a)))(Queue.takeUpTo(this.dequeue, max));
  }
  takeBetween(min, max) {
    return Effect.map(Chunk.map(a => this.f(a)))(Queue.takeBetween(this.dequeue, min, max));
  }
  takeN(n) {
    return Effect.map(Chunk.map(a => this.f(a)))(Queue.takeN(this.dequeue, n));
  }
  poll() {
    return Effect.map(Option.map(a => this.f(a)))(Queue.poll(this.dequeue));
  }
}
_a = Queue.DequeueTypeId;
/** @internal */
const groupByKey = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => groupByKeyBuffer(self, f, 16));
/** @internal */
exports.groupByKey = groupByKey;
const groupByKeyBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, f, bufferSize) => {
  const loop = (map, outerQueue) => core.readWithCause(input => core.flatMap(() => loop(map, outerQueue))(core.fromEffect(Effect.forEachDiscard(([key, values]) => {
    const innerQueue = map.get(key);
    if (innerQueue === undefined) {
      return Effect.flatMap(innerQueue => Effect.zipRight(Effect.catchSomeCause(cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.unit()) : Option.none())(Queue.offer(innerQueue, take.chunk(values))))(Effect.zipRight(Queue.offer(outerQueue, take.of([key, innerQueue])))(Effect.sync(() => {
        map.set(key, innerQueue);
      }))))(Queue.bounded(bufferSize));
    }
    return Effect.catchSomeCause(cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.unit()) : Option.none())(Queue.offer(innerQueue, take.chunk(values)));
  })(groupByIterable(f)(input)))), cause => core.fromEffect(Queue.offer(outerQueue, take.failCause(cause))), () => core.fromEffect(Effect.zipRight(Queue.offer(outerQueue, take.end))(Effect.forEachDiscard(([_, innerQueue]) => Effect.catchSomeCause(cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.unit()) : Option.none())(Queue.offer(innerQueue, take.end)))(map.entries()))));
  return make(stream.unwrapScoped(Effect.flatMap(map => Effect.flatMap(queue => Effect.as(stream.flattenTake(stream.fromQueueWithShutdown(queue)))(Effect.forkScoped(channelExecutor.runScoped(channel.drain(core.pipeTo(loop(map, queue))(stream.toChannel(self)))))))(Effect.acquireRelease(Queue.unbounded(), queue => Queue.shutdown(queue))))(Effect.sync(() => new Map()))));
});
/** @internal */
exports.groupByKeyBuffer = groupByKeyBuffer;
const mapEffectParByKey = /*#__PURE__*/(0, _Function.dual)(3, (self, keyBy, f) => mapEffectParByKeyBuffer(self, keyBy, 16, f));
/** @internal */
exports.mapEffectParByKey = mapEffectParByKey;
const mapEffectParByKeyBuffer = /*#__PURE__*/(0, _Function.dual)(4, (self, keyBy, bufferSize, f) => evaluate((_, s) => stream.mapEffect(f)(s))(groupByKeyBuffer(self, keyBy, bufferSize)));
/**
 * A variant of `groupBy` that retains the insertion order of keys.
 *
 * @internal
 */
exports.mapEffectParByKeyBuffer = mapEffectParByKeyBuffer;
const groupByIterable = /*#__PURE__*/(0, _Function.dual)(2, (iterable, f) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map = new Map();
  let next;
  while ((next = iterator.next()) && !next.done) {
    const value = next.value;
    const key = f(value);
    if (map.has(key)) {
      const innerBuilder = map.get(key);
      innerBuilder.push(value);
    } else {
      const innerBuilder = [value];
      builder.push([key, innerBuilder]);
      map.set(key, innerBuilder);
    }
  }
  return Chunk.unsafeFromArray(builder.map(tuple => [tuple[0], Chunk.unsafeFromArray(tuple[1])]));
});
exports.groupByIterable = groupByIterable;
//# sourceMappingURL=groupBy.js.map