import * as Chunk from "@effect/data/Chunk";
import type * as Context from "@effect/data/Context";
import * as Debug from "@effect/data/Debug";
import * as Option from "@effect/data/Option";
import * as Cause from "@effect/io/Cause";
import * as Effect from "@effect/io/Effect";
import * as Exit from "@effect/io/Exit";
import type * as Channel from "@effect/stream/Channel";
import type * as ChildExecutorDecision from "@effect/stream/Channel/ChildExecutorDecision";
import type * as UpstreamPullStrategy from "@effect/stream/Channel/UpstreamPullStrategy";
import * as ChannelState from "@effect/stream/internal/channel/channelState";
import * as Continuation from "@effect/stream/internal/channel/continuation";
import * as Subexecutor from "@effect/stream/internal/channel/subexecutor";
import * as core from "@effect/stream/internal/core";
export type ErasedChannel<R> = Channel.Channel<R, unknown, unknown, unknown, unknown, unknown, unknown>;
export declare class ChannelExecutor<Env, InErr, InElem, InDone, OutErr, OutElem, OutDone> {
    private _activeSubexecutor;
    private _cancelled;
    private _closeLastSubstream;
    private _currentChannel;
    private _done;
    private _doneStack;
    private _emitted;
    private _traceStack;
    private _executeCloseLastSubstream;
    private _input;
    private _inProgressFinalizer;
    private _providedEnv;
    constructor(initialChannel: Channel.Channel<Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>, providedEnv: Context.Context<unknown> | undefined, executeCloseLastSubstream: (effect: Effect.Effect<Env, never, unknown>) => Effect.Effect<Env, never, unknown>);
    run(): ChannelState.ChannelState<Env, unknown>;
    stackToLines(): Chunk.Chunk<Debug.SourceLocation>;
    getDone(): Exit.Exit<OutErr, OutDone>;
    getEmit(): OutElem;
    cancelWith(exit: Exit.Exit<OutErr, OutDone>): void;
    clearInProgressFinalizer(): void;
    storeInProgressFinalizer(finalizer: Effect.Effect<Env, never, unknown> | undefined): void;
    popAllFinalizers(exit: Exit.Exit<unknown, unknown>): Effect.Effect<Env, never, unknown>;
    popNextFinalizers(): Array<Continuation.ContinuationFinalizer<Env, unknown, unknown>>;
    restorePipe(exit: Exit.Exit<unknown, unknown>, prev: ErasedExecutor<Env> | undefined): Effect.Effect<Env, never, unknown> | undefined;
    close(exit: Exit.Exit<unknown, unknown>): Effect.Effect<Env, never, unknown> | undefined;
    doneSucceed(value: unknown): ChannelState.ChannelState<Env, unknown> | undefined;
    annotate<E>(_cause: Cause.Cause<E>): Cause.Cause<E>;
    doneHalt(cause: Cause.Cause<unknown>): ChannelState.ChannelState<Env, unknown> | undefined;
    processCancellation(): ChannelState.ChannelState<Env, unknown>;
    runBracketOut(bracketOut: core.BracketOut): ChannelState.ChannelState<Env, unknown>;
    provide(effect: Effect.Effect<unknown, unknown, unknown>): Effect.Effect<unknown, unknown, unknown>;
    runEnsuring(ensuring: core.Ensuring): void;
    addFinalizer(f: ErasedFinalizer<Env>): void;
    runSubexecutor(): ChannelState.ChannelState<Env, unknown> | undefined;
    replaceSubexecutor(nextSubExec: Subexecutor.Subexecutor<Env>): void;
    finishWithExit(exit: Exit.Exit<unknown, unknown>): Effect.Effect<Env, unknown, unknown>;
    finishSubexecutorWithCloseEffect(subexecutorDone: Exit.Exit<unknown, unknown>, ...closeFuncs: Array<(exit: Exit.Exit<unknown, unknown>) => Effect.Effect<Env, never, unknown> | undefined>): ChannelState.ChannelState<Env, unknown> | undefined;
    applyUpstreamPullStrategy(upstreamFinished: boolean, queue: ReadonlyArray<Subexecutor.PullFromChild<Env> | undefined>, strategy: UpstreamPullStrategy.UpstreamPullStrategy<unknown>): readonly [Option.Option<unknown>, ReadonlyArray<Subexecutor.PullFromChild<Env> | undefined>];
    pullFromChild(childExecutor: ErasedExecutor<Env>, parentSubexecutor: Subexecutor.Subexecutor<Env>, onEmitted: (emitted: unknown) => ChildExecutorDecision.ChildExecutorDecision, subexecutor: Subexecutor.PullFromChild<Env>): ChannelState.ChannelState<Env, unknown> | undefined;
    finishWithDoneValue(childExecutor: ErasedExecutor<Env>, parentSubexecutor: Subexecutor.Subexecutor<Env>, doneValue: unknown): void;
    handleSubexecutorFailure(childExecutor: ErasedExecutor<Env>, parentSubexecutor: Subexecutor.Subexecutor<Env>, cause: Cause.Cause<unknown>): ChannelState.ChannelState<Env, unknown> | undefined;
    pullFromUpstream(subexecutor: Subexecutor.PullFromUpstream<Env>): ChannelState.ChannelState<Env, unknown> | undefined;
    performPullFromUpstream(subexecutor: Subexecutor.PullFromUpstream<Env>): ChannelState.ChannelState<Env, unknown> | undefined;
    drainChildExecutors(subexecutor: Subexecutor.DrainChildExecutors<Env>): ChannelState.ChannelState<Env, unknown> | undefined;
}
//# sourceMappingURL=channelExecutor.d.ts.map