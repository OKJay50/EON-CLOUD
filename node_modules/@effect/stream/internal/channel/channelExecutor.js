"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runScoped = exports.run = exports.readUpstream = exports.ChannelExecutor = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Debug"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var MRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/MutableRef"));
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Deferred"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var ExecutionStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/ExecutionStrategy"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Exit"));
var Fiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Fiber"));
var Scope = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Scope"));
var ChannelState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/channelState"));
var Continuation = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/continuation"));
var Subexecutor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/subexecutor"));
var upstreamPullRequest = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/upstreamPullRequest"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/core"));
var ChannelOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/channel"));
var ChannelStateOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/channelState"));
var ChildExecutorDecisionOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/childExecutorDecision"));
var ContinuationOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/continuation"));
var UpstreamPullStrategyOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/upstreamPullStrategy"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class ChannelExecutor {
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._activeSubexecutor = undefined;
    this._cancelled = undefined;
    this._closeLastSubstream = undefined;
    this._done = undefined;
    this._doneStack = [];
    this._emitted = undefined;
    this._traceStack = [];
    this._input = undefined;
    this._inProgressFinalizer = undefined;
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = undefined;
    while (result === undefined) {
      if (this._cancelled !== undefined) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== undefined) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === undefined) {
            result = ChannelState.Done();
          } else {
            switch (this._currentChannel._tag) {
              case ChannelOpCodes.OP_BRACKET_OUT:
                {
                  result = this.runBracketOut(this._currentChannel);
                  break;
                }
              case ChannelOpCodes.OP_BRIDGE:
                {
                  const bridgeInput = this._currentChannel.input;
                  // PipeTo(left, Bridge(queue, channel))
                  // In a fiber: repeatedly run left and push its outputs to the queue
                  // Add a finalizer to interrupt the fiber and close the executor
                  this._currentChannel = this._currentChannel.channel;
                  if (this._input !== undefined) {
                    const inputExecutor = this._input;
                    this._input = undefined;
                    const drainer = () => Effect.flatMap(bridgeInput.awaitRead(), () => Effect.suspend(() => {
                      const state = inputExecutor.run();
                      switch (state._tag) {
                        case ChannelStateOpCodes.OP_DONE:
                          {
                            return Exit.match(inputExecutor.getDone(), cause => bridgeInput.error(cause), value => bridgeInput.done(value));
                          }
                        case ChannelStateOpCodes.OP_EMIT:
                          {
                            return Effect.flatMap(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                          }
                        case ChannelStateOpCodes.OP_FROM_EFFECT:
                          {
                            return Effect.matchCauseEffect(state.effect, cause => bridgeInput.error(cause), () => drainer());
                          }
                        case ChannelStateOpCodes.OP_READ:
                          {
                            return readUpstream(state, () => drainer(), cause => bridgeInput.error(cause));
                          }
                      }
                    }));
                    result = ChannelState.FromEffect(Effect.flatMap(Effect.forkDaemon(drainer()), fiber => Effect.sync(() => this.addFinalizer(exit => Effect.flatMap(Fiber.interrupt(fiber), () => Effect.suspend(() => {
                      const effect = this.restorePipe(exit, inputExecutor);
                      return effect !== undefined ? effect : Effect.unit();
                    }))))));
                  }
                  break;
                }
              case ChannelOpCodes.OP_CONCAT_ALL:
                {
                  const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, effect => Effect.sync(() => {
                    const prevLastClose = this._closeLastSubstream === undefined ? Effect.unit() : this._closeLastSubstream;
                    this._closeLastSubstream = Effect.zipRight(effect)(prevLastClose);
                  }));
                  executor._input = this._input;
                  const channel = this._currentChannel;
                  this._activeSubexecutor = new Subexecutor.PullFromUpstream(executor, value => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), request => channel.onPull(request), value => channel.onEmit(value));
                  this._closeLastSubstream = undefined;
                  this._currentChannel = undefined;
                  break;
                }
              case ChannelOpCodes.OP_EMIT:
                {
                  this._emitted = this._currentChannel.out;
                  this._currentChannel = this._activeSubexecutor !== undefined ? undefined : core.unit();
                  result = ChannelState.Emit();
                  break;
                }
              case ChannelOpCodes.OP_ENSURING:
                {
                  this.runEnsuring(this._currentChannel);
                  break;
                }
              case ChannelOpCodes.OP_FAIL:
                {
                  result = this.doneHalt(this._currentChannel.error());
                  break;
                }
              case "Tag":
                {
                  this._currentChannel = core.fromEffect(this._currentChannel);
                  break;
                }
              case ChannelOpCodes.OP_FOLD:
                {
                  this._doneStack.push(this._currentChannel.k);
                  this._currentChannel = this._currentChannel.channel;
                  break;
                }
              case ChannelOpCodes.OP_FROM_EFFECT:
                {
                  const effect = this._providedEnv === undefined ? this._currentChannel.effect() : Effect.provideContext(this._providedEnv)(this._currentChannel.effect());
                  result = ChannelState.FromEffect(Effect.matchCauseEffect(cause => {
                    const state = this.doneHalt(cause);
                    return state !== undefined && ChannelState.isFromEffect(state) ? state.effect : Effect.unit();
                  }, value => {
                    const state = this.doneSucceed(value);
                    return state !== undefined && ChannelState.isFromEffect(state) ? state.effect : Effect.unit();
                  })(effect));
                  break;
                }
              case ChannelOpCodes.OP_PIPE_TO:
                {
                  const previousInput = this._input;
                  const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, effect => this._executeCloseLastSubstream(effect));
                  leftExec._input = previousInput;
                  this._input = leftExec;
                  this.addFinalizer(exit => {
                    const effect = this.restorePipe(exit, previousInput);
                    return effect !== undefined ? effect : Effect.unit();
                  });
                  this._currentChannel = this._currentChannel.right();
                  break;
                }
              case ChannelOpCodes.OP_PROVIDE:
                {
                  const previousEnv = this._providedEnv;
                  this._providedEnv = this._currentChannel.context();
                  this._currentChannel = this._currentChannel.inner;
                  this.addFinalizer(() => Effect.sync(() => {
                    this._providedEnv = previousEnv;
                  }));
                  break;
                }
              case ChannelOpCodes.OP_READ:
                {
                  const read = this._currentChannel;
                  result = ChannelState.Read(this._input, _Function.identity, emitted => {
                    this._currentChannel = read.more(emitted);
                    return undefined;
                  }, exit => {
                    const onExit = exit => {
                      return read.done.onExit(exit);
                    };
                    this._currentChannel = onExit(exit);
                    return undefined;
                  });
                  break;
                }
              case ChannelOpCodes.OP_SUCCEED:
                {
                  result = this.doneSucceed(this._currentChannel.evaluate());
                  break;
                }
              case ChannelOpCodes.OP_SUCCEED_NOW:
                {
                  result = this.doneSucceed(this._currentChannel.terminal);
                  break;
                }
              case ChannelOpCodes.OP_SUSPEND:
                {
                  this._currentChannel = this._currentChannel.channel();
                  break;
                }
              case ChannelOpCodes.OP_TRACED:
                {
                  this._traceStack.push(this._currentChannel.trace);
                  this.addFinalizer(() => Effect.sync(() => {
                    this._traceStack.pop();
                  }));
                  this._currentChannel = this._currentChannel.channel;
                  break;
                }
              default:
                {
                  // @ts-expect-error
                  this._currentChannel._tag;
                }
            }
          }
        } catch (error) {
          this._currentChannel = core.failCause(Cause.die(error));
        }
      }
    }
    return result;
  }
  stackToLines() {
    if (this._traceStack.length === 0) {
      return Chunk.empty();
    }
    const lines = [];
    let current = this._traceStack.length - 1;
    while (current >= 0 && lines.length < Debug.runtimeDebug.traceStackLimit) {
      const value = this._traceStack[current];
      lines.push(value);
      current = current - 1;
    }
    return Chunk.unsafeFromArray(lines);
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit) {
    this._cancelled = exit;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = undefined;
  }
  storeInProgressFinalizer(finalizer) {
    this._inProgressFinalizer = finalizer;
  }
  popAllFinalizers(exit) {
    return Debug.untraced(() => {
      const finalizers = [];
      let next = this._doneStack.pop();
      while (next) {
        if (next._tag === "ContinuationFinalizer") {
          finalizers.push(next.finalizer);
        }
        next = this._doneStack.pop();
      }
      const effect = finalizers.length === 0 ? Effect.unit() : runFinalizers(finalizers, exit);
      this.storeInProgressFinalizer(effect);
      return effect;
    });
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === ContinuationOpCodes.OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit, prev) {
    return Debug.untraced(() => {
      const currInput = this._input;
      this._input = prev;
      if (currInput !== undefined) {
        const effect = currInput.close(exit);
        return effect;
      }
      return Effect.unit();
    });
  }
  close(exit) {
    return Debug.untraced(() => {
      let runInProgressFinalizers = undefined;
      const finalizer = this._inProgressFinalizer;
      if (finalizer !== undefined) {
        runInProgressFinalizers = Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer()))(finalizer);
      }
      let closeSelf = undefined;
      const selfFinalizers = this.popAllFinalizers(exit);
      if (selfFinalizers !== undefined) {
        closeSelf = Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer()))(selfFinalizers);
      }
      const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit);
      if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {
        return undefined;
      }
      return Effect.flatMap(Effect.done)(Effect.uninterruptible(Effect.map(([[exit1, exit2], exit3]) => Exit.zipRight(exit3)(Exit.zipRight(exit2)(exit1)))(Effect.zip(Effect.exit(ifNotNull(closeSelf)))(Effect.zip(Effect.exit(ifNotNull(runInProgressFinalizers)))(Effect.exit(ifNotNull(closeSubexecutors)))))));
    });
  }
  doneSucceed(value) {
    if (this._doneStack.length === 0) {
      this._done = Exit.succeed(value);
      this._currentChannel = undefined;
      return ChannelState.Done();
    }
    const head = this._doneStack[this._doneStack.length - 1];
    if (head._tag === ContinuationOpCodes.OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head.onSuccess(value);
      return undefined;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = Exit.succeed(value);
      this._currentChannel = undefined;
      return ChannelState.Done();
    }
    const finalizerEffect = runFinalizers(finalizers.map(f => f.finalizer), Exit.succeed(value));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect = Effect.flatMap(() => Effect.sync(() => this.doneSucceed(value)))(Effect.uninterruptible(Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer()))(finalizerEffect)));
    return ChannelState.FromEffect(effect);
  }
  annotate(_cause) {
    let cause = _cause;
    if (Cause.isAnnotatedType(cause) && Cause.isStackAnnotation(cause.annotation)) {
      const stack = cause.annotation.stack;
      const currentStack = this.stackToLines();
      cause = Cause.annotated(cause.cause, new Cause.StackAnnotation(Chunk.take(Debug.runtimeDebug.traceStackLimit)(Chunk.dedupeAdjacent(stack.length === 0 ? currentStack : currentStack.length === 0 ? stack : Chunk.unsafeLast(stack) === Chunk.unsafeLast(currentStack) ? stack : Chunk.concat(currentStack)(stack))), cause.annotation.seq));
    } else {
      cause = Cause.annotated(cause, new Cause.StackAnnotation(this.stackToLines(), MRef.getAndIncrement(Cause.globalErrorSeq)));
    }
    return cause;
  }
  doneHalt(cause) {
    if (this._doneStack.length === 0) {
      this._done = Exit.failCause(cause);
      this._currentChannel = undefined;
      return ChannelState.Done();
    }
    const head = this._doneStack[this._doneStack.length - 1];
    if (head._tag === ContinuationOpCodes.OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head.onHalt(cause);
      return undefined;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = Exit.failCause(cause);
      this._currentChannel = undefined;
      return ChannelState.Done();
    }
    const finalizerEffect = runFinalizers(finalizers.map(f => f.finalizer), Exit.failCause(cause));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect = Effect.flatMap(() => Effect.sync(() => this.doneHalt(cause)))(Effect.uninterruptible(Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer()))(finalizerEffect)));
    return ChannelState.FromEffect(effect);
  }
  processCancellation() {
    this._currentChannel = undefined;
    this._done = this._cancelled;
    this._cancelled = undefined;
    return ChannelState.Done();
  }
  runBracketOut(bracketOut) {
    const effect = Effect.uninterruptible(Effect.matchCauseEffect(cause => Effect.sync(() => {
      this._currentChannel = core.failCause(cause);
    }), out => Effect.sync(() => {
      this.addFinalizer(exit => this.provide(bracketOut.finalizer(out, exit)));
      this._currentChannel = core.write(out);
    }))(this.provide(bracketOut.acquire())));
    return ChannelState.FromEffect(effect);
  }
  provide(effect) {
    if (this._providedEnv === undefined) {
      return effect;
    }
    return Effect.provideContext(this._providedEnv)(effect);
  }
  runEnsuring(ensuring) {
    this.addFinalizer(ensuring.finalizer);
    this._currentChannel = ensuring.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new Continuation.ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case Subexecutor.OP_PULL_FROM_CHILD:
        {
          return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
        }
      case Subexecutor.OP_PULL_FROM_UPSTREAM:
        {
          return this.pullFromUpstream(subexecutor);
        }
      case Subexecutor.OP_DRAIN_CHILD_EXECUTORS:
        {
          return this.drainChildExecutors(subexecutor);
        }
      case Subexecutor.OP_EMIT:
        {
          this._emitted = subexecutor.value;
          this._activeSubexecutor = subexecutor.next;
          return ChannelState.Emit();
        }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = undefined;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit) {
    return Debug.untraced(() => {
      const state = Exit.match(cause => this.doneHalt(cause), value => this.doneSucceed(value))(exit);
      this._activeSubexecutor = undefined;
      return state === undefined ? Effect.unit() : ChannelState.effect(state);
    });
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => Effect.forEachDiscard(closeFunc => Effect.flatMap(closeEffect => closeEffect !== undefined ? closeEffect : Effect.unit())(Effect.sync(() => closeFunc(subexecutorDone))))(closeFuncs));
    const state = Exit.match(cause => this.doneHalt(cause), value => this.doneSucceed(value))(subexecutorDone);
    this._activeSubexecutor = undefined;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case UpstreamPullStrategyOpCodes.OP_PULL_AFTER_NEXT:
        {
          const shouldPrepend = !upstreamFinished || queue.some(subexecutor => subexecutor !== undefined);
          return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];
        }
      case UpstreamPullStrategyOpCodes.OP_PULL_AFTER_ALL_ENQUEUED:
        {
          const shouldEnqueue = !upstreamFinished || queue.some(subexecutor => subexecutor !== undefined);
          return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];
        }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return ChannelState.Read(childExecutor, _Function.identity, emitted => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case ChildExecutorDecisionOpCodes.OP_CONTINUE:
          {
            break;
          }
        case ChildExecutorDecisionOpCodes.OP_CLOSE:
          {
            this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
            break;
          }
        case ChildExecutorDecisionOpCodes.OP_YIELD:
          {
            const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
            this.replaceSubexecutor(modifiedParent);
            break;
          }
      }
      this._activeSubexecutor = new Subexecutor.Emit(emitted, this._activeSubexecutor);
      return undefined;
    }, Exit.match(cause => {
      const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause);
      return state === undefined ? undefined : ChannelState.effectOrUndefinedIgnored(state);
    }, doneValue => {
      this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
      return undefined;
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case Subexecutor.OP_PULL_FROM_UPSTREAM:
        {
          const modifiedParent = new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
          this._closeLastSubstream = childExecutor.close(Exit.succeed(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      case Subexecutor.OP_DRAIN_CHILD_EXECUTORS:
        {
          const modifiedParent = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
          this._closeLastSubstream = childExecutor.close(Exit.succeed(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      default:
        {
          break;
        }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause) {
    return this.finishSubexecutorWithCloseEffect(Exit.failCause(cause), exit => parentSubexecutor.close(exit), exit => childExecutor.close(exit));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === undefined) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new Subexecutor.PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return undefined;
  }
  performPullFromUpstream(subexecutor) {
    return ChannelState.Read(subexecutor.upstreamExecutor, effect => {
      const closeLastSubstream = this._closeLastSubstream === undefined ? Effect.unit() : this._closeLastSubstream;
      this._closeLastSubstream = undefined;
      return Effect.zipRight(effect)(this._executeCloseLastSubstream(closeLastSubstream));
    }, emitted => {
      if (this._closeLastSubstream !== undefined) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = undefined;
        return Effect.map(() => {
          const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor._input = this._input;
          const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(upstreamPullRequest.Pulled(emitted)));
          this._activeSubexecutor = new Subexecutor.PullFromChild(childExecutor, new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (Option.isSome(emitSeparator)) {
            this._activeSubexecutor = new Subexecutor.Emit(emitSeparator.value, this._activeSubexecutor);
          }
          return undefined;
        })(this._executeCloseLastSubstream(closeLastSubstream));
      }
      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(upstreamPullRequest.Pulled(emitted)));
      this._activeSubexecutor = new Subexecutor.PullFromChild(childExecutor, new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (Option.isSome(emitSeparator)) {
        this._activeSubexecutor = new Subexecutor.Emit(emitSeparator.value, this._activeSubexecutor);
      }
      return undefined;
    }, exit => {
      if (subexecutor.activeChildExecutors.some(subexecutor => subexecutor !== undefined)) {
        const drain = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== undefined) {
          const closeLastSubstream = this._closeLastSubstream;
          this._closeLastSubstream = undefined;
          return Effect.map(() => this.replaceSubexecutor(drain))(this._executeCloseLastSubstream(closeLastSubstream));
        }
        this.replaceSubexecutor(drain);
        return undefined;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(Exit.map(a => subexecutor.combineWithChildResult(subexecutor.lastDone, a))(exit), () => closeLastSubstream, exit => subexecutor.upstreamExecutor.close(exit));
      return state === undefined ? undefined :
      // NOTE: assuming finalizers cannot fail
      ChannelState.effectOrUndefinedIgnored(state);
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== undefined) {
        this.addFinalizer(() => Effect.succeed(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, exit => subexecutor.upstreamExecutor.close(exit));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === undefined) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(upstreamPullRequest.NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));
      this.replaceSubexecutor(new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (Option.isSome(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return ChannelState.Emit();
      }
      return undefined;
    }
    const parentSubexecutor = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new Subexecutor.PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return undefined;
  }
}
exports.ChannelExecutor = ChannelExecutor;
const ifNotNull = /*#__PURE__*/Debug.untracedMethod(() => effect => effect !== undefined ? effect : Effect.unit());
const runFinalizers = /*#__PURE__*/Debug.untracedMethod(() => (finalizers, exit) => {
  return Effect.flatMap(exit => Effect.done(exit))(Effect.map(exits => Option.getOrElse(() => Exit.unit())(Exit.collectAll(exits)))(Effect.forEach(finalizers, fin => Effect.exit(fin(exit)))));
});
/**
 * @internal
 */
const readUpstream = /*#__PURE__*/Debug.methodWithTrace(trace => (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read = () => {
    const current = readStack.pop();
    if (current === undefined || current.upstream === undefined) {
      return Effect.dieMessage("Unexpected end of input for channel execution");
    }
    const state = current.upstream.run();
    switch (state._tag) {
      case ChannelStateOpCodes.OP_EMIT:
        {
          const emitEffect = current.onEmit(current.upstream.getEmit());
          if (readStack.length === 0) {
            if (emitEffect === undefined) {
              return Effect.suspend(onSuccess);
            }
            return Effect.matchCauseEffect(onFailure, onSuccess)(emitEffect).traced(trace);
          }
          if (emitEffect === undefined) {
            return Effect.suspend(() => read()).traced(trace);
          }
          return Effect.matchCauseEffect(onFailure, () => read())(emitEffect).traced(trace);
        }
      case ChannelStateOpCodes.OP_DONE:
        {
          const doneEffect = current.onDone(current.upstream.getDone());
          if (readStack.length === 0) {
            if (doneEffect === undefined) {
              return Effect.suspend(onSuccess).traced(trace);
            }
            return Effect.matchCauseEffect(onFailure, () => onSuccess())(doneEffect).traced(trace);
          }
          if (doneEffect === undefined) {
            return Effect.suspend(() => read()).traced(trace);
          }
          return Effect.matchCauseEffect(onFailure, () => read())(doneEffect).traced(trace);
        }
      case ChannelStateOpCodes.OP_FROM_EFFECT:
        {
          readStack.push(current);
          return Effect.matchCauseEffect(onFailure, () => read())(Effect.catchAllCause(cause => Effect.suspend(() => {
            const doneEffect = current.onDone(Exit.failCause(cause));
            return doneEffect === undefined ? Effect.unit() : doneEffect;
          }))(current.onEffect(state.effect))).traced(trace);
        }
      case ChannelStateOpCodes.OP_READ:
        {
          readStack.push(current);
          readStack.push(state);
          return Effect.suspend(() => read()).traced(trace);
        }
    }
  };
  return read();
});
/** @internal */
exports.readUpstream = readUpstream;
const run = /*#__PURE__*/Debug.methodWithTrace(trace => self => Effect.scoped(runScoped(self)).traced(trace));
/** @internal */
exports.run = run;
const runScoped = self => {
  const run = (deferred, scope) => Effect.acquireUseRelease(Effect.sync(() => new ChannelExecutor(self, void 0, _Function.identity)), exec => Effect.suspend(() => Effect.zipLeft(Effect.never())(Effect.zipRight(Deferred.await(deferred))(Effect.intoDeferred(deferred)(runScopedInterpret(exec.run(), exec))))), (exec, exit) => {
    const finalize = exec.close(exit);
    if (finalize === undefined) {
      return Effect.unit();
    }
    return Effect.tapErrorCause(finalize, cause => Scope.addFinalizer(scope, Effect.failCause(cause)));
  });
  return Effect.flatMap(Effect.scope(), parent => Effect.flatMap(Scope.fork(parent, ExecutionStrategy.sequential), child => Effect.flatMap(Deferred.make(), deferred => Effect.flatMap(Effect.forkScoped(run(deferred, child)), fiber => Effect.zipLeft(Deferred.await(deferred), Fiber.inheritAll(fiber))))));
};
/** @internal */
exports.runScoped = runScoped;
const runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case ChannelStateOpCodes.OP_FROM_EFFECT:
      {
        return Effect.flatMap(() => runScopedInterpret(exec.run(), exec))(op.effect);
      }
    case ChannelStateOpCodes.OP_EMIT:
      {
        // Can't really happen because Out <:< Nothing. So just skip ahead.
        return runScopedInterpret(exec.run(), exec);
      }
    case ChannelStateOpCodes.OP_DONE:
      {
        return Effect.done(exec.getDone());
      }
    case ChannelStateOpCodes.OP_READ:
      {
        return readUpstream(op, () => runScopedInterpret(exec.run(), exec), Effect.failCause);
      }
  }
};
//# sourceMappingURL=channelExecutor.js.map