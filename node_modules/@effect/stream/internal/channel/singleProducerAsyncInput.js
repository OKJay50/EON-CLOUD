"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = void 0;
var _Debug = /*#__PURE__*/require("@effect/data/Debug");
var Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Deferred"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Exit"));
var Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Ref"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/** @internal */
const OP_STATE_EMPTY = "Empty";
/** @internal */
const OP_STATE_EMIT = "Emit";
/** @internal */
const OP_STATE_ERROR = "Error";
/** @internal */
const OP_STATE_DONE = "Done";
/** @internal */
const stateEmpty = notifyProducer => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
/** @internal */
const stateEmit = notifyConsumers => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
/** @internal */
const stateError = cause => ({
  _tag: OP_STATE_ERROR,
  cause
});
/** @internal */
const stateDone = done => ({
  _tag: OP_STATE_DONE,
  done
});
/** @internal */
class SingleProducerAsyncInputImpl {
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return (0, _Debug.bodyWithTrace)(trace => {
      return Effect.flatten(Ref.modify(this.ref, state => state._tag === OP_STATE_EMPTY ? [Deferred.await(state.notifyProducer), state] : [Effect.unit(), state])).traced(trace);
    });
  }
  close() {
    return (0, _Debug.bodyWithTrace)(trace => {
      return Effect.fiberIdWith(fiberId => this.error(Cause.interrupt(fiberId))).traced(trace);
    });
  }
  done(value) {
    return (0, _Debug.bodyWithTrace)(trace => {
      return Effect.flatten(Ref.modify(this.ref, state => {
        switch (state._tag) {
          case OP_STATE_EMPTY:
            {
              return [Deferred.await(state.notifyProducer), state];
            }
          case OP_STATE_EMIT:
            {
              return [Effect.forEachDiscard(deferred => Deferred.succeed(deferred, Either.left(value)))(state.notifyConsumers), stateDone(value)];
            }
          case OP_STATE_ERROR:
            {
              return [Effect.interrupt(), state];
            }
          case OP_STATE_DONE:
            {
              return [Effect.interrupt(), state];
            }
        }
      })).traced(trace);
    });
  }
  emit(element) {
    return (0, _Debug.bodyWithTrace)(trace => {
      return Effect.flatMap(deferred => Effect.flatten(Ref.modify(this.ref, state => {
        switch (state._tag) {
          case OP_STATE_EMPTY:
            {
              return [Deferred.await(state.notifyProducer), state];
            }
          case OP_STATE_EMIT:
            {
              const notifyConsumer = state.notifyConsumers[0];
              const notifyConsumers = state.notifyConsumers.slice(1);
              if (notifyConsumer !== undefined) {
                return [Deferred.succeed(notifyConsumer, Either.right(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
              }
              throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! Please report an issue at https://github.com/Effect-TS/stream/issues");
            }
          case OP_STATE_ERROR:
            {
              return [Effect.interrupt(), state];
            }
          case OP_STATE_DONE:
            {
              return [Effect.interrupt(), state];
            }
        }
      })))(Deferred.make()).traced(trace);
    });
  }
  error(cause) {
    return (0, _Debug.bodyWithTrace)(trace => {
      return Effect.flatten(Ref.modify(this.ref, state => {
        switch (state._tag) {
          case OP_STATE_EMPTY:
            {
              return [Deferred.await(state.notifyProducer), state];
            }
          case OP_STATE_EMIT:
            {
              return [Effect.forEachDiscard(state.notifyConsumers, deferred => Deferred.failCause(deferred, cause)), stateError(cause)];
            }
          case OP_STATE_ERROR:
            {
              return [Effect.interrupt(), state];
            }
          case OP_STATE_DONE:
            {
              return [Effect.interrupt(), state];
            }
        }
      })).traced(trace);
    });
  }
  take() {
    return (0, _Debug.bodyWithTrace)(trace => {
      return this.takeWith(cause => Exit.failCause(Cause.map(cause, Either.left)), elem => Exit.succeed(elem), done => Exit.fail(Either.right(done))).traced(trace);
    });
  }
  takeWith(onError, onElement, onDone) {
    return (0, _Debug.bodyWithTrace)(trace => {
      return Effect.flatMap(deferred => Effect.flatten(Ref.modify(this.ref, state => {
        switch (state._tag) {
          case OP_STATE_EMPTY:
            {
              return [Effect.zipRight(Deferred.succeed(state.notifyProducer, void 0), Effect.matchCause(Deferred.await(deferred), onError, Either.match(onDone, onElement))), stateEmit([deferred])];
            }
          case OP_STATE_EMIT:
            {
              return [Effect.matchCause(Deferred.await(deferred), onError, Either.match(onDone, onElement)), stateEmit([...state.notifyConsumers, deferred])];
            }
          case OP_STATE_ERROR:
            {
              return [Effect.succeed(onError(state.cause)), state];
            }
          case OP_STATE_DONE:
            {
              return [Effect.succeed(onDone(state.done)), state];
            }
        }
      })))(Deferred.make()).traced(trace);
    });
  }
}
/** @internal */
const make = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => () => Effect.map(ref => new SingleProducerAsyncInputImpl(ref))(Effect.flatMap(deferred => Ref.make(stateEmpty(deferred)))(Deferred.make())).traced(trace));
exports.make = make;
//# sourceMappingURL=singleProducerAsyncInput.js.map