"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PullFromUpstream = exports.PullFromChild = exports.OP_PULL_FROM_UPSTREAM = exports.OP_PULL_FROM_CHILD = exports.OP_EMIT = exports.OP_DRAIN_CHILD_EXECUTORS = exports.Emit = exports.DrainChildExecutors = void 0;
var _Debug = /*#__PURE__*/require("@effect/data/Debug");
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Exit"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/** @internal */
const OP_PULL_FROM_CHILD = "PullFromChild";
/** @internal */
exports.OP_PULL_FROM_CHILD = OP_PULL_FROM_CHILD;
const OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
/** @internal */
exports.OP_PULL_FROM_UPSTREAM = OP_PULL_FROM_UPSTREAM;
const OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
/** @internal */
exports.OP_DRAIN_CHILD_EXECUTORS = OP_DRAIN_CHILD_EXECUTORS;
const OP_EMIT = "Emit";
/**
 * Execute the `childExecutor` and on each emitted value, decide what to do by
 * `onEmit`.
 *
 * @internal
 */
exports.OP_EMIT = OP_EMIT;
class PullFromChild {
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
    this._tag = OP_PULL_FROM_CHILD;
  }
  close(exit) {
    return (0, _Debug.bodyWithTrace)(trace => {
      const fin1 = this.childExecutor.close(exit);
      const fin2 = this.parentSubexecutor.close(exit);
      if (fin1 !== undefined && fin2 !== undefined) {
        return Effect.zipWith(Effect.exit(fin2), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(Effect.exit(fin1)).traced(trace);
      } else if (fin1 !== undefined) {
        return fin1.traced(trace);
      } else if (fin2 !== undefined) {
        return fin2.traced(trace);
      } else {
        return undefined;
      }
    });
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}
/**
 * Execute `upstreamExecutor` and for each emitted element, spawn a child
 * channel and continue with processing it by `PullFromChild`.
 *
 * @internal
 */
exports.PullFromChild = PullFromChild;
class PullFromUpstream {
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
    this._tag = OP_PULL_FROM_UPSTREAM;
  }
  close(exit) {
    return (0, _Debug.bodyWithTrace)(trace => {
      const fin1 = this.upstreamExecutor.close(exit);
      const fins = [...this.activeChildExecutors.map(child => child !== undefined ? child.childExecutor.close(exit) : undefined), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== undefined && next !== undefined) {
          return Effect.zipWith(Effect.exit(next), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(acc);
        } else if (acc !== undefined) {
          return acc;
        } else if (next !== undefined) {
          return Effect.exit(next);
        } else {
          return undefined;
        }
      }, undefined);
      return result === undefined ? result : result.traced(trace);
    });
  }
  enqueuePullFromChild(child) {
    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
}
/**
 * Transformed from `PullFromUpstream` when upstream has finished but there
 * are still active child executors.
 *
 * @internal
 */
exports.PullFromUpstream = PullFromUpstream;
class DrainChildExecutors {
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this._tag = OP_DRAIN_CHILD_EXECUTORS;
  }
  close(exit) {
    return (0, _Debug.bodyWithTrace)(trace => {
      const fin1 = this.upstreamExecutor.close(exit);
      const fins = [...this.activeChildExecutors.map(child => child !== undefined ? child.childExecutor.close(exit) : undefined), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== undefined && next !== undefined) {
          return Effect.zipWith(Effect.exit(next), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(acc);
        } else if (acc !== undefined) {
          return acc;
        } else if (next !== undefined) {
          return Effect.exit(next);
        } else {
          return undefined;
        }
      }, undefined);
      return result === undefined ? result : result.traced(trace);
    });
  }
  enqueuePullFromChild(child) {
    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
}
/** @internal */
exports.DrainChildExecutors = DrainChildExecutors;
class Emit {
  constructor(value, next) {
    this.value = value;
    this.next = next;
    this._tag = OP_EMIT;
  }
  close(exit) {
    return (0, _Debug.bodyWithTrace)(trace => {
      const result = this.next.close(exit);
      return result === undefined ? result : result.traced(trace);
    });
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}
exports.Emit = Emit;
//# sourceMappingURL=subexecutor.js.map