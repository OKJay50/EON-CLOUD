"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zipRight = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeft = exports.zip = exports.writeChunk = exports.writeAll = exports.updateService = exports.unwrapScoped = exports.unwrap = exports.toQueue = exports.toPull = exports.toHub = exports.serviceWithEffect = exports.serviceWithChannel = exports.serviceWith = exports.service = exports.scoped = exports.runDrain = exports.runCollect = exports.run = exports.repeated = exports.read = exports.provideSomeLayer = exports.provideService = exports.provideLayer = exports.pipeToOrFail = exports.orElse = exports.orDieWith = exports.orDie = exports.never = exports.mergeWith = exports.mergeOutWith = exports.mergeOut = exports.mergeMapStrategy = exports.mergeMapBufferStrategy = exports.mergeMapBuffer = exports.mergeMap = exports.mergeAllWith = exports.mergeAllUnboundedWith = exports.mergeAllUnbounded = exports.mergeAll = exports.mapOutEffectPar = exports.mapOutEffect = exports.mapOut = exports.mapErrorCause = exports.mapError = exports.mapEffect = exports.map = exports.isChannelException = exports.interruptWhenDeferred = exports.interruptWhen = exports.identityChannel = exports.fromQueue = exports.fromOption = exports.fromInput = exports.fromHubScoped = exports.fromHub = exports.fromEither = exports.foldChannel = exports.flatten = exports.ensuring = exports.emitCollect = exports.drain = exports.doneCollect = exports.contramapInEffect = exports.contramapIn = exports.contramapErrorEffect = exports.contramapError = exports.contramapEffect = exports.contramapContext = exports.contramap = exports.contextWithEffect = exports.contextWithChannel = exports.contextWith = exports.context = exports.concatOut = exports.concatMap = exports.collect = exports.catchAll = exports.bufferChunk = exports.buffer = exports.asUnit = exports.as = exports.acquireUseRelease = exports.ChannelExceptionTypeId = exports.ChannelException = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Context"));
var Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Debug"));
var Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equal"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Deferred"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Exit"));
var Fiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Fiber"));
var Hub = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Hub"));
var Layer = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Layer"));
var Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Queue"));
var Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Ref"));
var Scope = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Scope"));
var executor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/channelExecutor"));
var mergeDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/mergeDecision"));
var mergeState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/mergeState"));
var _mergeStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/mergeStrategy"));
var singleProducerAsyncInput = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/singleProducerAsyncInput"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/core"));
var ChannelStateOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/channelState"));
var MergeDecisionOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/mergeDecision"));
var MergeStateOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/mergeState"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/** @internal */
const acquireUseRelease = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (acquire, use, release) => core.flatMap(core.fromEffect(Ref.make(() => Effect.unit())), ref => core.ensuringWith(exit => Effect.flatMap(Ref.get(ref), f => f(exit)))(core.flatMap(restore(use))(core.fromEffect(Effect.uninterruptible(Effect.tap(acquire, a => Ref.set(ref, exit => restore(release)(a, exit)))))))).traced(trace));
/** @internal */
exports.acquireUseRelease = acquireUseRelease;
const as = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => map(self, () => value).traced(trace));
/** @internal */
exports.as = as;
const asUnit = /*#__PURE__*/Debug.methodWithTrace(trace => self => map(self, _Function.constVoid).traced(trace));
/** @internal */
exports.asUnit = asUnit;
const buffer = /*#__PURE__*/Debug.methodWithTrace(trace => (empty, isEmpty, ref) => core.suspend(() => {
  const doBuffer = (empty, isEmpty, ref) => unwrap(Ref.modify(ref, inElem => isEmpty(inElem) ? [core.readWith(input => core.flatMap(core.write(input), () => doBuffer(empty, isEmpty, ref)), error => core.fail(error), done => core.succeedNow(done)), inElem] : [core.flatMap(core.write(inElem), () => doBuffer(empty, isEmpty, ref)), empty]));
  return doBuffer(empty, isEmpty, ref);
}).traced(trace));
/** @internal */
exports.buffer = buffer;
const bufferChunk = /*#__PURE__*/Debug.methodWithTrace(trace => ref => buffer(Chunk.empty(), Chunk.isEmpty, ref).traced(trace));
/** @internal */
exports.bufferChunk = bufferChunk;
const catchAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAllCause(self, cause => Either.match(Cause.failureOrCause(cause), restore(f), core.failCause)).traced(trace));
/** @internal */
exports.catchAll = catchAll;
const concatMap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.concatMapWith(self, restore(f), () => void 0, () => void 0).traced(trace));
/** @internal */
exports.concatMap = concatMap;
const collect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => {
  const collector = core.readWith(out => Option.match(restore(pf)(out), () => collector, out2 => core.flatMap(core.write(out2), () => collector)), core.fail, core.succeedNow);
  return core.pipeTo(self, collector).traced(trace);
});
/** @internal */
exports.collect = collect;
const concatOut = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.concatAll(self).traced(trace));
/** @internal */
exports.concatOut = concatOut;
const contramap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), core.fail, done => core.succeedNow(restore(f)(done)));
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
exports.contramap = contramap;
const contramapEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), core.fail, done => core.fromEffect(restore(f)(done)));
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
exports.contramapEffect = contramapEffect;
const contramapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), error => core.fail(restore(f)(error)), core.succeedNow);
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
exports.contramapError = contramapError;
const contramapErrorEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), error => core.fromEffect(restore(f)(error)), core.succeedNow);
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
exports.contramapErrorEffect = contramapErrorEffect;
const contramapIn = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(restore(f)(inElem)), () => reader), core.fail, core.succeedNow);
  return core.pipeTo(reader, self).traced(trace);
});
exports.contramapIn = contramapIn;
const contramapInEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.flatMap(core.fromEffect(restore(f)(inElem)), core.write), () => reader), core.fail, core.succeedNow);
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
exports.contramapInEffect = contramapInEffect;
const doneCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.suspend(() => {
  const builder = [];
  return core.flatMap(outDone => core.succeed([Chunk.unsafeFromArray(builder), outDone]))(core.pipeTo(self, doneCollectReader(builder))).traced(trace);
}));
/** @internal */
exports.doneCollect = doneCollect;
const doneCollectReader = builder => {
  return core.readWith(outElem => core.flatMap(core.sync(() => {
    builder.push(outElem);
  }), () => doneCollectReader(builder)), core.fail, core.succeed);
};
/** @internal */
const drain = /*#__PURE__*/Debug.methodWithTrace(trace => self => {
  const drainer = core.readWithCause(() => drainer, core.failCause, core.succeed);
  return core.pipeTo(self, drainer).traced(trace);
});
/** @internal */
exports.drain = drain;
const emitCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(doneCollect(self), core.write).traced(trace));
/** @internal */
exports.emitCollect = emitCollect;
const ensuring = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, finalizer) => core.ensuringWith(self, () => finalizer).traced(trace));
/** @internal */
exports.ensuring = ensuring;
const context = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.fromEffect(Effect.context()).traced(trace));
/** @internal */
exports.context = context;
const contextWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => map(context(), restore(f)).traced(trace));
/** @internal */
exports.contextWith = contextWith;
const contextWithChannel = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.flatMap(context(), restore(f)).traced(trace));
/** @internal */
exports.contextWithChannel = contextWithChannel;
const contextWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => mapEffect(context(), restore(f)).traced(trace));
/** @internal */
exports.contextWithEffect = contextWithEffect;
const flatten = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, _Function.identity).traced(trace));
/** @internal */
exports.flatten = flatten;
const foldChannel = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onError, onSuccess) => core.foldCauseChannel(self, cause => {
  const either = Cause.failureOrCause(cause);
  switch (either._tag) {
    case "Left":
      {
        return restore(onError)(either.left);
      }
    case "Right":
      {
        return core.failCause(either.right);
      }
  }
}, restore(onSuccess)).traced(trace));
/** @internal */
exports.foldChannel = foldChannel;
const fromEither = /*#__PURE__*/Debug.methodWithTrace(trace => either => core.suspend(() => Either.match(either, core.fail, core.succeed)).traced(trace));
/** @internal */
exports.fromEither = fromEither;
const fromInput = /*#__PURE__*/Debug.methodWithTrace(trace => input => unwrap(input.takeWith(core.failCause, elem => core.flatMap(core.write(elem), () => fromInput(input)), core.succeed)).traced(trace));
/** @internal */
exports.fromInput = fromInput;
const fromHub = /*#__PURE__*/Debug.methodWithTrace(trace => hub => unwrapScoped(Effect.map(Hub.subscribe(hub), fromQueue)).traced(trace));
/** @internal */
exports.fromHub = fromHub;
const fromHubScoped = /*#__PURE__*/Debug.methodWithTrace(trace => hub => Effect.map(Hub.subscribe(hub), fromQueue).traced(trace));
/** @internal */
exports.fromHubScoped = fromHubScoped;
const fromOption = /*#__PURE__*/Debug.methodWithTrace(trace => option => core.suspend(() => Option.match(option, () => core.fail(Option.none()), core.succeed)).traced(trace));
/** @internal */
exports.fromOption = fromOption;
const fromQueue = /*#__PURE__*/Debug.methodWithTrace(trace => queue => core.suspend(() => fromQueueInternal(queue)).traced(trace));
/** @internal */
exports.fromQueue = fromQueue;
const fromQueueInternal = queue => core.flatMap(Either.match(Exit.match(core.failCause, core.succeedNow), elem => core.flatMap(() => fromQueueInternal(queue))(core.write(elem))))(core.fromEffect(Queue.take(queue)));
/** @internal */
const identityChannel = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.readWith(input => core.flatMap(core.write(input), () => identityChannel()), core.fail, core.succeedNow).traced(trace));
/** @internal */
exports.identityChannel = identityChannel;
const interruptWhen = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, effect) => mergeWith(self, core.fromEffect(effect), selfDone => mergeDecision.Done(Effect.done(selfDone)), effectDone => mergeDecision.Done(Effect.done(effectDone))).traced(trace));
/** @internal */
exports.interruptWhen = interruptWhen;
const interruptWhenDeferred = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, deferred) => interruptWhen(self, Deferred.await(deferred)).traced(trace));
/** @internal */
exports.interruptWhenDeferred = interruptWhenDeferred;
const map = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(self, a => core.sync(() => restore(f)(a))).traced(trace));
/** @internal */
exports.map = map;
const mapEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(self, z => core.fromEffect(restore(f)(z))).traced(trace));
/** @internal */
exports.mapEffect = mapEffect;
const mapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => mapErrorCause(self, Cause.map(restore(f))).traced(trace));
/** @internal */
exports.mapError = mapError;
const mapErrorCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAllCause(self, cause => core.failCause(restore(f)(cause))).traced(trace));
/** @internal */
exports.mapErrorCause = mapErrorCause;
const mapOut = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(outElem => core.flatMap(core.write(restore(f)(outElem)), () => reader), core.fail, core.succeedNow);
  return core.pipeTo(self, reader).traced(trace);
});
/** @internal */
exports.mapOut = mapOut;
const mapOutEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(outElem => core.flatMap(() => reader)(core.flatMap(core.write)(core.fromEffect(restore(f)(outElem)))), core.fail, core.succeedNow);
  return core.pipeTo(self, reader).traced(trace);
});
/** @internal */
exports.mapOutEffect = mapOutEffect;
const mapOutEffectPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, f, n) => unwrapScoped(Effect.map(queue => {
  const consumer = unwrap(Effect.matchCause(Effect.flatten(Queue.take(queue)), core.failCause, Either.match(core.succeedNow, outElem => core.flatMap(core.write(outElem), () => consumer))));
  return consumer;
})(Effect.gen(function* ($) {
  const queue = yield* $(Effect.acquireRelease(Queue.bounded(n), Queue.shutdown));
  const errorSignal = yield* $(Deferred.make());
  const withPermits = n === Number.POSITIVE_INFINITY ? _ => _Function.identity : (yield* $(Effect.makeSemaphore(n))).withPermits;
  const pull = yield* $(toPull(self));
  yield* $(Effect.forkScoped(Effect.interruptible(Effect.forever(Effect.matchCauseEffect(pull, cause => Queue.offer(queue, Effect.failCause(cause)), either => Either.match(either, outDone => {
    const lock = withPermits(n);
    return Effect.zipRight(Effect.interruptible(lock(Effect.unit())), Effect.asUnit(Queue.offer(queue, Effect.succeed(Either.left(outDone)))));
  }, outElem => Effect.gen(function* ($) {
    const deferred = yield* $(Deferred.make());
    const latch = yield* $(Deferred.make());
    yield* $(Effect.asUnit(Queue.offer(queue, Effect.map(Deferred.await(deferred), Either.right))));
    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(Effect.intoDeferred(deferred)(Effect.tapErrorCause(cause => Deferred.failCause(errorSignal, cause))(Effect.uninterruptibleMask(restore => Effect.flatMap(Effect.done)(Effect.raceFirst(Effect.exit(restore(restoreTrace(f)(outElem))))(Effect.exit(restore(Deferred.await(errorSignal)))))))))(Deferred.succeed(latch, void 0)))));
    yield* $(Deferred.await(latch));
  })))))));
  return queue;
}))).traced(trace));
/** @internal */
exports.mapOutEffectPar = mapOutEffectPar;
const mergeAll = /*#__PURE__*/Debug.methodWithTrace(trace => (n, bufferSize = 16, mergeStrategy = _mergeStrategy.BackPressure()) => {
  return channels => mergeAllWith(n, bufferSize, mergeStrategy)(channels, _Function.constVoid).traced(trace);
});
/** @internal */
exports.mergeAll = mergeAll;
const mergeAllUnbounded = /*#__PURE__*/Debug.methodWithTrace(trace => channels => mergeAllWith(Number.POSITIVE_INFINITY)(channels, _Function.constVoid).traced(trace));
/** @internal */
exports.mergeAllUnbounded = mergeAllUnbounded;
const mergeAllUnboundedWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (channels, f) => mergeAllWith(Number.POSITIVE_INFINITY)(channels, restore(f)).traced(trace));
/** @internal */
exports.mergeAllUnboundedWith = mergeAllUnboundedWith;
const mergeAllWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (n, bufferSize = 16, mergeStrategy = _mergeStrategy.BackPressure()) => (channels, f) => unwrapScoped(Effect.map(([queue, input]) => {
  const consumer = unwrap(Effect.matchCause(core.failCause, Either.match(core.succeedNow, outElem => core.flatMap(core.write(outElem), () => consumer)))(Effect.flatten(Queue.take(queue))));
  return core.embedInput(consumer, input);
})(Effect.gen(function* ($) {
  const input = yield* $(singleProducerAsyncInput.make());
  const queueReader = fromInput(input);
  const queue = yield* $(Effect.acquireRelease(Queue.bounded(bufferSize), Queue.shutdown));
  const cancelers = yield* $(Effect.acquireRelease(Queue.unbounded(), Queue.shutdown));
  const lastDone = yield* $(Ref.make(Option.none()));
  const errorSignal = yield* $(Deferred.make());
  const withPermits = n === Number.POSITIVE_INFINITY ? _ => _Function.identity : (yield* $(Effect.makeSemaphore(n))).withPermits;
  const pull = yield* $(toPull(channels));
  const evaluatePull = pull => Effect.catchAllCause(cause => Cause.isInterrupted(cause) ? Effect.failCause(cause) : Effect.asUnit(Effect.zipRight(Deferred.succeed(errorSignal, void 0))(Queue.offer(queue, Effect.failCause(cause)))))(Effect.flatMap(Option.match(() => Effect.unit(), outDone => Ref.update(lastDone, Option.match(() => Option.some(outDone), lastDone => Option.some(f(lastDone, outDone))))))(Effect.repeatUntil(Option.isSome)(Effect.flatMap(Either.match(done => Effect.succeed(Option.some(done)), outElem => Effect.as(Option.none())(Queue.offer(queue, Effect.succeed(Either.right(outElem))))))(pull))));
  yield* $(Effect.forkScoped(Effect.repeatWhileEquals(true)(Effect.matchCauseEffect(pull, cause => Effect.zipRight(Effect.succeed(false))(Queue.offer(queue, Effect.failCause(cause))), Either.match(outDone => Effect.raceWith(withPermits(n)(Effect.unit()), (_, permitAcquisition) => Effect.as(false)(Fiber.interrupt(permitAcquisition)), (_, failureAwait) => Effect.zipRight(Effect.as(false)(Effect.flatMap(Option.match(() => Queue.offer(queue, Effect.succeed(Either.left(outDone))), lastDone => Queue.offer(queue, Effect.succeed(Either.left(restore(f)(lastDone, outDone))))))(Ref.get(lastDone))))(Fiber.interrupt(failureAwait)))(Deferred.await(errorSignal)), channel => _mergeStrategy.match(() => Effect.gen(function* ($) {
    const latch = yield* $(Deferred.make());
    const raceEffects = Effect.scoped(Effect.flatMap(pull => Effect.raceAwait(Deferred.await(errorSignal))(evaluatePull(pull)))(toPull(core.pipeTo(channel)(queueReader))));
    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(raceEffects)(Deferred.succeed(latch, void 0)))));
    yield* $(Deferred.await(latch));
    const errored = yield* $(Deferred.isDone(errorSignal));
    return !errored;
  }), () => Effect.gen(function* ($) {
    const canceler = yield* $(Deferred.make());
    const latch = yield* $(Deferred.make());
    const size = yield* $(Queue.size(cancelers));
    yield* $(Effect.when(() => size >= n)(Effect.flatMap(_ => Deferred.succeed(_, void 0))(Queue.take(cancelers))));
    yield* $(Queue.offer(cancelers, canceler));
    const raceEffects = Effect.scoped(Effect.flatMap(pull => Effect.raceAwait(Deferred.await(canceler))(Effect.raceAwait(Deferred.await(errorSignal))(evaluatePull(pull))))(toPull(core.pipeTo(channel)(queueReader))));
    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(raceEffects)(Deferred.succeed(latch, void 0)))));
    yield* $(Deferred.await(latch));
    const errored = yield* $(Deferred.isDone(errorSignal));
    return !errored;
  }))(mergeStrategy))))));
  return [queue, input];
}))).traced(trace));
/** @internal */
exports.mergeAllWith = mergeAllWith;
const mergeMap = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, n) => mergeMapBufferStrategy(self, restore(f), n, 16, _mergeStrategy.BackPressure()).traced(trace));
/** @internal */
exports.mergeMap = mergeMap;
const mergeMapBuffer = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, n, bufferSize) => mergeMapBufferStrategy(self, restore(f), n, bufferSize, _mergeStrategy.BackPressure()).traced(trace));
/** @internal */
exports.mergeMapBuffer = mergeMapBuffer;
const mergeMapStrategy = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, n, mergeStrategy) => mergeMapBufferStrategy(self, restore(f), n, 16, mergeStrategy).traced(trace));
/** @internal */
exports.mergeMapStrategy = mergeMapStrategy;
const mergeMapBufferStrategy = /*#__PURE__*/Debug.dualWithTrace(5, (trace, restore) => (self, f, n, bufferSize, mergeStrategy) => mergeAll(n, bufferSize, mergeStrategy)(mapOut(self, restore(f))).traced(trace));
/** @internal */
exports.mergeMapBufferStrategy = mergeMapBufferStrategy;
const mergeOut = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => mergeAll(n)(mapOut(self, _Function.identity)).traced(trace));
/** @internal */
exports.mergeOut = mergeOut;
const mergeOutWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, n, f) => mergeAllWith(n)(mapOut(self, _Function.identity), restore(f)).traced(trace));
/** @internal */
exports.mergeOutWith = mergeOutWith;
const mergeWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, that, leftDone, rightDone) => unwrapScoped(Effect.flatMap(input => {
  const queueReader = fromInput(input);
  return Effect.map(Effect.zip(toPull(core.pipeTo(queueReader, self)), toPull(core.pipeTo(queueReader, that))), ([pullL, pullR]) => {
    const handleSide = (exit, fiber, pull) => (done, both, single) => {
      const onDecision = decision => {
        const op = decision;
        if (op._tag === MergeDecisionOpCodes.OP_DONE) {
          return Effect.succeed(core.fromEffect(Effect.zipRight(Fiber.interrupt(fiber), op.effect)));
        }
        return Effect.map(Fiber.await(fiber), Exit.match(cause => core.fromEffect(op.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(op.f(Exit.succeed(done))), elem => zipRight(core.write(elem), go(single(op.f))))));
      };
      return Exit.match(exit, cause => onDecision(done(Exit.failCause(cause))), Either.match(z => onDecision(done(Exit.succeed(z))), elem => Effect.succeed(core.flatMap(core.write(elem), () => core.flatMap(core.fromEffect(Effect.forkDaemon(pull)), leftFiber => go(both(leftFiber, fiber)))))));
    };
    const go = state => {
      switch (state._tag) {
        case MergeStateOpCodes.OP_BOTH_RUNNING:
          {
            const leftJoin = Effect.interruptible(Fiber.join(state.left));
            const rightJoin = Effect.interruptible(Fiber.join(state.right));
            return unwrap(Effect.raceWith(leftJoin, rightJoin, (leftExit, rf) => Effect.zipRight(Fiber.interrupt(rf), handleSide(leftExit, state.right, pullL)(restore(leftDone), mergeState.BothRunning, f => mergeState.LeftDone(f))), (rightExit, lf) => Effect.zipRight(Fiber.interrupt(lf), handleSide(rightExit, state.left, pullR)(restore(rightDone), (left, right) => mergeState.BothRunning(right, left), f => mergeState.RightDone(f)))));
          }
        case MergeStateOpCodes.OP_LEFT_DONE:
          {
            return unwrap(Effect.map(Effect.exit(pullR), Exit.match(cause => core.fromEffect(state.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(state.f(Exit.succeed(done))), elem => core.flatMap(core.write(elem), () => go(mergeState.LeftDone(state.f)))))));
          }
        case MergeStateOpCodes.OP_RIGHT_DONE:
          {
            return unwrap(Effect.map(Effect.exit(pullL), Exit.match(cause => core.fromEffect(state.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(state.f(Exit.succeed(done))), elem => core.flatMap(core.write(elem), () => go(mergeState.RightDone(state.f)))))));
          }
      }
    };
    return core.embedInput(input)(core.flatMap(go)(core.fromEffect(Effect.zipWith(Effect.forkDaemon(pullL), Effect.forkDaemon(pullR), (left, right) => mergeState.BothRunning(left, right)))));
  });
})(singleProducerAsyncInput.make())).traced(trace));
/** @internal */
exports.mergeWith = mergeWith;
const never = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.fromEffect(Effect.never()).traced(trace));
/** @internal */
exports.never = never;
const orDie = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, error) => orDieWith(self, restore(error)).traced(trace));
/** @internal */
exports.orDie = orDie;
const orDieWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => catchAll(self, e => {
  throw restore(f)(e);
}).traced(trace));
/** @internal */
exports.orDieWith = orDieWith;
const orElse = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => catchAll(self, that).traced(trace));
/** @internal */
exports.orElse = orElse;
const pipeToOrFail = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.suspend(() => {
  let channelException = undefined;
  const reader = core.readWith(outElem => core.flatMap(core.write(outElem), () => reader), outErr => {
    channelException = ChannelException(outErr);
    return core.failCause(Cause.die(channelException));
  }, core.succeedNow);
  const writer = core.readWithCause(outElem => core.flatMap(() => writer)(core.write(outElem)), annotatedCause => {
    const unannotated = Cause.unannotate(annotatedCause);
    return Cause.isDieType(unannotated) && isChannelException(unannotated.defect) && Equal.equals(unannotated.defect, channelException) ? core.fail(unannotated.defect.error) : core.failCause(annotatedCause);
  }, core.succeedNow);
  return core.pipeTo(core.pipeTo(core.pipeTo(self, reader), that), writer).traced(trace);
}));
/** @internal */
exports.pipeToOrFail = pipeToOrFail;
const provideService = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, tag, service) => {
  return core.flatMap(context(), context => core.provideContext(self, Context.add(context, tag, service))).traced(trace);
});
/** @internal */
exports.provideService = provideService;
const provideLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) => unwrapScoped(Effect.map(Layer.build(layer), env => core.provideContext(self, env))).traced(trace));
/** @internal */
exports.provideLayer = provideLayer;
const contramapContext = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => contextWithChannel(context => core.provideContext(self, restore(f)(context))).traced(trace));
/** @internal */
exports.contramapContext = contramapContext;
const provideSomeLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) =>
// @ts-expect-error
provideLayer(self, Layer.merge(Layer.context(), layer)).traced(trace));
/** @internal */
exports.provideSomeLayer = provideSomeLayer;
const read = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.readOrFail(Option.none()).traced(trace));
/** @internal */
exports.read = read;
const repeated = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, () => repeated(self)).traced(trace));
/** @internal */
exports.repeated = repeated;
const run = /*#__PURE__*/Debug.methodWithTrace(trace => self => Effect.scoped(executor.runScoped(self)).traced(trace));
/** @internal */
exports.run = run;
const runCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => executor.run(core.collectElements(self)).traced(trace));
/** @internal */
exports.runCollect = runCollect;
const runDrain = /*#__PURE__*/Debug.methodWithTrace(trace => self => executor.run(drain(self)).traced(trace));
/** @internal */
exports.runDrain = runDrain;
const scoped = /*#__PURE__*/Debug.methodWithTrace(trace => effect => unwrap(Effect.uninterruptibleMask(restore => Effect.map(Scope.make(), scope => core.acquireReleaseOut(Effect.tapErrorCause(restore(Scope.extend(scope)(effect)), cause => Scope.close(scope, Exit.failCause(cause))), (_, exit) => Scope.close(scope, exit))))).traced(trace));
/** @internal */
exports.scoped = scoped;
const service = /*#__PURE__*/Debug.methodWithTrace(trace => tag => core.fromEffect(tag).traced(trace));
/** @internal */
exports.service = service;
const serviceWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => map(service(tag), restore(f)).traced(trace));
/** @internal */
exports.serviceWith = serviceWith;
const serviceWithChannel = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => core.flatMap(service(tag), restore(f)).traced(trace));
/** @internal */
exports.serviceWithChannel = serviceWithChannel;
const serviceWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => mapEffect(service(tag), restore(f)).traced(trace));
/** @internal */
exports.serviceWithEffect = serviceWithEffect;
const toHub = /*#__PURE__*/Debug.methodWithTrace(trace => hub => toQueue(hub).traced(trace));
/** @internal */
exports.toHub = toHub;
const toPull = /*#__PURE__*/Debug.methodWithTrace(trace => self => Effect.map(Effect.acquireRelease(Effect.sync(() => new executor.ChannelExecutor(self, void 0, _Function.identity)), (exec, exit) => {
  const finalize = exec.close(exit);
  return finalize === undefined ? Effect.unit() : finalize;
}), exec => Effect.suspend(() => interpretToPull(exec.run(), exec))).traced(trace));
/** @internal */
exports.toPull = toPull;
const interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case ChannelStateOpCodes.OP_DONE:
      {
        return Exit.match(exec.getDone(), Effect.failCause, done => Effect.succeed(Either.left(done)));
      }
    case ChannelStateOpCodes.OP_EMIT:
      {
        return Effect.succeed(Either.right(exec.getEmit()));
      }
    case ChannelStateOpCodes.OP_FROM_EFFECT:
      {
        return Effect.flatMap(() => interpretToPull(exec.run(), exec))(state.effect);
      }
    case ChannelStateOpCodes.OP_READ:
      {
        return executor.readUpstream(state, () => interpretToPull(exec.run(), exec), cause => Effect.failCause(cause));
      }
  }
};
/** @internal */
const toQueue = /*#__PURE__*/Debug.methodWithTrace(trace => queue => core.suspend(() => toQueueInternal(queue)).traced(trace));
/** @internal */
exports.toQueue = toQueue;
const toQueueInternal = queue => {
  return core.readWithCause(elem => core.flatMap(core.fromEffect(Queue.offer(queue, Either.right(elem))), () => toQueueInternal(queue)), cause => core.fromEffect(Queue.offer(queue, Either.left(Exit.failCause(cause)))), done => core.fromEffect(Queue.offer(queue, Either.left(Exit.succeed(done)))));
};
/** @internal */
const unwrap = /*#__PURE__*/Debug.methodWithTrace(trace => channel => flatten(core.fromEffect(channel)).traced(trace));
/** @internal */
exports.unwrap = unwrap;
const unwrapScoped = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.concatAllWith(scoped(self), (d, _) => d, (d, _) => d).traced(trace));
/** @internal */
exports.unwrapScoped = unwrapScoped;
const updateService = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => contramapContext(self, context => Context.merge(context, Context.make(tag, restore(f)(Context.unsafeGet(context, tag))))).traced(trace));
/** @internal */
exports.updateService = updateService;
const writeAll = /*#__PURE__*/Debug.methodWithTrace(trace => (...outs) => writeChunk(Chunk.fromIterable(outs)).traced(trace));
/** @internal */
exports.writeAll = writeAll;
const writeChunk = /*#__PURE__*/Debug.methodWithTrace(trace => outs => writeChunkWriter(0, outs.length, outs).traced(trace));
/** @internal */
exports.writeChunk = writeChunk;
const writeChunkWriter = (idx, len, chunk) => {
  return idx === len ? core.unit() : core.flatMap(() => writeChunkWriter(idx + 1, len, chunk))(core.write(Chunk.unsafeGet(idx)(chunk)));
};
/** @internal */
const zip = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, a => map(b => [a, b])(that)).traced(trace));
/** @internal */
exports.zip = zip;
const zipLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, z => as(that, z)).traced(trace));
/** @internal */
exports.zipLeft = zipLeft;
const zipRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, () => that).traced(trace));
/** @internal */
exports.zipRight = zipRight;
const zipPar = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => mergeWith(self, that, exit1 => mergeDecision.Await(exit2 => Effect.done(Exit.zip(exit1, exit2))), exit2 => mergeDecision.Await(exit1 => Effect.done(Exit.zip(exit1, exit2)))).traced(trace));
/** @internal */
exports.zipPar = zipPar;
const zipParLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => map(zipPar(self, that), tuple => tuple[0]).traced(trace));
/** @internal */
exports.zipParLeft = zipParLeft;
const zipParRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => map(zipPar(self, that), tuple => tuple[1]).traced(trace));
/** @internal */
exports.zipParRight = zipParRight;
const ChannelExceptionTypeId = /*#__PURE__*/Symbol.for("@effect/stream/Channel/errors/ChannelException");
/** @internal */
exports.ChannelExceptionTypeId = ChannelExceptionTypeId;
const ChannelException = error => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error
});
/** @internal */
exports.ChannelException = ChannelException;
const isChannelException = u => typeof u === "object" && u != null && ChannelExceptionTypeId in u;
exports.isChannelException = isChannelException;
//# sourceMappingURL=channel.js.map