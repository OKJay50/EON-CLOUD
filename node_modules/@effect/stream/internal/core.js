"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.write = exports.unit = exports.sync = exports.suspend = exports.succeedNow = exports.succeed = exports.readWithCause = exports.readWith = exports.readOrFail = exports.provideContext = exports.pipeTo = exports.fromEffect = exports.foldCauseChannel = exports.flatMap = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.ensuringWith = exports.embedInput = exports.concatMapWithCustom = exports.concatMapWith = exports.concatAllWith = exports.concatAll = exports.collectElements = exports.catchAllCause = exports.acquireReleaseOut = exports.ChannelTypeId = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Debug"));
var Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var childExecutorDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/childExecutorDecision"));
var _continuation = /*#__PURE__*/require("@effect/stream/internal/channel/continuation");
var upstreamPullStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/channel/upstreamPullStrategy"));
var OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/opCodes/channel"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/** @internal */
const ChannelSymbolKey = "@effect/stream/Channel";
/** @internal */
const ChannelTypeId = /*#__PURE__*/Symbol.for(ChannelSymbolKey);
/** @internal */
exports.ChannelTypeId = ChannelTypeId;
const channelVariance = {
  _Env: _ => _,
  _InErr: _ => _,
  _InElem: _ => _,
  _InDone: _ => _,
  _OutErr: _ => _,
  _OutElem: _ => _,
  _OutDone: _ => _
};
/** @internal */
const proto = {
  [ChannelTypeId]: channelVariance,
  traced(trace) {
    if (trace) {
      return Object.create(proto, {
        _tag: {
          value: OpCodes.OP_TRACED
        },
        channel: {
          value: this
        },
        trace: {
          value: trace
        }
      });
    }
    return this;
  }
};
/** @internal */
const acquireReleaseOut = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, release) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = restore(release);
  return op.traced(trace);
});
/** @internal */
exports.acquireReleaseOut = acquireReleaseOut;
const catchAllCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FOLD;
  op.channel = self;
  op.k = new _continuation.ContinuationKImpl(succeed, restore(f));
  return op.traced(trace);
});
/** @internal */
exports.catchAllCause = catchAllCause;
const collectElements = /*#__PURE__*/Debug.methodWithTrace(trace => self => {
  return suspend(() => {
    const builder = [];
    return flatMap(pipeTo(self, collectElementsReader(builder)), value => sync(() => [Chunk.fromIterable(builder), value]));
  }).traced(trace);
});
/** @internal */
exports.collectElements = collectElements;
const collectElementsReader = builder => {
  return readWith(outElem => flatMap(sync(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)), fail, succeedNow);
};
/** @internal */
const concatAll = /*#__PURE__*/Debug.methodWithTrace(trace => channels => concatAllWith(channels, _Function.constVoid, _Function.constVoid).traced(trace));
/** @internal */
exports.concatAll = concatAll;
const concatAllWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (channels, f, g) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_CONCAT_ALL;
  op.combineInners = restore(f);
  op.combineAll = restore(g);
  op.onPull = () => upstreamPullStrategy.PullAfterNext(Option.none());
  op.onEmit = () => childExecutorDecision.Continue;
  op.value = () => channels;
  op.k = _Function.identity;
  return op.traced(trace);
});
/** @internal */
exports.concatAllWith = concatAllWith;
const concatMapWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, g, h) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_CONCAT_ALL;
  op.combineInners = restore(g);
  op.combineAll = restore(h);
  op.onPull = () => upstreamPullStrategy.PullAfterNext(Option.none());
  op.onEmit = () => childExecutorDecision.Continue;
  op.value = () => self;
  op.k = restore(f);
  return op.traced(trace);
});
/** @internal */
exports.concatMapWith = concatMapWith;
const concatMapWithCustom = /*#__PURE__*/Debug.dualWithTrace(6, (trace, restore) => (self, f, g, h, onPull, onEmit) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_CONCAT_ALL;
  op.combineInners = restore(g);
  op.combineAll = restore(h);
  op.onPull = restore(onPull);
  op.onEmit = restore(onEmit);
  op.value = () => self;
  op.k = restore(f);
  return op.traced(trace);
});
/** @internal */
exports.concatMapWithCustom = concatMapWithCustom;
const embedInput = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, input) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op.traced(trace);
});
/** @internal */
exports.embedInput = embedInput;
const ensuringWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, finalizer) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_ENSURING;
  op.channel = self;
  op.finalizer = restore(finalizer);
  return op.traced(trace);
});
/** @internal */
exports.ensuringWith = ensuringWith;
const fail = /*#__PURE__*/Debug.methodWithTrace(trace => error => failCause(Cause.fail(error)).traced(trace));
/** @internal */
exports.fail = fail;
const failSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => failCauseSync(() => Cause.fail(restore(evaluate)())).traced(trace));
/** @internal */
exports.failSync = failSync;
const failCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => failCauseSync(() => cause).traced(trace));
/** @internal */
exports.failCause = failCause;
const failCauseSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FAIL;
  op.error = restore(evaluate);
  return op.traced(trace);
});
/** @internal */
exports.failCauseSync = failCauseSync;
const flatMap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FOLD;
  op.channel = self;
  op.k = new _continuation.ContinuationKImpl(restore(f), failCause);
  return op.traced(trace);
});
/** @internal */
exports.flatMap = flatMap;
const foldCauseChannel = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onError, onSuccess) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FOLD;
  op.channel = self;
  op.k = new _continuation.ContinuationKImpl(restore(onSuccess), restore(onError));
  return op.traced(trace);
});
/** @internal */
exports.foldCauseChannel = foldCauseChannel;
const fromEffect = /*#__PURE__*/Debug.methodWithTrace(trace => effect => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FROM_EFFECT;
  op.effect = () => effect;
  return op.traced(trace);
});
/** @internal */
exports.fromEffect = fromEffect;
const pipeTo = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op.traced(trace);
});
/** @internal */
exports.pipeTo = pipeTo;
const provideContext = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, env) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_PROVIDE;
  op.context = () => env;
  op.inner = self;
  return op.traced(trace);
});
/** @internal */
exports.provideContext = provideContext;
const readOrFail = /*#__PURE__*/Debug.methodWithTrace(trace => error => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_READ;
  op.more = succeed;
  op.done = new _continuation.ContinuationKImpl(() => fail(error), () => fail(error));
  return op.traced(trace);
});
/** @internal */
exports.readOrFail = readOrFail;
const readWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (input, error, done) => readWithCause(restore(input), cause => Either.match(Cause.failureOrCause(cause), restore(error), failCause), restore(done)));
/** @internal */
exports.readWith = readWith;
const readWithCause = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (input, halt, done) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_READ;
  op.more = restore(input);
  op.done = new _continuation.ContinuationKImpl(restore(done), restore(halt));
  return op.traced(trace);
});
/** @internal */
exports.readWithCause = readWithCause;
const succeed = /*#__PURE__*/Debug.methodWithTrace(trace => value => sync(() => value).traced(trace));
/** @internal */
exports.succeed = succeed;
const succeedNow = /*#__PURE__*/Debug.methodWithTrace(trace => result => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_SUCCEED_NOW;
  op.terminal = result;
  return op.traced(trace);
});
/** @internal */
exports.succeedNow = succeedNow;
const suspend = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_SUSPEND;
  op.channel = restore(evaluate);
  return op.traced(trace);
});
exports.suspend = suspend;
const sync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_SUCCEED;
  op.evaluate = restore(evaluate);
  return op.traced(trace);
});
/** @internal */
exports.sync = sync;
const unit = /*#__PURE__*/Debug.methodWithTrace(trace => () => succeedNow(void 0).traced(trace));
/** @internal */
exports.unit = unit;
const write = /*#__PURE__*/Debug.methodWithTrace(trace => out => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_EMIT;
  op.out = out;
  return op.traced(trace);
});
exports.write = write;
//# sourceMappingURL=core.js.map