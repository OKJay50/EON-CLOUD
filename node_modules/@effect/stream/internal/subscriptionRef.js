"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.set = exports.modifyEffect = exports.modify = exports.make = exports.get = exports.SubscriptionRefTypeId = void 0;
var _Debug = /*#__PURE__*/require("@effect/data/Debug");
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var Hub = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Hub"));
var _circular = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/internal_effect_untraced/effect/circular"));
var _ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/internal_effect_untraced/ref"));
var Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Ref"));
var Synchronized = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Ref/Synchronized"));
var stream = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/stream"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var _a, _b, _c;
/** @internal */
const SubscriptionRefSymbolKey = "@effect/stream/SubscriptionRef";
/** @internal */
const SubscriptionRefTypeId = /*#__PURE__*/Symbol.for(SubscriptionRefSymbolKey);
/** @internal */
exports.SubscriptionRefTypeId = SubscriptionRefTypeId;
const subscriptionRefVariance = {
  _A: _ => _
};
/** @internal */
class SubscriptionRefImpl {
  constructor(ref, hub, semaphore) {
    this.ref = ref;
    this.hub = hub;
    this.semaphore = semaphore;
    this[_a] = _ref.refVariance;
    this[_b] = _circular.synchronizedVariance;
    this[_c] = subscriptionRefVariance;
  }
  get changes() {
    return stream.unwrapScoped(this.semaphore.withPermits(1)(Effect.flatMap(a => Effect.map(s => stream.concat(s)(stream.make(a)))(stream.fromHubScoped(this.hub)))(Ref.get(this.ref))));
  }
  /** @macro traced */
  modify(f) {
    return (0, _Debug.bodyWithTrace)(trace => this.modifyEffect(a => Effect.succeed(f(a))).traced(trace));
  }
  /** @macro traced */
  modifyEffect(f) {
    return (0, _Debug.bodyWithTrace)(trace => this.semaphore.withPermits(1)(Effect.flatMap(([b, a]) => Effect.zipLeft(Hub.publish(this.hub, a))(Effect.as(b)(Ref.set(this.ref, a))))(Effect.flatMap(f)(Ref.get(this.ref)))).traced(trace));
  }
}
_a = Ref.RefTypeId, _b = Synchronized.SynchronizedTypeId, _c = SubscriptionRefTypeId;
/** @internal */
const get = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => Ref.get(self.ref).traced(trace));
/** @internal */
exports.get = get;
const make = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => value => Effect.map(([hub, ref, semaphore]) => new SubscriptionRefImpl(ref, hub, semaphore))(Effect.all(Hub.unbounded(), Ref.make(value), Effect.makeSemaphore(1))).traced(trace));
/** @internal */
exports.make = make;
const modify = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => self.modify(f).traced(trace));
/** @internal */
exports.modify = modify;
const modifyEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => self.modifyEffect(f).traced(trace));
/** @internal */
exports.modifyEffect = modifyEffect;
const set = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, value) => self.semaphore.withPermits(1)(Effect.zipLeft(Hub.publish(self.hub, value))(Ref.set(self.ref, value))).traced(trace));
exports.set = set;
//# sourceMappingURL=subscriptionRef.js.map