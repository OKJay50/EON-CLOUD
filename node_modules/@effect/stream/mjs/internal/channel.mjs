import * as Chunk from "@effect/data/Chunk";
import * as Context from "@effect/data/Context";
import * as Debug from "@effect/data/Debug";
import * as Either from "@effect/data/Either";
import * as Equal from "@effect/data/Equal";
import { constVoid, identity } from "@effect/data/Function";
import * as Option from "@effect/data/Option";
import * as Cause from "@effect/io/Cause";
import * as Deferred from "@effect/io/Deferred";
import * as Effect from "@effect/io/Effect";
import * as Exit from "@effect/io/Exit";
import * as Fiber from "@effect/io/Fiber";
import * as Hub from "@effect/io/Hub";
import * as Layer from "@effect/io/Layer";
import * as Queue from "@effect/io/Queue";
import * as Ref from "@effect/io/Ref";
import * as Scope from "@effect/io/Scope";
import * as executor from "@effect/stream/internal/channel/channelExecutor";
import * as mergeDecision from "@effect/stream/internal/channel/mergeDecision";
import * as mergeState from "@effect/stream/internal/channel/mergeState";
import * as _mergeStrategy from "@effect/stream/internal/channel/mergeStrategy";
import * as singleProducerAsyncInput from "@effect/stream/internal/channel/singleProducerAsyncInput";
import * as core from "@effect/stream/internal/core";
import * as ChannelStateOpCodes from "@effect/stream/internal/opCodes/channelState";
import * as MergeDecisionOpCodes from "@effect/stream/internal/opCodes/mergeDecision";
import * as MergeStateOpCodes from "@effect/stream/internal/opCodes/mergeState";
/** @internal */
export const acquireUseRelease = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (acquire, use, release) => core.flatMap(core.fromEffect(Ref.make(() => Effect.unit())), ref => core.ensuringWith(exit => Effect.flatMap(Ref.get(ref), f => f(exit)))(core.flatMap(restore(use))(core.fromEffect(Effect.uninterruptible(Effect.tap(acquire, a => Ref.set(ref, exit => restore(release)(a, exit)))))))).traced(trace));
/** @internal */
export const as = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => map(self, () => value).traced(trace));
/** @internal */
export const asUnit = /*#__PURE__*/Debug.methodWithTrace(trace => self => map(self, constVoid).traced(trace));
/** @internal */
export const buffer = /*#__PURE__*/Debug.methodWithTrace(trace => (empty, isEmpty, ref) => core.suspend(() => {
  const doBuffer = (empty, isEmpty, ref) => unwrap(Ref.modify(ref, inElem => isEmpty(inElem) ? [core.readWith(input => core.flatMap(core.write(input), () => doBuffer(empty, isEmpty, ref)), error => core.fail(error), done => core.succeedNow(done)), inElem] : [core.flatMap(core.write(inElem), () => doBuffer(empty, isEmpty, ref)), empty]));
  return doBuffer(empty, isEmpty, ref);
}).traced(trace));
/** @internal */
export const bufferChunk = /*#__PURE__*/Debug.methodWithTrace(trace => ref => buffer(Chunk.empty(), Chunk.isEmpty, ref).traced(trace));
/** @internal */
export const catchAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAllCause(self, cause => Either.match(Cause.failureOrCause(cause), restore(f), core.failCause)).traced(trace));
/** @internal */
export const concatMap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.concatMapWith(self, restore(f), () => void 0, () => void 0).traced(trace));
/** @internal */
export const collect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => {
  const collector = core.readWith(out => Option.match(restore(pf)(out), () => collector, out2 => core.flatMap(core.write(out2), () => collector)), core.fail, core.succeedNow);
  return core.pipeTo(self, collector).traced(trace);
});
/** @internal */
export const concatOut = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.concatAll(self).traced(trace));
/** @internal */
export const contramap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), core.fail, done => core.succeedNow(restore(f)(done)));
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
export const contramapEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), core.fail, done => core.fromEffect(restore(f)(done)));
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
export const contramapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), error => core.fail(restore(f)(error)), core.succeedNow);
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
export const contramapErrorEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), error => core.fromEffect(restore(f)(error)), core.succeedNow);
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
export const contramapIn = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.write(restore(f)(inElem)), () => reader), core.fail, core.succeedNow);
  return core.pipeTo(reader, self).traced(trace);
});
export const contramapInEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(inElem => core.flatMap(core.flatMap(core.fromEffect(restore(f)(inElem)), core.write), () => reader), core.fail, core.succeedNow);
  return core.pipeTo(reader, self).traced(trace);
});
/** @internal */
export const doneCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.suspend(() => {
  const builder = [];
  return core.flatMap(outDone => core.succeed([Chunk.unsafeFromArray(builder), outDone]))(core.pipeTo(self, doneCollectReader(builder))).traced(trace);
}));
/** @internal */
const doneCollectReader = builder => {
  return core.readWith(outElem => core.flatMap(core.sync(() => {
    builder.push(outElem);
  }), () => doneCollectReader(builder)), core.fail, core.succeed);
};
/** @internal */
export const drain = /*#__PURE__*/Debug.methodWithTrace(trace => self => {
  const drainer = core.readWithCause(() => drainer, core.failCause, core.succeed);
  return core.pipeTo(self, drainer).traced(trace);
});
/** @internal */
export const emitCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(doneCollect(self), core.write).traced(trace));
/** @internal */
export const ensuring = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, finalizer) => core.ensuringWith(self, () => finalizer).traced(trace));
/** @internal */
export const context = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.fromEffect(Effect.context()).traced(trace));
/** @internal */
export const contextWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => map(context(), restore(f)).traced(trace));
/** @internal */
export const contextWithChannel = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.flatMap(context(), restore(f)).traced(trace));
/** @internal */
export const contextWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => mapEffect(context(), restore(f)).traced(trace));
/** @internal */
export const flatten = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, identity).traced(trace));
/** @internal */
export const foldChannel = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onError, onSuccess) => core.foldCauseChannel(self, cause => {
  const either = Cause.failureOrCause(cause);
  switch (either._tag) {
    case "Left":
      {
        return restore(onError)(either.left);
      }
    case "Right":
      {
        return core.failCause(either.right);
      }
  }
}, restore(onSuccess)).traced(trace));
/** @internal */
export const fromEither = /*#__PURE__*/Debug.methodWithTrace(trace => either => core.suspend(() => Either.match(either, core.fail, core.succeed)).traced(trace));
/** @internal */
export const fromInput = /*#__PURE__*/Debug.methodWithTrace(trace => input => unwrap(input.takeWith(core.failCause, elem => core.flatMap(core.write(elem), () => fromInput(input)), core.succeed)).traced(trace));
/** @internal */
export const fromHub = /*#__PURE__*/Debug.methodWithTrace(trace => hub => unwrapScoped(Effect.map(Hub.subscribe(hub), fromQueue)).traced(trace));
/** @internal */
export const fromHubScoped = /*#__PURE__*/Debug.methodWithTrace(trace => hub => Effect.map(Hub.subscribe(hub), fromQueue).traced(trace));
/** @internal */
export const fromOption = /*#__PURE__*/Debug.methodWithTrace(trace => option => core.suspend(() => Option.match(option, () => core.fail(Option.none()), core.succeed)).traced(trace));
/** @internal */
export const fromQueue = /*#__PURE__*/Debug.methodWithTrace(trace => queue => core.suspend(() => fromQueueInternal(queue)).traced(trace));
/** @internal */
const fromQueueInternal = queue => core.flatMap(Either.match(Exit.match(core.failCause, core.succeedNow), elem => core.flatMap(() => fromQueueInternal(queue))(core.write(elem))))(core.fromEffect(Queue.take(queue)));
/** @internal */
export const identityChannel = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.readWith(input => core.flatMap(core.write(input), () => identityChannel()), core.fail, core.succeedNow).traced(trace));
/** @internal */
export const interruptWhen = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, effect) => mergeWith(self, core.fromEffect(effect), selfDone => mergeDecision.Done(Effect.done(selfDone)), effectDone => mergeDecision.Done(Effect.done(effectDone))).traced(trace));
/** @internal */
export const interruptWhenDeferred = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, deferred) => interruptWhen(self, Deferred.await(deferred)).traced(trace));
/** @internal */
export const map = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(self, a => core.sync(() => restore(f)(a))).traced(trace));
/** @internal */
export const mapEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(self, z => core.fromEffect(restore(f)(z))).traced(trace));
/** @internal */
export const mapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => mapErrorCause(self, Cause.map(restore(f))).traced(trace));
/** @internal */
export const mapErrorCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAllCause(self, cause => core.failCause(restore(f)(cause))).traced(trace));
/** @internal */
export const mapOut = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(outElem => core.flatMap(core.write(restore(f)(outElem)), () => reader), core.fail, core.succeedNow);
  return core.pipeTo(self, reader).traced(trace);
});
/** @internal */
export const mapOutEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const reader = core.readWith(outElem => core.flatMap(() => reader)(core.flatMap(core.write)(core.fromEffect(restore(f)(outElem)))), core.fail, core.succeedNow);
  return core.pipeTo(self, reader).traced(trace);
});
/** @internal */
export const mapOutEffectPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, f, n) => unwrapScoped(Effect.map(queue => {
  const consumer = unwrap(Effect.matchCause(Effect.flatten(Queue.take(queue)), core.failCause, Either.match(core.succeedNow, outElem => core.flatMap(core.write(outElem), () => consumer))));
  return consumer;
})(Effect.gen(function* ($) {
  const queue = yield* $(Effect.acquireRelease(Queue.bounded(n), Queue.shutdown));
  const errorSignal = yield* $(Deferred.make());
  const withPermits = n === Number.POSITIVE_INFINITY ? _ => identity : (yield* $(Effect.makeSemaphore(n))).withPermits;
  const pull = yield* $(toPull(self));
  yield* $(Effect.forkScoped(Effect.interruptible(Effect.forever(Effect.matchCauseEffect(pull, cause => Queue.offer(queue, Effect.failCause(cause)), either => Either.match(either, outDone => {
    const lock = withPermits(n);
    return Effect.zipRight(Effect.interruptible(lock(Effect.unit())), Effect.asUnit(Queue.offer(queue, Effect.succeed(Either.left(outDone)))));
  }, outElem => Effect.gen(function* ($) {
    const deferred = yield* $(Deferred.make());
    const latch = yield* $(Deferred.make());
    yield* $(Effect.asUnit(Queue.offer(queue, Effect.map(Deferred.await(deferred), Either.right))));
    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(Effect.intoDeferred(deferred)(Effect.tapErrorCause(cause => Deferred.failCause(errorSignal, cause))(Effect.uninterruptibleMask(restore => Effect.flatMap(Effect.done)(Effect.raceFirst(Effect.exit(restore(restoreTrace(f)(outElem))))(Effect.exit(restore(Deferred.await(errorSignal)))))))))(Deferred.succeed(latch, void 0)))));
    yield* $(Deferred.await(latch));
  })))))));
  return queue;
}))).traced(trace));
/** @internal */
export const mergeAll = /*#__PURE__*/Debug.methodWithTrace(trace => (n, bufferSize = 16, mergeStrategy = _mergeStrategy.BackPressure()) => {
  return channels => mergeAllWith(n, bufferSize, mergeStrategy)(channels, constVoid).traced(trace);
});
/** @internal */
export const mergeAllUnbounded = /*#__PURE__*/Debug.methodWithTrace(trace => channels => mergeAllWith(Number.POSITIVE_INFINITY)(channels, constVoid).traced(trace));
/** @internal */
export const mergeAllUnboundedWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (channels, f) => mergeAllWith(Number.POSITIVE_INFINITY)(channels, restore(f)).traced(trace));
/** @internal */
export const mergeAllWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (n, bufferSize = 16, mergeStrategy = _mergeStrategy.BackPressure()) => (channels, f) => unwrapScoped(Effect.map(([queue, input]) => {
  const consumer = unwrap(Effect.matchCause(core.failCause, Either.match(core.succeedNow, outElem => core.flatMap(core.write(outElem), () => consumer)))(Effect.flatten(Queue.take(queue))));
  return core.embedInput(consumer, input);
})(Effect.gen(function* ($) {
  const input = yield* $(singleProducerAsyncInput.make());
  const queueReader = fromInput(input);
  const queue = yield* $(Effect.acquireRelease(Queue.bounded(bufferSize), Queue.shutdown));
  const cancelers = yield* $(Effect.acquireRelease(Queue.unbounded(), Queue.shutdown));
  const lastDone = yield* $(Ref.make(Option.none()));
  const errorSignal = yield* $(Deferred.make());
  const withPermits = n === Number.POSITIVE_INFINITY ? _ => identity : (yield* $(Effect.makeSemaphore(n))).withPermits;
  const pull = yield* $(toPull(channels));
  const evaluatePull = pull => Effect.catchAllCause(cause => Cause.isInterrupted(cause) ? Effect.failCause(cause) : Effect.asUnit(Effect.zipRight(Deferred.succeed(errorSignal, void 0))(Queue.offer(queue, Effect.failCause(cause)))))(Effect.flatMap(Option.match(() => Effect.unit(), outDone => Ref.update(lastDone, Option.match(() => Option.some(outDone), lastDone => Option.some(f(lastDone, outDone))))))(Effect.repeatUntil(Option.isSome)(Effect.flatMap(Either.match(done => Effect.succeed(Option.some(done)), outElem => Effect.as(Option.none())(Queue.offer(queue, Effect.succeed(Either.right(outElem))))))(pull))));
  yield* $(Effect.forkScoped(Effect.repeatWhileEquals(true)(Effect.matchCauseEffect(pull, cause => Effect.zipRight(Effect.succeed(false))(Queue.offer(queue, Effect.failCause(cause))), Either.match(outDone => Effect.raceWith(withPermits(n)(Effect.unit()), (_, permitAcquisition) => Effect.as(false)(Fiber.interrupt(permitAcquisition)), (_, failureAwait) => Effect.zipRight(Effect.as(false)(Effect.flatMap(Option.match(() => Queue.offer(queue, Effect.succeed(Either.left(outDone))), lastDone => Queue.offer(queue, Effect.succeed(Either.left(restore(f)(lastDone, outDone))))))(Ref.get(lastDone))))(Fiber.interrupt(failureAwait)))(Deferred.await(errorSignal)), channel => _mergeStrategy.match(() => Effect.gen(function* ($) {
    const latch = yield* $(Deferred.make());
    const raceEffects = Effect.scoped(Effect.flatMap(pull => Effect.raceAwait(Deferred.await(errorSignal))(evaluatePull(pull)))(toPull(core.pipeTo(channel)(queueReader))));
    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(raceEffects)(Deferred.succeed(latch, void 0)))));
    yield* $(Deferred.await(latch));
    const errored = yield* $(Deferred.isDone(errorSignal));
    return !errored;
  }), () => Effect.gen(function* ($) {
    const canceler = yield* $(Deferred.make());
    const latch = yield* $(Deferred.make());
    const size = yield* $(Queue.size(cancelers));
    yield* $(Effect.when(() => size >= n)(Effect.flatMap(_ => Deferred.succeed(_, void 0))(Queue.take(cancelers))));
    yield* $(Queue.offer(cancelers, canceler));
    const raceEffects = Effect.scoped(Effect.flatMap(pull => Effect.raceAwait(Deferred.await(canceler))(Effect.raceAwait(Deferred.await(errorSignal))(evaluatePull(pull))))(toPull(core.pipeTo(channel)(queueReader))));
    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(raceEffects)(Deferred.succeed(latch, void 0)))));
    yield* $(Deferred.await(latch));
    const errored = yield* $(Deferred.isDone(errorSignal));
    return !errored;
  }))(mergeStrategy))))));
  return [queue, input];
}))).traced(trace));
/** @internal */
export const mergeMap = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, n) => mergeMapBufferStrategy(self, restore(f), n, 16, _mergeStrategy.BackPressure()).traced(trace));
/** @internal */
export const mergeMapBuffer = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, n, bufferSize) => mergeMapBufferStrategy(self, restore(f), n, bufferSize, _mergeStrategy.BackPressure()).traced(trace));
/** @internal */
export const mergeMapStrategy = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, n, mergeStrategy) => mergeMapBufferStrategy(self, restore(f), n, 16, mergeStrategy).traced(trace));
/** @internal */
export const mergeMapBufferStrategy = /*#__PURE__*/Debug.dualWithTrace(5, (trace, restore) => (self, f, n, bufferSize, mergeStrategy) => mergeAll(n, bufferSize, mergeStrategy)(mapOut(self, restore(f))).traced(trace));
/** @internal */
export const mergeOut = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => mergeAll(n)(mapOut(self, identity)).traced(trace));
/** @internal */
export const mergeOutWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, n, f) => mergeAllWith(n)(mapOut(self, identity), restore(f)).traced(trace));
/** @internal */
export const mergeWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, that, leftDone, rightDone) => unwrapScoped(Effect.flatMap(input => {
  const queueReader = fromInput(input);
  return Effect.map(Effect.zip(toPull(core.pipeTo(queueReader, self)), toPull(core.pipeTo(queueReader, that))), ([pullL, pullR]) => {
    const handleSide = (exit, fiber, pull) => (done, both, single) => {
      const onDecision = decision => {
        const op = decision;
        if (op._tag === MergeDecisionOpCodes.OP_DONE) {
          return Effect.succeed(core.fromEffect(Effect.zipRight(Fiber.interrupt(fiber), op.effect)));
        }
        return Effect.map(Fiber.await(fiber), Exit.match(cause => core.fromEffect(op.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(op.f(Exit.succeed(done))), elem => zipRight(core.write(elem), go(single(op.f))))));
      };
      return Exit.match(exit, cause => onDecision(done(Exit.failCause(cause))), Either.match(z => onDecision(done(Exit.succeed(z))), elem => Effect.succeed(core.flatMap(core.write(elem), () => core.flatMap(core.fromEffect(Effect.forkDaemon(pull)), leftFiber => go(both(leftFiber, fiber)))))));
    };
    const go = state => {
      switch (state._tag) {
        case MergeStateOpCodes.OP_BOTH_RUNNING:
          {
            const leftJoin = Effect.interruptible(Fiber.join(state.left));
            const rightJoin = Effect.interruptible(Fiber.join(state.right));
            return unwrap(Effect.raceWith(leftJoin, rightJoin, (leftExit, rf) => Effect.zipRight(Fiber.interrupt(rf), handleSide(leftExit, state.right, pullL)(restore(leftDone), mergeState.BothRunning, f => mergeState.LeftDone(f))), (rightExit, lf) => Effect.zipRight(Fiber.interrupt(lf), handleSide(rightExit, state.left, pullR)(restore(rightDone), (left, right) => mergeState.BothRunning(right, left), f => mergeState.RightDone(f)))));
          }
        case MergeStateOpCodes.OP_LEFT_DONE:
          {
            return unwrap(Effect.map(Effect.exit(pullR), Exit.match(cause => core.fromEffect(state.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(state.f(Exit.succeed(done))), elem => core.flatMap(core.write(elem), () => go(mergeState.LeftDone(state.f)))))));
          }
        case MergeStateOpCodes.OP_RIGHT_DONE:
          {
            return unwrap(Effect.map(Effect.exit(pullL), Exit.match(cause => core.fromEffect(state.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(state.f(Exit.succeed(done))), elem => core.flatMap(core.write(elem), () => go(mergeState.RightDone(state.f)))))));
          }
      }
    };
    return core.embedInput(input)(core.flatMap(go)(core.fromEffect(Effect.zipWith(Effect.forkDaemon(pullL), Effect.forkDaemon(pullR), (left, right) => mergeState.BothRunning(left, right)))));
  });
})(singleProducerAsyncInput.make())).traced(trace));
/** @internal */
export const never = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.fromEffect(Effect.never()).traced(trace));
/** @internal */
export const orDie = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, error) => orDieWith(self, restore(error)).traced(trace));
/** @internal */
export const orDieWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => catchAll(self, e => {
  throw restore(f)(e);
}).traced(trace));
/** @internal */
export const orElse = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => catchAll(self, that).traced(trace));
/** @internal */
export const pipeToOrFail = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.suspend(() => {
  let channelException = undefined;
  const reader = core.readWith(outElem => core.flatMap(core.write(outElem), () => reader), outErr => {
    channelException = ChannelException(outErr);
    return core.failCause(Cause.die(channelException));
  }, core.succeedNow);
  const writer = core.readWithCause(outElem => core.flatMap(() => writer)(core.write(outElem)), annotatedCause => {
    const unannotated = Cause.unannotate(annotatedCause);
    return Cause.isDieType(unannotated) && isChannelException(unannotated.defect) && Equal.equals(unannotated.defect, channelException) ? core.fail(unannotated.defect.error) : core.failCause(annotatedCause);
  }, core.succeedNow);
  return core.pipeTo(core.pipeTo(core.pipeTo(self, reader), that), writer).traced(trace);
}));
/** @internal */
export const provideService = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, tag, service) => {
  return core.flatMap(context(), context => core.provideContext(self, Context.add(context, tag, service))).traced(trace);
});
/** @internal */
export const provideLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) => unwrapScoped(Effect.map(Layer.build(layer), env => core.provideContext(self, env))).traced(trace));
/** @internal */
export const contramapContext = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => contextWithChannel(context => core.provideContext(self, restore(f)(context))).traced(trace));
/** @internal */
export const provideSomeLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) =>
// @ts-expect-error
provideLayer(self, Layer.merge(Layer.context(), layer)).traced(trace));
/** @internal */
export const read = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.readOrFail(Option.none()).traced(trace));
/** @internal */
export const repeated = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, () => repeated(self)).traced(trace));
/** @internal */
export const run = /*#__PURE__*/Debug.methodWithTrace(trace => self => Effect.scoped(executor.runScoped(self)).traced(trace));
/** @internal */
export const runCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => executor.run(core.collectElements(self)).traced(trace));
/** @internal */
export const runDrain = /*#__PURE__*/Debug.methodWithTrace(trace => self => executor.run(drain(self)).traced(trace));
/** @internal */
export const scoped = /*#__PURE__*/Debug.methodWithTrace(trace => effect => unwrap(Effect.uninterruptibleMask(restore => Effect.map(Scope.make(), scope => core.acquireReleaseOut(Effect.tapErrorCause(restore(Scope.extend(scope)(effect)), cause => Scope.close(scope, Exit.failCause(cause))), (_, exit) => Scope.close(scope, exit))))).traced(trace));
/** @internal */
export const service = /*#__PURE__*/Debug.methodWithTrace(trace => tag => core.fromEffect(tag).traced(trace));
/** @internal */
export const serviceWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => map(service(tag), restore(f)).traced(trace));
/** @internal */
export const serviceWithChannel = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => core.flatMap(service(tag), restore(f)).traced(trace));
/** @internal */
export const serviceWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => mapEffect(service(tag), restore(f)).traced(trace));
/** @internal */
export const toHub = /*#__PURE__*/Debug.methodWithTrace(trace => hub => toQueue(hub).traced(trace));
/** @internal */
export const toPull = /*#__PURE__*/Debug.methodWithTrace(trace => self => Effect.map(Effect.acquireRelease(Effect.sync(() => new executor.ChannelExecutor(self, void 0, identity)), (exec, exit) => {
  const finalize = exec.close(exit);
  return finalize === undefined ? Effect.unit() : finalize;
}), exec => Effect.suspend(() => interpretToPull(exec.run(), exec))).traced(trace));
/** @internal */
const interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case ChannelStateOpCodes.OP_DONE:
      {
        return Exit.match(exec.getDone(), Effect.failCause, done => Effect.succeed(Either.left(done)));
      }
    case ChannelStateOpCodes.OP_EMIT:
      {
        return Effect.succeed(Either.right(exec.getEmit()));
      }
    case ChannelStateOpCodes.OP_FROM_EFFECT:
      {
        return Effect.flatMap(() => interpretToPull(exec.run(), exec))(state.effect);
      }
    case ChannelStateOpCodes.OP_READ:
      {
        return executor.readUpstream(state, () => interpretToPull(exec.run(), exec), cause => Effect.failCause(cause));
      }
  }
};
/** @internal */
export const toQueue = /*#__PURE__*/Debug.methodWithTrace(trace => queue => core.suspend(() => toQueueInternal(queue)).traced(trace));
/** @internal */
const toQueueInternal = queue => {
  return core.readWithCause(elem => core.flatMap(core.fromEffect(Queue.offer(queue, Either.right(elem))), () => toQueueInternal(queue)), cause => core.fromEffect(Queue.offer(queue, Either.left(Exit.failCause(cause)))), done => core.fromEffect(Queue.offer(queue, Either.left(Exit.succeed(done)))));
};
/** @internal */
export const unwrap = /*#__PURE__*/Debug.methodWithTrace(trace => channel => flatten(core.fromEffect(channel)).traced(trace));
/** @internal */
export const unwrapScoped = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.concatAllWith(scoped(self), (d, _) => d, (d, _) => d).traced(trace));
/** @internal */
export const updateService = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => contramapContext(self, context => Context.merge(context, Context.make(tag, restore(f)(Context.unsafeGet(context, tag))))).traced(trace));
/** @internal */
export const writeAll = /*#__PURE__*/Debug.methodWithTrace(trace => (...outs) => writeChunk(Chunk.fromIterable(outs)).traced(trace));
/** @internal */
export const writeChunk = /*#__PURE__*/Debug.methodWithTrace(trace => outs => writeChunkWriter(0, outs.length, outs).traced(trace));
/** @internal */
const writeChunkWriter = (idx, len, chunk) => {
  return idx === len ? core.unit() : core.flatMap(() => writeChunkWriter(idx + 1, len, chunk))(core.write(Chunk.unsafeGet(idx)(chunk)));
};
/** @internal */
export const zip = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, a => map(b => [a, b])(that)).traced(trace));
/** @internal */
export const zipLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, z => as(that, z)).traced(trace));
/** @internal */
export const zipRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, () => that).traced(trace));
/** @internal */
export const zipPar = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => mergeWith(self, that, exit1 => mergeDecision.Await(exit2 => Effect.done(Exit.zip(exit1, exit2))), exit2 => mergeDecision.Await(exit1 => Effect.done(Exit.zip(exit1, exit2)))).traced(trace));
/** @internal */
export const zipParLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => map(zipPar(self, that), tuple => tuple[0]).traced(trace));
/** @internal */
export const zipParRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => map(zipPar(self, that), tuple => tuple[1]).traced(trace));
/** @internal */
export const ChannelExceptionTypeId = /*#__PURE__*/Symbol.for("@effect/stream/Channel/errors/ChannelException");
/** @internal */
export const ChannelException = error => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error
});
/** @internal */
export const isChannelException = u => typeof u === "object" && u != null && ChannelExceptionTypeId in u;
//# sourceMappingURL=channel.mjs.map