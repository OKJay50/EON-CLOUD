import * as Chunk from "@effect/data/Chunk";
import * as Debug from "@effect/data/Debug";
import * as Either from "@effect/data/Either";
import { constVoid, identity } from "@effect/data/Function";
import * as Option from "@effect/data/Option";
import * as Cause from "@effect/io/Cause";
import * as childExecutorDecision from "@effect/stream/internal/channel/childExecutorDecision";
import { ContinuationKImpl } from "@effect/stream/internal/channel/continuation";
import * as upstreamPullStrategy from "@effect/stream/internal/channel/upstreamPullStrategy";
import * as OpCodes from "@effect/stream/internal/opCodes/channel";
/** @internal */
const ChannelSymbolKey = "@effect/stream/Channel";
/** @internal */
export const ChannelTypeId = /*#__PURE__*/Symbol.for(ChannelSymbolKey);
/** @internal */
const channelVariance = {
  _Env: _ => _,
  _InErr: _ => _,
  _InElem: _ => _,
  _InDone: _ => _,
  _OutErr: _ => _,
  _OutElem: _ => _,
  _OutDone: _ => _
};
/** @internal */
const proto = {
  [ChannelTypeId]: channelVariance,
  traced(trace) {
    if (trace) {
      return Object.create(proto, {
        _tag: {
          value: OpCodes.OP_TRACED
        },
        channel: {
          value: this
        },
        trace: {
          value: trace
        }
      });
    }
    return this;
  }
};
/** @internal */
export const acquireReleaseOut = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, release) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = restore(release);
  return op.traced(trace);
});
/** @internal */
export const catchAllCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FOLD;
  op.channel = self;
  op.k = new ContinuationKImpl(succeed, restore(f));
  return op.traced(trace);
});
/** @internal */
export const collectElements = /*#__PURE__*/Debug.methodWithTrace(trace => self => {
  return suspend(() => {
    const builder = [];
    return flatMap(pipeTo(self, collectElementsReader(builder)), value => sync(() => [Chunk.fromIterable(builder), value]));
  }).traced(trace);
});
/** @internal */
const collectElementsReader = builder => {
  return readWith(outElem => flatMap(sync(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)), fail, succeedNow);
};
/** @internal */
export const concatAll = /*#__PURE__*/Debug.methodWithTrace(trace => channels => concatAllWith(channels, constVoid, constVoid).traced(trace));
/** @internal */
export const concatAllWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (channels, f, g) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_CONCAT_ALL;
  op.combineInners = restore(f);
  op.combineAll = restore(g);
  op.onPull = () => upstreamPullStrategy.PullAfterNext(Option.none());
  op.onEmit = () => childExecutorDecision.Continue;
  op.value = () => channels;
  op.k = identity;
  return op.traced(trace);
});
/** @internal */
export const concatMapWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, g, h) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_CONCAT_ALL;
  op.combineInners = restore(g);
  op.combineAll = restore(h);
  op.onPull = () => upstreamPullStrategy.PullAfterNext(Option.none());
  op.onEmit = () => childExecutorDecision.Continue;
  op.value = () => self;
  op.k = restore(f);
  return op.traced(trace);
});
/** @internal */
export const concatMapWithCustom = /*#__PURE__*/Debug.dualWithTrace(6, (trace, restore) => (self, f, g, h, onPull, onEmit) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_CONCAT_ALL;
  op.combineInners = restore(g);
  op.combineAll = restore(h);
  op.onPull = restore(onPull);
  op.onEmit = restore(onEmit);
  op.value = () => self;
  op.k = restore(f);
  return op.traced(trace);
});
/** @internal */
export const embedInput = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, input) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op.traced(trace);
});
/** @internal */
export const ensuringWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, finalizer) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_ENSURING;
  op.channel = self;
  op.finalizer = restore(finalizer);
  return op.traced(trace);
});
/** @internal */
export const fail = /*#__PURE__*/Debug.methodWithTrace(trace => error => failCause(Cause.fail(error)).traced(trace));
/** @internal */
export const failSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => failCauseSync(() => Cause.fail(restore(evaluate)())).traced(trace));
/** @internal */
export const failCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => failCauseSync(() => cause).traced(trace));
/** @internal */
export const failCauseSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FAIL;
  op.error = restore(evaluate);
  return op.traced(trace);
});
/** @internal */
export const flatMap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FOLD;
  op.channel = self;
  op.k = new ContinuationKImpl(restore(f), failCause);
  return op.traced(trace);
});
/** @internal */
export const foldCauseChannel = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onError, onSuccess) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FOLD;
  op.channel = self;
  op.k = new ContinuationKImpl(restore(onSuccess), restore(onError));
  return op.traced(trace);
});
/** @internal */
export const fromEffect = /*#__PURE__*/Debug.methodWithTrace(trace => effect => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FROM_EFFECT;
  op.effect = () => effect;
  return op.traced(trace);
});
/** @internal */
export const pipeTo = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op.traced(trace);
});
/** @internal */
export const provideContext = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, env) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_PROVIDE;
  op.context = () => env;
  op.inner = self;
  return op.traced(trace);
});
/** @internal */
export const readOrFail = /*#__PURE__*/Debug.methodWithTrace(trace => error => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_READ;
  op.more = succeed;
  op.done = new ContinuationKImpl(() => fail(error), () => fail(error));
  return op.traced(trace);
});
/** @internal */
export const readWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (input, error, done) => readWithCause(restore(input), cause => Either.match(Cause.failureOrCause(cause), restore(error), failCause), restore(done)));
/** @internal */
export const readWithCause = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (input, halt, done) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_READ;
  op.more = restore(input);
  op.done = new ContinuationKImpl(restore(done), restore(halt));
  return op.traced(trace);
});
/** @internal */
export const succeed = /*#__PURE__*/Debug.methodWithTrace(trace => value => sync(() => value).traced(trace));
/** @internal */
export const succeedNow = /*#__PURE__*/Debug.methodWithTrace(trace => result => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_SUCCEED_NOW;
  op.terminal = result;
  return op.traced(trace);
});
/** @internal */
export const suspend = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_SUSPEND;
  op.channel = restore(evaluate);
  return op.traced(trace);
});
export const sync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_SUCCEED;
  op.evaluate = restore(evaluate);
  return op.traced(trace);
});
/** @internal */
export const unit = /*#__PURE__*/Debug.methodWithTrace(trace => () => succeedNow(void 0).traced(trace));
/** @internal */
export const write = /*#__PURE__*/Debug.methodWithTrace(trace => out => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_EMIT;
  op.out = out;
  return op.traced(trace);
});
//# sourceMappingURL=core.mjs.map