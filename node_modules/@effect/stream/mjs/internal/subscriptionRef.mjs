var _a, _b, _c;
import { bodyWithTrace, dualWithTrace, methodWithTrace } from "@effect/data/Debug";
import * as Effect from "@effect/io/Effect";
import * as Hub from "@effect/io/Hub";
import * as _circular from "@effect/io/internal_effect_untraced/effect/circular";
import * as _ref from "@effect/io/internal_effect_untraced/ref";
import * as Ref from "@effect/io/Ref";
import * as Synchronized from "@effect/io/Ref/Synchronized";
import * as stream from "@effect/stream/internal/stream";
/** @internal */
const SubscriptionRefSymbolKey = "@effect/stream/SubscriptionRef";
/** @internal */
export const SubscriptionRefTypeId = /*#__PURE__*/Symbol.for(SubscriptionRefSymbolKey);
/** @internal */
const subscriptionRefVariance = {
  _A: _ => _
};
/** @internal */
class SubscriptionRefImpl {
  constructor(ref, hub, semaphore) {
    this.ref = ref;
    this.hub = hub;
    this.semaphore = semaphore;
    this[_a] = _ref.refVariance;
    this[_b] = _circular.synchronizedVariance;
    this[_c] = subscriptionRefVariance;
  }
  get changes() {
    return stream.unwrapScoped(this.semaphore.withPermits(1)(Effect.flatMap(a => Effect.map(s => stream.concat(s)(stream.make(a)))(stream.fromHubScoped(this.hub)))(Ref.get(this.ref))));
  }
  /** @macro traced */
  modify(f) {
    return bodyWithTrace(trace => this.modifyEffect(a => Effect.succeed(f(a))).traced(trace));
  }
  /** @macro traced */
  modifyEffect(f) {
    return bodyWithTrace(trace => this.semaphore.withPermits(1)(Effect.flatMap(([b, a]) => Effect.zipLeft(Hub.publish(this.hub, a))(Effect.as(b)(Ref.set(this.ref, a))))(Effect.flatMap(f)(Ref.get(this.ref)))).traced(trace));
  }
}
_a = Ref.RefTypeId, _b = Synchronized.SynchronizedTypeId, _c = SubscriptionRefTypeId;
/** @internal */
export const get = /*#__PURE__*/methodWithTrace(trace => self => Ref.get(self.ref).traced(trace));
/** @internal */
export const make = /*#__PURE__*/methodWithTrace(trace => value => Effect.map(([hub, ref, semaphore]) => new SubscriptionRefImpl(ref, hub, semaphore))(Effect.all(Hub.unbounded(), Ref.make(value), Effect.makeSemaphore(1))).traced(trace));
/** @internal */
export const modify = /*#__PURE__*/dualWithTrace(2, trace => (self, f) => self.modify(f).traced(trace));
/** @internal */
export const modifyEffect = /*#__PURE__*/dualWithTrace(2, trace => (self, f) => self.modifyEffect(f).traced(trace));
/** @internal */
export const set = /*#__PURE__*/dualWithTrace(2, trace => (self, value) => self.semaphore.withPermits(1)(Effect.zipLeft(Hub.publish(self.hub, value))(Ref.set(self.ref, value))).traced(trace));
//# sourceMappingURL=subscriptionRef.mjs.map