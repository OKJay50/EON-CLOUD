import { bodyWithTrace } from "@effect/data/Debug";
import * as Effect from "@effect/io/Effect";
import * as Exit from "@effect/io/Exit";
/** @internal */
export const OP_PULL_FROM_CHILD = "PullFromChild";
/** @internal */
export const OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
/** @internal */
export const OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
/** @internal */
export const OP_EMIT = "Emit";
/**
 * Execute the `childExecutor` and on each emitted value, decide what to do by
 * `onEmit`.
 *
 * @internal
 */
export class PullFromChild {
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
    this._tag = OP_PULL_FROM_CHILD;
  }
  close(exit) {
    return bodyWithTrace(trace => {
      const fin1 = this.childExecutor.close(exit);
      const fin2 = this.parentSubexecutor.close(exit);
      if (fin1 !== undefined && fin2 !== undefined) {
        return Effect.zipWith(Effect.exit(fin2), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(Effect.exit(fin1)).traced(trace);
      } else if (fin1 !== undefined) {
        return fin1.traced(trace);
      } else if (fin2 !== undefined) {
        return fin2.traced(trace);
      } else {
        return undefined;
      }
    });
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}
/**
 * Execute `upstreamExecutor` and for each emitted element, spawn a child
 * channel and continue with processing it by `PullFromChild`.
 *
 * @internal
 */
export class PullFromUpstream {
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
    this._tag = OP_PULL_FROM_UPSTREAM;
  }
  close(exit) {
    return bodyWithTrace(trace => {
      const fin1 = this.upstreamExecutor.close(exit);
      const fins = [...this.activeChildExecutors.map(child => child !== undefined ? child.childExecutor.close(exit) : undefined), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== undefined && next !== undefined) {
          return Effect.zipWith(Effect.exit(next), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(acc);
        } else if (acc !== undefined) {
          return acc;
        } else if (next !== undefined) {
          return Effect.exit(next);
        } else {
          return undefined;
        }
      }, undefined);
      return result === undefined ? result : result.traced(trace);
    });
  }
  enqueuePullFromChild(child) {
    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
}
/**
 * Transformed from `PullFromUpstream` when upstream has finished but there
 * are still active child executors.
 *
 * @internal
 */
export class DrainChildExecutors {
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this._tag = OP_DRAIN_CHILD_EXECUTORS;
  }
  close(exit) {
    return bodyWithTrace(trace => {
      const fin1 = this.upstreamExecutor.close(exit);
      const fins = [...this.activeChildExecutors.map(child => child !== undefined ? child.childExecutor.close(exit) : undefined), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== undefined && next !== undefined) {
          return Effect.zipWith(Effect.exit(next), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(acc);
        } else if (acc !== undefined) {
          return acc;
        } else if (next !== undefined) {
          return Effect.exit(next);
        } else {
          return undefined;
        }
      }, undefined);
      return result === undefined ? result : result.traced(trace);
    });
  }
  enqueuePullFromChild(child) {
    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
}
/** @internal */
export class Emit {
  constructor(value, next) {
    this.value = value;
    this.next = next;
    this._tag = OP_EMIT;
  }
  close(exit) {
    return bodyWithTrace(trace => {
      const result = this.next.close(exit);
      return result === undefined ? result : result.traced(trace);
    });
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}
//# sourceMappingURL=subexecutor.mjs.map