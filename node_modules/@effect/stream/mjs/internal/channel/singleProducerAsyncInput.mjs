import { bodyWithTrace, methodWithTrace } from "@effect/data/Debug";
import * as Either from "@effect/data/Either";
import * as Cause from "@effect/io/Cause";
import * as Deferred from "@effect/io/Deferred";
import * as Effect from "@effect/io/Effect";
import * as Exit from "@effect/io/Exit";
import * as Ref from "@effect/io/Ref";
/** @internal */
const OP_STATE_EMPTY = "Empty";
/** @internal */
const OP_STATE_EMIT = "Emit";
/** @internal */
const OP_STATE_ERROR = "Error";
/** @internal */
const OP_STATE_DONE = "Done";
/** @internal */
const stateEmpty = notifyProducer => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
/** @internal */
const stateEmit = notifyConsumers => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
/** @internal */
const stateError = cause => ({
  _tag: OP_STATE_ERROR,
  cause
});
/** @internal */
const stateDone = done => ({
  _tag: OP_STATE_DONE,
  done
});
/** @internal */
class SingleProducerAsyncInputImpl {
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return bodyWithTrace(trace => {
      return Effect.flatten(Ref.modify(this.ref, state => state._tag === OP_STATE_EMPTY ? [Deferred.await(state.notifyProducer), state] : [Effect.unit(), state])).traced(trace);
    });
  }
  close() {
    return bodyWithTrace(trace => {
      return Effect.fiberIdWith(fiberId => this.error(Cause.interrupt(fiberId))).traced(trace);
    });
  }
  done(value) {
    return bodyWithTrace(trace => {
      return Effect.flatten(Ref.modify(this.ref, state => {
        switch (state._tag) {
          case OP_STATE_EMPTY:
            {
              return [Deferred.await(state.notifyProducer), state];
            }
          case OP_STATE_EMIT:
            {
              return [Effect.forEachDiscard(deferred => Deferred.succeed(deferred, Either.left(value)))(state.notifyConsumers), stateDone(value)];
            }
          case OP_STATE_ERROR:
            {
              return [Effect.interrupt(), state];
            }
          case OP_STATE_DONE:
            {
              return [Effect.interrupt(), state];
            }
        }
      })).traced(trace);
    });
  }
  emit(element) {
    return bodyWithTrace(trace => {
      return Effect.flatMap(deferred => Effect.flatten(Ref.modify(this.ref, state => {
        switch (state._tag) {
          case OP_STATE_EMPTY:
            {
              return [Deferred.await(state.notifyProducer), state];
            }
          case OP_STATE_EMIT:
            {
              const notifyConsumer = state.notifyConsumers[0];
              const notifyConsumers = state.notifyConsumers.slice(1);
              if (notifyConsumer !== undefined) {
                return [Deferred.succeed(notifyConsumer, Either.right(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
              }
              throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! Please report an issue at https://github.com/Effect-TS/stream/issues");
            }
          case OP_STATE_ERROR:
            {
              return [Effect.interrupt(), state];
            }
          case OP_STATE_DONE:
            {
              return [Effect.interrupt(), state];
            }
        }
      })))(Deferred.make()).traced(trace);
    });
  }
  error(cause) {
    return bodyWithTrace(trace => {
      return Effect.flatten(Ref.modify(this.ref, state => {
        switch (state._tag) {
          case OP_STATE_EMPTY:
            {
              return [Deferred.await(state.notifyProducer), state];
            }
          case OP_STATE_EMIT:
            {
              return [Effect.forEachDiscard(state.notifyConsumers, deferred => Deferred.failCause(deferred, cause)), stateError(cause)];
            }
          case OP_STATE_ERROR:
            {
              return [Effect.interrupt(), state];
            }
          case OP_STATE_DONE:
            {
              return [Effect.interrupt(), state];
            }
        }
      })).traced(trace);
    });
  }
  take() {
    return bodyWithTrace(trace => {
      return this.takeWith(cause => Exit.failCause(Cause.map(cause, Either.left)), elem => Exit.succeed(elem), done => Exit.fail(Either.right(done))).traced(trace);
    });
  }
  takeWith(onError, onElement, onDone) {
    return bodyWithTrace(trace => {
      return Effect.flatMap(deferred => Effect.flatten(Ref.modify(this.ref, state => {
        switch (state._tag) {
          case OP_STATE_EMPTY:
            {
              return [Effect.zipRight(Deferred.succeed(state.notifyProducer, void 0), Effect.matchCause(Deferred.await(deferred), onError, Either.match(onDone, onElement))), stateEmit([deferred])];
            }
          case OP_STATE_EMIT:
            {
              return [Effect.matchCause(Deferred.await(deferred), onError, Either.match(onDone, onElement)), stateEmit([...state.notifyConsumers, deferred])];
            }
          case OP_STATE_ERROR:
            {
              return [Effect.succeed(onError(state.cause)), state];
            }
          case OP_STATE_DONE:
            {
              return [Effect.succeed(onDone(state.done)), state];
            }
        }
      })))(Deferred.make()).traced(trace);
    });
  }
}
/** @internal */
export const make = /*#__PURE__*/methodWithTrace(trace => () => Effect.map(ref => new SingleProducerAsyncInputImpl(ref))(Effect.flatMap(deferred => Ref.make(stateEmpty(deferred)))(Deferred.make())).traced(trace));
//# sourceMappingURL=singleProducerAsyncInput.mjs.map