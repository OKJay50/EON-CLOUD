"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapError = exports.mapEffect = exports.map = exports.logWarningCauseMessage = exports.logWarningCause = exports.logWarning = exports.logTraceCauseMessage = exports.logTraceCause = exports.logTrace = exports.logInfoCauseMessage = exports.logInfoCause = exports.logInfo = exports.logFatalCauseMessage = exports.logFatalCause = exports.logFatal = exports.logErrorCauseMessage = exports.logErrorCause = exports.logError = exports.logDebugCauseMessage = exports.logDebugCause = exports.logDebug = exports.log = exports.leftover = exports.last = exports.ignoreLeftover = exports.head = exports.fromQueueWithShutdown = exports.fromQueue = exports.fromPush = exports.fromHubWithShutdown = exports.fromHub = exports.fromEffect = exports.fromChannel = exports.forEachWhile = exports.forEachChunkWhile = exports.forEachChunk = exports.forEach = exports.foldWeightedEffect = exports.foldWeightedDecomposeEffect = exports.foldWeightedDecompose = exports.foldWeighted = exports.foldUntilEffect = exports.foldUntil = exports.foldSink = exports.foldLeftEffect = exports.foldLeftChunksEffect = exports.foldLeftChunks = exports.foldLeft = exports.foldEffect = exports.foldChunksEffect = exports.foldChunks = exports.fold = exports.flatMap = exports.findEffect = exports.filterInputEffect = exports.filterInput = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.every = exports.ensuringWith = exports.ensuring = exports.dropWhileEffect = exports.dropWhile = exports.dropUntilEffect = exports.dropUntil = exports.drop = exports.drain = exports.dimapEffect = exports.dimapChunksEffect = exports.dimapChunks = exports.dimap = exports.dieSync = exports.dieMessage = exports.die = exports.count = exports.contramapEffect = exports.contramapChunksEffect = exports.contramapChunks = exports.contramap = exports.contextWithSink = exports.contextWithEffect = exports.contextWith = exports.context = exports.collectLeftover = exports.collectAllWhileWith = exports.collectAllWhileEffect = exports.collectAllWhile = exports.collectAllUntilEffect = exports.collectAllUntil = exports.collectAllToSetN = exports.collectAllToSet = exports.collectAllToMapN = exports.collectAllToMap = exports.collectAllN = exports.collectAllFrom = exports.collectAll = exports.as = exports.SinkTypeId = void 0;
exports.zipWithPar = exports.zipWith = exports.zipRight = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeft = exports.zip = exports.withDuration = exports.unwrapScoped = exports.unwrap = exports.timed = exports.take = exports.sync = exports.suspend = exports.summarized = exports.sum = exports.succeed = exports.splitWhere = exports.some = exports.refineOrDieWith = exports.refineOrDie = exports.raceWithCapacity = exports.raceWith = exports.raceBothCapacity = exports.raceBoth = exports.race = exports.provideContext = exports.orElse = exports.never = exports.mkString = exports.mapLeftover = void 0;
var internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/stream/internal/sink"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 * @category symbols
 */
const SinkTypeId = internal.SinkTypeId;
/**
 * Replaces this sink's result with the provided value.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.SinkTypeId = SinkTypeId;
const as = internal.as;
/**
 * A sink that collects all elements into a `Chunk`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.as = as;
const collectAll = internal.collectAll;
/**
 * A sink that collects first `n` elements into a chunk.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAll = collectAll;
const collectAllN = internal.collectAllN;
/**
 * Repeatedly runs the sink and accumulates its results into a `Chunk`.
 *
 * @since 1.0.0
 * @category utils
 */
exports.collectAllN = collectAllN;
const collectAllFrom = internal.collectAllFrom;
/**
 * A sink that collects all of its inputs into a map. The keys are extracted
 * from inputs using the keying function `key`; if multiple inputs use the
 * same key, they are merged using the `merge` function.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAllFrom = collectAllFrom;
const collectAllToMap = internal.collectAllToMap;
/**
 * A sink that collects first `n` keys into a map. The keys are calculated
 * from inputs using the keying function `key`; if multiple inputs use the the
 * same key, they are merged using the `merge` function.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAllToMap = collectAllToMap;
const collectAllToMapN = internal.collectAllToMapN;
/**
 * A sink that collects all of its inputs into a set.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAllToMapN = collectAllToMapN;
const collectAllToSet = internal.collectAllToSet;
/**
 * A sink that collects first `n` distinct inputs into a set.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAllToSet = collectAllToSet;
const collectAllToSetN = internal.collectAllToSetN;
/**
 * Accumulates incoming elements into a chunk until predicate `p` is
 * satisfied.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAllToSetN = collectAllToSetN;
const collectAllUntil = internal.collectAllUntil;
/**
 * Accumulates incoming elements into a chunk until effectful predicate `p` is
 * satisfied.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAllUntil = collectAllUntil;
const collectAllUntilEffect = internal.collectAllUntilEffect;
/**
 * Accumulates incoming elements into a chunk as long as they verify predicate
 * `p`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAllUntilEffect = collectAllUntilEffect;
const collectAllWhile = internal.collectAllWhile;
/**
 * Accumulates incoming elements into a chunk as long as they verify effectful
 * predicate `p`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.collectAllWhile = collectAllWhile;
const collectAllWhileEffect = internal.collectAllWhileEffect;
/**
 * Repeatedly runs the sink for as long as its results satisfy the predicate
 * `p`. The sink's results will be accumulated using the stepping function `f`.
 *
 * @since 1.0.0
 * @category utils
 */
exports.collectAllWhileEffect = collectAllWhileEffect;
const collectAllWhileWith = internal.collectAllWhileWith;
/**
 * Collects the leftovers from the stream when the sink succeeds and returns
 * them as part of the sink's result.
 *
 * @since 1.0.0
 * @category utils
 */
exports.collectAllWhileWith = collectAllWhileWith;
const collectLeftover = internal.collectLeftover;
/**
 * Transforms this sink's input elements.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.collectLeftover = collectLeftover;
const contramap = internal.contramap;
/**
 * Effectfully transforms this sink's input elements.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.contramap = contramap;
const contramapEffect = internal.contramapEffect;
/**
 * Transforms this sink's input chunks. `f` must preserve chunking-invariance.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.contramapEffect = contramapEffect;
const contramapChunks = internal.contramapChunks;
/**
 * Effectfully transforms this sink's input chunks. `f` must preserve
 * chunking-invariance.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.contramapChunks = contramapChunks;
const contramapChunksEffect = internal.contramapChunksEffect;
/**
 * A sink that counts the number of elements fed to it.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.contramapChunksEffect = contramapChunksEffect;
const count = internal.count;
/**
 * Creates a sink halting with the specified defect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.count = count;
const die = internal.die;
/**
 * Creates a sink halting with the specified message, wrapped in a
 * `RuntimeException`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.die = die;
const dieMessage = internal.dieMessage;
/**
 * Creates a sink halting with the specified defect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.dieMessage = dieMessage;
const dieSync = internal.dieSync;
/**
 * Transforms both inputs and result of this sink using the provided
 * functions.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.dieSync = dieSync;
const dimap = internal.dimap;
/**
 * Effectfully transforms both inputs and result of this sink using the
 * provided functions.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.dimap = dimap;
const dimapEffect = internal.dimapEffect;
/**
 * Transforms both input chunks and result of this sink using the provided
 * functions.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.dimapEffect = dimapEffect;
const dimapChunks = internal.dimapChunks;
/**
 * Effectfully transforms both input chunks and result of this sink using the
 * provided functions. `f` and `g` must preserve chunking-invariance.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.dimapChunks = dimapChunks;
const dimapChunksEffect = internal.dimapChunksEffect;
/**
 * A sink that ignores its inputs.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.dimapChunksEffect = dimapChunksEffect;
const drain = internal.drain;
/**
 * Creates a sink that drops `n` elements.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.drain = drain;
const drop = internal.drop;
/**
 * Drops incoming elements until the predicate is satisfied.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.drop = drop;
const dropUntil = internal.dropUntil;
/**
 * Drops incoming elements until the effectful predicate is satisfied.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.dropUntil = dropUntil;
const dropUntilEffect = internal.dropUntilEffect;
/**
 * Drops incoming elements as long as the predicate is satisfied.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.dropUntilEffect = dropUntilEffect;
const dropWhile = internal.dropWhile;
/**
 * Drops incoming elements as long as the effectful predicate is satisfied.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.dropWhile = dropWhile;
const dropWhileEffect = internal.dropWhileEffect;
/**
 * Returns a new sink with an attached finalizer. The finalizer is guaranteed
 * to be executed so long as the sink begins execution (and regardless of
 * whether or not it completes).
 *
 * @since 1.0.0
 * @category finalization
 */
exports.dropWhileEffect = dropWhileEffect;
const ensuring = internal.ensuring;
/**
 * Returns a new sink with an attached finalizer. The finalizer is guaranteed
 * to be executed so long as the sink begins execution (and regardless of
 * whether or not it completes).
 *
 * @since 1.0.0
 * @category finalization
 */
exports.ensuring = ensuring;
const ensuringWith = internal.ensuringWith;
/**
 * Accesses the whole context of the sink.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.ensuringWith = ensuringWith;
const context = internal.context;
/**
 * Accesses the context of the sink.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.context = context;
const contextWith = internal.contextWith;
/**
 * Accesses the context of the sink in the context of an effect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.contextWith = contextWith;
const contextWithEffect = internal.contextWithEffect;
/**
 * Accesses the context of the sink in the context of a sink.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.contextWithEffect = contextWithEffect;
const contextWithSink = internal.contextWithSink;
/**
 * A sink that returns whether all elements satisfy the specified predicate.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.contextWithSink = contextWithSink;
const every = internal.every;
/**
 * A sink that always fails with the specified error.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.every = every;
const fail = internal.fail;
/**
 * A sink that always fails with the specified lazily evaluated error.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fail = fail;
const failSync = internal.failSync;
/**
 * Creates a sink halting with a specified `Cause`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.failSync = failSync;
const failCause = internal.failCause;
/**
 * Creates a sink halting with a specified lazily evaluated `Cause`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.failCause = failCause;
const failCauseSync = internal.failCauseSync;
/**
 * Filters the sink's input with the given predicate.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.failCauseSync = failCauseSync;
const filterInput = internal.filterInput;
/**
 * Effectfully filter the input of this sink using the specified predicate.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.filterInput = filterInput;
const filterInputEffect = internal.filterInputEffect;
/**
 * Creates a sink that produces values until one verifies the predicate `f`.
 *
 * @since 1.0.0
 * @category elements
 */
exports.filterInputEffect = filterInputEffect;
const findEffect = internal.findEffect;
/**
 * A sink that folds its inputs with the provided function, termination
 * predicate and initial state.
 *
 * @since 1.0.0
 * @category folding
 */
exports.findEffect = findEffect;
const fold = internal.fold;
/**
 * Folds over the result of the sink
 *
 * @since 1.0.0
 * @category folding
 */
exports.fold = fold;
const foldSink = internal.foldSink;
/**
 * A sink that folds its input chunks with the provided function, termination
 * predicate and initial state. `contFn` condition is checked only for the
 * initial value and at the end of processing of each chunk. `f` and `contFn`
 * must preserve chunking-invariance.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldSink = foldSink;
const foldChunks = internal.foldChunks;
/**
 * A sink that effectfully folds its input chunks with the provided function,
 * termination predicate and initial state. `contFn` condition is checked only
 * for the initial value and at the end of processing of each chunk. `f` and
 * `contFn` must preserve chunking-invariance.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldChunks = foldChunks;
const foldChunksEffect = internal.foldChunksEffect;
/**
 * A sink that effectfully folds its inputs with the provided function,
 * termination predicate and initial state.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldChunksEffect = foldChunksEffect;
const foldEffect = internal.foldEffect;
/**
 * A sink that folds its inputs with the provided function and initial state.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldEffect = foldEffect;
const foldLeft = internal.foldLeft;
/**
 * A sink that folds its input chunks with the provided function and initial
 * state. `f` must preserve chunking-invariance.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldLeft = foldLeft;
const foldLeftChunks = internal.foldLeftChunks;
/**
 * A sink that effectfully folds its input chunks with the provided function
 * and initial state. `f` must preserve chunking-invariance.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldLeftChunks = foldLeftChunks;
const foldLeftChunksEffect = internal.foldLeftChunksEffect;
/**
 * A sink that effectfully folds its inputs with the provided function and
 * initial state.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldLeftChunksEffect = foldLeftChunksEffect;
const foldLeftEffect = internal.foldLeftEffect;
/**
 * Creates a sink that folds elements of type `In` into a structure of type
 * `S` until `max` elements have been folded.
 *
 * Like `Sink.foldWeighted`, but with a constant cost function of `1`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldLeftEffect = foldLeftEffect;
const foldUntil = internal.foldUntil;
/**
 * Creates a sink that effectfully folds elements of type `In` into a
 * structure of type `S` until `max` elements have been folded.
 *
 * Like `Sink.foldWeightedEffect` but with a constant cost function of `1`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldUntil = foldUntil;
const foldUntilEffect = internal.foldUntilEffect;
/**
 * Creates a sink that folds elements of type `In` into a structure of type
 * `S`, until `max` worth of elements (determined by the `costFn`) have been
 * folded.
 *
 * @note
 *   Elements that have an individual cost larger than `max` will force the
 *   sink to cross the `max` cost. See `Sink.foldWeightedDecompose` for a
 *   variant that can handle these cases.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldUntilEffect = foldUntilEffect;
const foldWeighted = internal.foldWeighted;
/**
 * Creates a sink that folds elements of type `In` into a structure of type
 * `S`, until `max` worth of elements (determined by the `costFn`) have been
 * folded.
 *
 * The `decompose` function will be used for decomposing elements that cause
 * an `S` aggregate to cross `max` into smaller elements. For example:
 *
 * ```ts
 * pipe(
 *   Stream.make(1, 5, 1),
 *   Stream.transduce(
 *     Sink.foldWeightedDecompose(
 *       Chunk.empty<number>(),
 *       4,
 *       (n: number) => n,
 *       (n: number) => Chunk.make(n - 1, 1),
 *       (acc, el) => pipe(acc, Chunk.append(el))
 *     )
 *   ),
 *   Stream.runCollect
 * )
 * ```
 *
 * The stream would emit the elements `Chunk(1), Chunk(4), Chunk(1, 1)`.
 *
 * Be vigilant with this function, it has to generate "simpler" values or the
 * fold may never end. A value is considered indivisible if `decompose` yields
 * the empty chunk or a single-valued chunk. In these cases, there is no other
 * choice than to yield a value that will cross the threshold.
 *
 * `Sink.foldWeightedDecomposeEffect` allows the decompose function to return an
 * effect value, and consequently it allows the sink to fail.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldWeighted = foldWeighted;
const foldWeightedDecompose = internal.foldWeightedDecompose;
/**
 * Creates a sink that effectfully folds elements of type `In` into a
 * structure of type `S`, until `max` worth of elements (determined by the
 * `costFn`) have been folded.
 *
 * The `decompose` function will be used for decomposing elements that cause
 * an `S` aggregate to cross `max` into smaller elements. Be vigilant with
 * this function, it has to generate "simpler" values or the fold may never
 * end. A value is considered indivisible if `decompose` yields the empty
 * chunk or a single-valued chunk. In these cases, there is no other choice
 * than to yield a value that will cross the threshold.
 *
 * See `Sink.foldWeightedDecompose` for an example.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldWeightedDecompose = foldWeightedDecompose;
const foldWeightedDecomposeEffect = internal.foldWeightedDecomposeEffect;
/**
 * Creates a sink that effectfully folds elements of type `In` into a
 * structure of type `S`, until `max` worth of elements (determined by the
 * `costFn`) have been folded.
 *
 * @note
 *   Elements that have an individual cost larger than `max` will force the
 *   sink to cross the `max` cost. See `Sink.foldWeightedDecomposeEffect` for
 *   a variant that can handle these cases.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldWeightedDecomposeEffect = foldWeightedDecomposeEffect;
const foldWeightedEffect = internal.foldWeightedEffect;
/**
 * A sink that executes the provided effectful function for every element fed
 * to it.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.foldWeightedEffect = foldWeightedEffect;
const forEach = internal.forEach;
/**
 * A sink that executes the provided effectful function for every chunk fed to
 * it.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.forEach = forEach;
const forEachChunk = internal.forEachChunk;
/**
 * A sink that executes the provided effectful function for every chunk fed to
 * it until `f` evaluates to `false`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.forEachChunk = forEachChunk;
const forEachChunkWhile = internal.forEachChunkWhile;
/**
 * A sink that executes the provided effectful function for every element fed
 * to it until `f` evaluates to `false`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.forEachChunkWhile = forEachChunkWhile;
const forEachWhile = internal.forEachWhile;
/**
 * Runs this sink until it yields a result, then uses that result to create
 * another sink from the provided function which will continue to run until it
 * yields a result.
 *
 * This function essentially runs sinks in sequence.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.forEachWhile = forEachWhile;
const flatMap = internal.flatMap;
/**
 * Creates a sink from a `Channel`.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.flatMap = flatMap;
const fromChannel = internal.fromChannel;
/**
 * Creates a single-value sink produced from an effect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromChannel = fromChannel;
const fromEffect = internal.fromEffect;
/**
 * Create a sink which publishes each element to the specified hub.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromEffect = fromEffect;
const fromHub = internal.fromHub;
/**
 * Create a sink which publishes each element to the specified hub. The hub
 * will be shutdown once the stream is closed.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromHub = fromHub;
const fromHubWithShutdown = internal.fromHubWithShutdown;
/**
 * Creates a sink from a chunk processing function.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromHubWithShutdown = fromHubWithShutdown;
const fromPush = internal.fromPush;
/**
 * Create a sink which enqueues each element into the specified queue.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromPush = fromPush;
const fromQueue = internal.fromQueue;
/**
 * Create a sink which enqueues each element into the specified queue. The
 * queue will be shutdown once the stream is closed.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromQueue = fromQueue;
const fromQueueWithShutdown = internal.fromQueueWithShutdown;
/**
 * Creates a sink containing the first value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.fromQueueWithShutdown = fromQueueWithShutdown;
const head = internal.head;
/**
 * Drains the remaining elements from the stream after the sink finishes
 *
 * @since 1.0.0
 * @category utils
 */
exports.head = head;
const ignoreLeftover = internal.ignoreLeftover;
/**
 * Creates a sink containing the last value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.ignoreLeftover = ignoreLeftover;
const last = internal.last;
/**
 * Creates a sink that does not consume any input but provides the given chunk
 * as its leftovers
 *
 * @since 1.0.0
 * @category constructors
 */
exports.last = last;
const leftover = internal.leftover;
/**
 * Logs the specified message at the current log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.leftover = leftover;
const log = internal.log;
/**
 * Logs the specified message at the debug log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.log = log;
const logDebug = internal.logDebug;
/**
 * Logs the specified `Cause` at the debug log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logDebug = logDebug;
const logDebugCause = internal.logDebugCause;
/**
 * Logs the specified message and `Cause` at the debug log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logDebugCause = logDebugCause;
const logDebugCauseMessage = internal.logDebugCauseMessage;
/**
 * Logs the specified message at the error log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logDebugCauseMessage = logDebugCauseMessage;
const logError = internal.logError;
/**
 * Logs the specified `Cause` at the error log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logError = logError;
const logErrorCause = internal.logErrorCause;
/**
 * Logs the specified message and `Cause` at the error log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logErrorCause = logErrorCause;
const logErrorCauseMessage = internal.logErrorCauseMessage;
/**
 * Logs the specified message at the fatal log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logErrorCauseMessage = logErrorCauseMessage;
const logFatal = internal.logFatal;
/**
 * Logs the specified `Cause` at the fatal log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logFatal = logFatal;
const logFatalCause = internal.logFatalCause;
/**
 * Logs the specified message and `Cause` at the fatal log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logFatalCause = logFatalCause;
const logFatalCauseMessage = internal.logFatalCauseMessage;
/**
 * Logs the specified message at the info log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logFatalCauseMessage = logFatalCauseMessage;
const logInfo = internal.logInfo;
/**
 * Logs the specified `Cause` at the info log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logInfo = logInfo;
const logInfoCause = internal.logInfoCause;
/**
 * Logs the specified message and `Cause` at the info log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logInfoCause = logInfoCause;
const logInfoCauseMessage = internal.logInfoCauseMessage;
/**
 * Logs the specified message at the warning log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logInfoCauseMessage = logInfoCauseMessage;
const logWarning = internal.logWarning;
/**
 * Logs the specified `Cause` at the warning log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logWarning = logWarning;
const logWarningCause = internal.logWarningCause;
/**
 * Logs the specified message and `Cause` at the warning log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logWarningCause = logWarningCause;
const logWarningCauseMessage = internal.logWarningCauseMessage;
/**
 * Logs the specified message at the trace log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logWarningCauseMessage = logWarningCauseMessage;
const logTrace = internal.logTrace;
/**
 * Logs the specified `Cause` at the trace log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logTrace = logTrace;
const logTraceCause = internal.logTraceCause;
/**
 * Logs the specified message and `Cause` at the trace log level.
 *
 * @since 1.0.0
 * @category logging
 */
exports.logTraceCause = logTraceCause;
const logTraceCauseMessage = internal.logTraceCauseMessage;
/**
 * Transforms this sink's result.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.logTraceCauseMessage = logTraceCauseMessage;
const map = internal.map;
/**
 * Effectfully transforms this sink's result.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.map = map;
const mapEffect = internal.mapEffect;
/**
 * Transforms the errors emitted by this sink using `f`.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapEffect = mapEffect;
const mapError = internal.mapError;
/**
 * Transforms the leftovers emitted by this sink using `f`.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.mapError = mapError;
const mapLeftover = internal.mapLeftover;
/**
 * Creates a sink which transforms it's inputs into a string.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.mapLeftover = mapLeftover;
const mkString = internal.mkString;
/**
 * Creates a sink which never terminates.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.mkString = mkString;
const never = internal.never;
/**
 * Switch to another sink in case of failure
 *
 * @since 1.0.0
 * @category error handling
 */
exports.never = never;
const orElse = internal.orElse;
/**
 * Provides the sink with its required context, which eliminates its
 * dependency on `R`.
 *
 * @since 1.0.0
 * @category context
 */
exports.orElse = orElse;
const provideContext = internal.provideContext;
/**
 * Runs both sinks in parallel on the input, , returning the result or the
 * error from the one that finishes first.
 *
 * @since 1.0.0
 * @category utils
 */
exports.provideContext = provideContext;
const race = internal.race;
/**
 * Runs both sinks in parallel on the input, returning the result or the error
 * from the one that finishes first.
 *
 * @since 1.0.0
 * @category utils
 */
exports.race = race;
const raceBoth = internal.raceBoth;
/**
 * Like `raceBoth`, but with a configurable `capacity` parameter.
 *
 * @since 1.0.0
 * @category utils
 */
exports.raceBoth = raceBoth;
const raceBothCapacity = internal.raceBothCapacity;
/**
 * Runs both sinks in parallel on the input, using the specified merge
 * function as soon as one result or the other has been computed.
 *
 * @since 1.0.0
 * @category utils
 */
exports.raceBothCapacity = raceBothCapacity;
const raceWith = internal.raceWith;
/**
 * Like `raceWith`, but with a configurable `capacity` parameter.
 *
 * @since 1.0.0
 * @category utils
 */
exports.raceWith = raceWith;
const raceWithCapacity = internal.raceWithCapacity;
/**
 * @since 1.0.0
 * @category error handling
 */
exports.raceWithCapacity = raceWithCapacity;
const refineOrDie = internal.refineOrDie;
/**
 * @since 1.0.0
 * @category error handling
 */
exports.refineOrDie = refineOrDie;
const refineOrDieWith = internal.refineOrDieWith;
/**
 * A sink that returns whether an element satisfies the specified predicate.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.refineOrDieWith = refineOrDieWith;
const some = internal.some;
/**
 * Splits the sink on the specified predicate, returning a new sink that
 * consumes elements until an element after the first satisfies the specified
 * predicate.
 *
 * @since 1.0.0
 * @category utils
 */
exports.some = some;
const splitWhere = internal.splitWhere;
/**
 * A sink that immediately ends with the specified value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.splitWhere = splitWhere;
const succeed = internal.succeed;
/**
 * A sink that sums incoming numeric values.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.succeed = succeed;
const sum = internal.sum;
/**
 * Summarize a sink by running an effect when the sink starts and again when
 * it completes.
 *
 * @since 1.0.0
 * @category utils
 */
exports.sum = sum;
const summarized = internal.summarized;
/**
 * Returns a lazily constructed sink that may require effects for its
 * creation.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.summarized = summarized;
const suspend = internal.suspend;
/**
 * A sink that immediately ends with the specified lazy value.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.suspend = suspend;
const sync = internal.sync;
/**
 * A sink that takes the specified number of values.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.sync = sync;
const take = internal.take;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.take = take;
const timed = internal.timed;
/**
 * Creates a sink produced from an effect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.timed = timed;
const unwrap = internal.unwrap;
/**
 * Creates a sink produced from a scoped effect.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.unwrap = unwrap;
const unwrapScoped = internal.unwrapScoped;
/**
 * Returns the sink that executes this one and times its execution.
 *
 * @since 1.0.0
 * @category utils
 */
exports.unwrapScoped = unwrapScoped;
const withDuration = internal.withDuration;
/**
 * Feeds inputs to this sink until it yields a result, then switches over to
 * the provided sink until it yields a result, finally combining the two
 * results into a tuple.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.withDuration = withDuration;
const zip = internal.zip;
/**
 * Like `Sink.zip` but keeps only the result from this sink.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zip = zip;
const zipLeft = internal.zipLeft;
/**
 * Like `Sink.zip` but keeps only the result from `that` sink.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipLeft = zipLeft;
const zipRight = internal.zipRight;
/**
 * Feeds inputs to this sink until it yields a result, then switches over to
 * the provided sink until it yields a result, finally combining the two
 * results with `f`.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipRight = zipRight;
const zipWith = internal.zipWith;
/**
 * Runs both sinks in parallel on the input and combines the results in a
 * tuple.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipWith = zipWith;
const zipPar = internal.zipPar;
/**
 * Like `Sink.zipPar` but keeps only the result from this sink.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipPar = zipPar;
const zipParLeft = internal.zipParLeft;
/**
 * Like `Sink.zipPar` but keeps only the result from `that` sink.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipParLeft = zipParLeft;
const zipParRight = internal.zipParRight;
/**
 * Runs both sinks in parallel on the input and combines the results using the
 * provided function.
 *
 * @since 1.0.0
 * @category zipping
 */
exports.zipParRight = zipParRight;
const zipWithPar = internal.zipWithPar;
exports.zipWithPar = zipWithPar;
//# sourceMappingURL=Sink.js.map