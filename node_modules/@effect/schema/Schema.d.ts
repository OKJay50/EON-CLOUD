/**
 * @since 1.0.0
 */
import type { Brand } from "@effect/data/Brand";
import type { Chunk } from "@effect/data/Chunk";
import * as D from "@effect/data/Data";
import type { Either } from "@effect/data/Either";
import type { Option } from "@effect/data/Option";
import type { Predicate, Refinement } from "@effect/data/Predicate";
import type { ParseOptions } from "@effect/schema/AST";
import * as AST from "@effect/schema/AST";
import type { ParseResult } from "@effect/schema/ParseResult";
/**
 * @category model
 * @since 1.0.0
 */
export interface Schema<From, To = From> {
    readonly From: (_: From) => From;
    readonly To: (_: To) => To;
    readonly ast: AST.AST;
}
/**
 * @category model
 * @since 1.0.0
 */
export type From<S extends {
    readonly From: (..._: any) => any;
}> = Parameters<S["From"]>[0];
/**
 * @category model
 * @since 1.0.0
 */
export type To<S extends {
    readonly To: (..._: any) => any;
}> = Parameters<S["To"]>[0];
/**
 * @since 1.0.0
 */
export declare const from: <I, A>(schema: Schema<I, A>) => Schema<I, I>;
/**
 * @since 1.0.0
 */
export declare const to: <I, A>(schema: Schema<I, A>) => Schema<A, A>;
/**
 * @since 1.0.0
 */
export declare const reverse: <I, A>(schema: Schema<I, A>) => Schema<A, I>;
export { 
/**
 * @category validation
 * @since 1.0.0
 */
asserts, 
/**
 * @category decoding
 * @since 1.0.0
 */
decode, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeEffect, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeEither, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeOption, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodePromise, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeResult, 
/**
 * @category encoding
 * @since 1.0.0
 */
encode, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeEffect, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeEither, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeOption, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodePromise, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeResult, 
/**
 * @category validation
 * @since 1.0.0
 */
is, 
/**
 * @category parsing
 * @since 1.0.0
 */
parse, 
/**
 * @category parsing
 * @since 1.0.0
 */
parseEffect, 
/**
 * @category parsing
 * @since 1.0.0
 */
parseEither, 
/**
 * @category parsing
 * @since 1.0.0
 */
parseOption, 
/**
 * @category parsing
 * @since 1.0.0
 */
parsePromise, 
/**
 * @category parsing
 * @since 1.0.0
 */
parseResult, 
/**
 * @category validation
 * @since 1.0.0
 */
validate, 
/**
 * @category validation
 * @since 1.0.0
 */
validateEffect, 
/**
 * @category validation
 * @since 1.0.0
 */
validateEither, 
/**
 * @category validation
 * @since 1.0.0
 */
validateOption, 
/**
 * @category validation
 * @since 1.0.0
 */
validatePromise, 
/**
 * @category validation
 * @since 1.0.0
 */
validateResult } from "@effect/schema/Parser";
export type { 
/**
 * @since 1.0.0
 */
ToAsserts } from "@effect/schema/Parser";
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const make: <I, A>(ast: AST.AST) => Schema<I, A>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const literal: <Literals extends readonly AST.LiteralValue[]>(...literals: Literals) => Schema<Literals[number], Literals[number]>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const uniqueSymbol: <S extends symbol>(symbol: S, annotations?: AST.Annotated["annotations"]) => Schema<S, S>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const enums: <A extends {
    [x: string]: string | number;
}>(enums: A) => Schema<A[keyof A], A[keyof A]>;
/**
 * @since 1.0.0
 */
export type Join<T> = T extends [infer Head, ...infer Tail] ? `${Head & (string | number | bigint | boolean | null | undefined)}${Tail extends [] ? "" : Join<Tail>}` : never;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const templateLiteral: <T extends [Schema<any, any>, ...Schema<any, any>[]]>(...[head, ...tail]: T) => Schema<Join<{ [K in keyof T]: To<T[K]>; }>, Join<{ [K in keyof T]: To<T[K]>; }>>;
/**
  @category combinators
  @since 1.0.0
*/
export declare const declare: (typeParameters: ReadonlyArray<Schema<any>>, type: Schema<any>, decode: (...typeParameters: ReadonlyArray<Schema<any>>) => (input: unknown, options?: ParseOptions) => ParseResult<any>, annotations?: AST.Annotated["annotations"]) => Schema<any>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const union: <Members extends readonly Schema<any, any>[]>(...members: Members) => Schema<From<Members[number]>, To<Members[number]>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const nullable: <From_1, To_1>(self: Schema<From_1, To_1>) => Schema<From_1 | null, To_1 | null>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const keyof: <I, A>(schema: Schema<I, A>) => Schema<keyof A, keyof A>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const tuple: <Elements extends readonly Schema<any, any>[]>(...elements: Elements) => Schema<{ readonly [K in keyof Elements]: From<Elements[K]>; }, { readonly [K_1 in keyof Elements]: To<Elements[K_1]>; }>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const rest: <IR, R>(rest: Schema<IR, R>) => <I extends readonly any[], A extends readonly any[]>(self: Schema<I, A>) => Schema<readonly [...I, ...IR[]], readonly [...A, ...R[]]>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const element: <IE, E>(element: Schema<IE, E>) => <I extends readonly any[], A extends readonly any[]>(self: Schema<I, A>) => Schema<readonly [...I, IE], readonly [...A, E]>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const optionalElement: <IE, E>(element: Schema<IE, E>) => <I extends readonly any[], A extends readonly any[]>(self: Schema<I, A>) => Schema<readonly [...I, IE?], readonly [...A, E?]>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const array: <I, A>(item: Schema<I, A>) => Schema<readonly I[], readonly A[]>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const nonEmptyArray: <I, A>(item: Schema<I, A>) => Schema<readonly [I, ...I[]], readonly [A, ...A[]]>;
/**
 * @since 1.0.0
 */
export type Spread<A> = {
    [K in keyof A]: A[K];
} extends infer B ? B : never;
/**
 * @since 1.0.0
 */
export declare const OptionalSchemaId: unique symbol;
/**
 * @since 1.0.0
 */
export type OptionalSchemaId = typeof OptionalSchemaId;
/**
 * @since 1.0.0
 */
export interface OptionalSchema<From, To = From> {
    readonly From: (_: From) => From;
    readonly To: (_: To) => To;
    readonly _id: OptionalSchemaId;
}
/**
 * @since 1.0.0
 */
export declare const optional: <I, A>(schema: Schema<I, A>) => OptionalSchema<I, A>;
/**
 * @since 1.0.0
 */
export type OptionalKeys<T> = {
    [K in keyof T]: T[K] extends OptionalSchema<any> ? K : never;
}[keyof T];
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const struct: <Fields extends Record<PropertyKey, Schema<any, any> | OptionalSchema<any, any>>>(fields: Fields) => Schema<Spread<{ readonly [K in Exclude<keyof Fields, OptionalKeys<Fields>>]: From<Fields[K]>; } & { readonly [K_1 in OptionalKeys<Fields>]?: From<Fields[K_1]>; }>, Spread<{ readonly [K_2 in Exclude<keyof Fields, OptionalKeys<Fields>>]: To<Fields[K_2]>; } & { readonly [K_3 in OptionalKeys<Fields>]?: To<Fields[K_3]>; }>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const pick: <A, Keys extends readonly (keyof A)[]>(...keys: Keys) => <I extends Record<keyof A, any>>(self: Schema<I, A>) => Schema<{ readonly [P in Keys[number]]: I[P]; }, { readonly [P_1 in Keys[number]]: A[P_1]; }>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const omit: <A, Keys extends readonly (keyof A)[]>(...keys: Keys) => <I extends Record<keyof A, any>>(self: Schema<I, A>) => Schema<{ readonly [P in Exclude<keyof A, Keys[number]>]: I[P]; }, { readonly [P_1 in Exclude<keyof A, Keys[number]>]: A[P_1]; }>;
/**
 * Returns an object containing all property signatures of a given schema.
 *
 * ```
 * Schema<A> -> { [K in keyof A]: Schema<A[K]> }
 * ```
 *
 * @param schema - The schema to extract property signatures from.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const Person = S.struct({
 *   name: S.string,
 *   age: S.number
 * })
 *
 * const shape = S.getPropertySignatures(Person)
 *
 * assert.deepStrictEqual(shape.name, S.string)
 * assert.deepStrictEqual(shape.age, S.number)
 *
 * @since 1.0.0
 */
export declare const getPropertySignatures: <I extends Record<keyof A, any>, A>(schema: Schema<I, A>) => { [K in keyof A]: Schema<I[K], A[K]>; };
/**
 * @category model
 * @since 1.0.0
 */
export interface BrandSchema<From, To extends Brand<any>> extends Schema<From, To>, Brand.Constructor<To> {
}
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "@effect/data/Function"
 *
 * const Int = pipe(S.number, S.int(), S.brand("Int"))
 * type Int = S.To<typeof Int> // number & Brand<"Int">
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const brand: <B extends string | symbol, A>(brand: B, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => BrandSchema<I, A & Brand<B>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const partial: <I, A>(self: Schema<I, A>) => Schema<Spread<Partial<I>>, Spread<Partial<A>>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const required: <I, A>(self: Schema<I, A>) => Schema<Spread<Required<I>>, Spread<Required<A>>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const record: <K extends string | symbol, I, A>(key: Schema<K, K>, value: Schema<I, A>) => Schema<{ readonly [k in K]: I; }, { readonly [k_1 in K]: A; }>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const extend: <IB, B>(that: Schema<IB, B>) => <I, A>(self: Schema<I, A>) => Schema<Spread<I & IB>, Spread<A & B>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const lazy: <I, A = I>(f: () => Schema<I, A>, annotations?: AST.Annotated["annotations"]) => Schema<I, A>;
/**
 * @category model
 * @since 1.0.0
 */
export type AnnotationOptions<A> = {
    typeId?: AST.TypeAnnotation | {
        id: AST.TypeAnnotation;
        params: unknown;
    };
    message?: AST.MessageAnnotation<A>;
    identifier?: AST.IdentifierAnnotation;
    title?: AST.TitleAnnotation;
    description?: AST.DescriptionAnnotation;
    examples?: AST.ExamplesAnnotation;
    documentation?: AST.DocumentationAnnotation;
    jsonSchema?: AST.JSONSchemaAnnotation;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare function filter<C extends A, B extends A, A = C>(refinement: Refinement<A, B>, options?: AnnotationOptions<A>): <I>(self: Schema<I, C>) => Schema<I, C & B>;
export declare function filter<B extends A, A = B>(predicate: Predicate<A>, options?: AnnotationOptions<A>): <I>(self: Schema<I, B>) => Schema<I, B>;
/**
  Create a new `Schema` by transforming the input and output of an existing `Schema`
  using the provided decoding functions.

  @category combinators
  @since 1.0.0
 */
export declare const transformResult: {
    <I2, A2, A1>(to: Schema<I2, A2>, decode: (a1: A1, options?: ParseOptions) => ParseResult<I2>, encode: (i2: I2, options?: ParseOptions) => ParseResult<A1>): <I1>(self: Schema<I1, A1>) => Schema<I1, A2>;
    <I1, A1, I2, A2>(from: Schema<I1, A1>, to: Schema<I2, A2>, decode: (a1: A1, options?: ParseOptions) => ParseResult<I2>, encode: (i2: I2, options?: ParseOptions) => ParseResult<A1>): Schema<I1, A2>;
};
/**
  Create a new `Schema` by transforming the input and output of an existing `Schema`
  using the provided mapping functions.

  @category combinators
  @since 1.0.0
*/
export declare const transform: {
    <I2, A2, A1>(to: Schema<I2, A2>, decode: (a1: A1) => I2, encode: (i2: I2) => A1): <I1>(self: Schema<I1, A1>) => Schema<I1, A2>;
    <I1, A1, I2, A2>(from: Schema<I1, A1>, to: Schema<I2, A2>, decode: (a1: A1) => I2, encode: (i2: I2) => A1): Schema<I1, A2>;
};
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "@effect/data/Function"
 *
 * const Circle = S.struct({ radius: S.number })
 * const Square = S.struct({ sideLength: S.number })
 * const Shape = S.union(
 *   pipe(Circle, S.attachPropertySignature("kind", "circle")),
 *   pipe(Square, S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decode(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const attachPropertySignature: <K extends PropertyKey, V extends AST.LiteralValue>(key: K, value: V) => <I, A extends object>(schema: Schema<I, A>) => Schema<I, Spread<A & { readonly [k in K]: V; }>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const annotations: (annotations: AST.Annotated["annotations"]) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const message: (message: AST.MessageAnnotation<unknown>) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const identifier: (identifier: AST.IdentifierAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const title: (title: AST.TitleAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const description: (description: AST.DescriptionAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const examples: (examples: AST.ExamplesAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const documentation: (documentation: AST.DocumentationAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
declare const _undefined: Schema<undefined>;
declare const _void: Schema<void>;
declare const _null: Schema<null>;
export { 
/**
 * @category primitives
 * @since 1.0.0
 */
_null as null, 
/**
 * @category primitives
 * @since 1.0.0
 */
_undefined as undefined, 
/**
 * @category primitives
 * @since 1.0.0
 */
_void as void };
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const never: Schema<never>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const unknown: Schema<unknown>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const any: Schema<any>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const string: Schema<string>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const number: Schema<number>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const boolean: Schema<boolean>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const bigint: Schema<bigint>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const symbol: Schema<symbol>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const object: Schema<object>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanBigintTypeId = "@effect/schema/GreaterThanBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const greaterThanBigint: <A extends bigint>(min: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToBigintTypeId = "@effect/schema/GreaterThanOrEqualToBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const greaterThanOrEqualToBigint: <A extends bigint>(min: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanBigintTypeId = "@effect/schema/LessThanBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const lessThanBigint: <A extends bigint>(max: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToBigintTypeId = "@effect/schema/LessThanOrEqualToBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const lessThanOrEqualToBigint: <A extends bigint>(max: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenBigintTypeId = "@effect/schema/BetweenBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const betweenBigint: <A extends bigint>(min: bigint, max: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PositiveBigintTypeId = "@effect/schema/PositiveBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const positiveBigint: <A extends bigint>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NegativeBigintTypeId = "@effect/schema/NegativeBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const negativeBigint: <A extends bigint>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNegativeBigintTypeId = "@effect/schema/NonNegativeBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const nonNegativeBigint: <A extends bigint>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonPositiveBigintTypeId = "@effect/schema/NonPositiveBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const nonPositiveBigint: <A extends bigint>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint
 * @since 1.0.0
 */
export declare const clampBigint: <A extends bigint>(min: bigint, max: bigint) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BrandTypeId = "@effect/schema/BrandTypeId";
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const fromBrand: <C extends Brand<string | symbol>>(constructor: Brand.Constructor<C>, options?: AnnotationOptions<Brand.Unbranded<C>> | undefined) => <I, A extends Brand.Unbranded<C>>(self: Schema<I, A>) => Schema<I, A & C>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const chunkFromSelf: <I, A>(item: Schema<I, A>) => Schema<Chunk<I>, Chunk<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const chunk: <I, A>(item: Schema<I, A>) => Schema<readonly I[], Chunk<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const dataFromSelf: <I extends readonly any[] | Readonly<Record<string, any>>, A extends readonly any[] | Readonly<Record<string, any>>>(item: Schema<I, A>) => Schema<D.Data<I>, D.Data<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const data: <I extends readonly any[] | Readonly<Record<string, any>>, A extends readonly any[] | Readonly<Record<string, any>>>(item: Schema<I, A>) => Schema<I, D.Data<A>>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const date: Schema<Date>;
/**
  Transforms a `string` into a `Date` by parsing the string using `Date.parse`.

  @category date
  @since 1.0.0
*/
export declare const dateFromString: Schema<string, Date>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const eitherFromSelf: <IE, E, IA, A>(left: Schema<IE, E>, right: Schema<IA, A>) => Schema<Either<IE, IA>, Either<E, A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const either: <IE, E, IA, A>(left: Schema<IE, E>, right: Schema<IA, A>) => Schema<{
    readonly _tag: "Left";
    readonly left: IE;
} | {
    readonly _tag: "Right";
    readonly right: IA;
}, Either<E, A>>;
/**
 * @category model
 * @since 1.0.0
 */
export type JsonArray = ReadonlyArray<Json>;
/**
 * @category model
 * @since 1.0.0
 */
export type JsonObject = {
    readonly [key: string]: Json;
};
/**
 * @category model
 * @since 1.0.0
 */
export type Json = null | boolean | number | string | JsonArray | JsonObject;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const json: Schema<Json>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const FiniteTypeId = "@effect/schema/FiniteTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const finite: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanTypeId = "@effect/schema/GreaterThanTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const greaterThan: <A extends number>(min: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToTypeId = "@effect/schema/GreaterThanOrEqualToTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const greaterThanOrEqualTo: <A extends number>(min: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MultipleOfTypeId = "@effect/schema/MultipleOfTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const multipleOf: <A extends number>(divisor: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const IntTypeId = "@effect/schema/IntTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const int: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanTypeId = "@effect/schema/LessThanTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const lessThan: <A extends number>(max: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToTypeId = "@effect/schema/LessThanOrEqualToTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const lessThanOrEqualTo: <A extends number>(max: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenTypeId = "@effect/schema/BetweenTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const between: <A extends number>(min: number, max: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNaNTypeId = "@effect/schema/NonNaNTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const nonNaN: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PositiveTypeId = "@effect/schema/PositiveTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const positive: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NegativeTypeId = "@effect/schema/NegativeTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const negative: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNegativeTypeId = "@effect/schema/NonNegativeTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const nonNegative: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonPositiveTypeId = "@effect/schema/NonPositiveTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const nonPositive: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number
 * @since 1.0.0
 */
export declare const clamp: <A extends number>(min: number, max: number) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
  Transforms a `string` into a `number` by parsing the string using `parseFloat`.

  The following special string values are supported: "NaN", "Infinity", "-Infinity".

  @category number
  @since 1.0.0
*/
export declare const numberFromString: <I>(self: Schema<I, string>) => Schema<I, number>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const InstanceOfTypeId = "@effect/schema/InstanceOfTypeId";
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A, options?: AnnotationOptions<object>) => Schema<InstanceType<A>, InstanceType<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const optionFromSelf: <I, A>(value: Schema<I, A>) => Schema<Option<I>, Option<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const option: <I, A>(value: Schema<I, A>) => Schema<{
    readonly _tag: "None";
} | {
    readonly _tag: "Some";
    readonly value: I;
}, Option<A>>;
/**
 * @category option
 * @since 1.0.0
 */
export declare const optionFromNullable: <I, A>(value: Schema<I, A>) => Schema<I | null | undefined, Option<A>>;
/**
 * @category option
 * @since 1.0.0
 */
export declare const optionsFromOptionals: <Fields extends Record<PropertyKey, Schema<any, any>>>(fields: Fields) => <I, A extends object>(schema: Schema<I, A>) => Schema<Spread<I & { readonly [K in keyof Fields]?: From<Fields[K]>; }>, Spread<A & { readonly [K_1 in keyof Fields]: Option<To<Fields[K_1]>>; }>>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MinItemsTypeId = "@effect/schema/MinItemsTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export declare const minItems: <A>(n: number, options?: AnnotationOptions<readonly A[]> | undefined) => <I>(self: Schema<I, readonly A[]>) => Schema<I, readonly A[]>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MaxItemsTypeId = "@effect/schema/MaxItemsTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export declare const maxItems: <A>(n: number, options?: AnnotationOptions<readonly A[]> | undefined) => <I>(self: Schema<I, readonly A[]>) => Schema<I, readonly A[]>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ItemsCountTypeId = "@effect/schema/ItemsCountTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export declare const itemsCount: <A>(n: number, options?: AnnotationOptions<readonly A[]> | undefined) => <I>(self: Schema<I, readonly A[]>) => Schema<I, readonly A[]>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const readonlyMapFromSelf: <IK, K, IV, V>(key: Schema<IK, K>, value: Schema<IV, V>) => Schema<ReadonlyMap<IK, IV>, ReadonlyMap<K, V>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const readonlyMap: <IK, K, IV, V>(key: Schema<IK, K>, value: Schema<IV, V>) => Schema<readonly (readonly [IK, IV])[], ReadonlyMap<K, V>>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const readonlySetFromSelf: <I, A>(item: Schema<I, A>) => Schema<ReadonlySet<I>, ReadonlySet<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const readonlySet: <I, A>(item: Schema<I, A>) => Schema<readonly I[], ReadonlySet<A>>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const TrimmedTypeId = "@effect/schema/TrimmedTypeId";
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string
 * @since 1.0.0
 */
export declare const trimmed: <A extends string>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category string
 * @since 1.0.0
 */
export declare const maxLength: <A extends string>(maxLength: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category string
 * @since 1.0.0
 */
export declare const minLength: <A extends string>(minLength: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PatternTypeId = "@effect/schema/PatternTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const pattern: <A extends string>(regex: RegExp, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const StartsWithTypeId = "@effect/schema/StartsWithTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const startsWith: <A extends string>(startsWith: string, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const EndsWithTypeId = "@effect/schema/EndsWithTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const endsWith: <A extends string>(endsWith: string, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const IncludesTypeId = "@effect/schema/IncludesTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const includes: <A extends string>(searchString: string, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * The `trim` parser allows removing whitespaces from the beginning and end of a string.
 *
 * @category string
 * @since 1.0.0
 */
export declare const trim: <I>(self: Schema<I, string>) => Schema<I, string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const UUIDTypeId = "@effect/schema/UUIDTypeId";
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const UUID: Schema<string>;
/**
 * @category string
 * @since 1.0.0
 */
export declare const length: <A extends string>(length: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category string
 * @since 1.0.0
 */
export declare const nonEmpty: <A extends string>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
//# sourceMappingURL=Schema.d.ts.map