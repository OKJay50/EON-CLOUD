"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.to = exports.from = exports.ArbitraryHookId = void 0;
var E = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var AST = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/schema/AST"));
var I = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/schema/internal/common"));
var _ParseResult = /*#__PURE__*/require("@effect/schema/ParseResult");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 */

/**
 * @category hooks
 * @since 1.0.0
 */
const ArbitraryHookId = I.ArbitraryHookId;
/**
 * @category arbitrary
 * @since 1.0.0
 */
exports.ArbitraryHookId = ArbitraryHookId;
const to = schema => go(schema.ast);
/**
 * @category arbitrary
 * @since 1.0.0
 */
exports.to = to;
const from = schema => go(AST.getFrom(schema.ast));
exports.from = from;
const record = (fc, key, value) => fc.array(fc.tuple(key, value), {
  maxLength: 10
}).map(tuples => {
  const out = {};
  for (const [k, v] of tuples) {
    out[k] = v;
  }
  return out;
});
const getHook = /*#__PURE__*/AST.getAnnotation(ArbitraryHookId);
const go = ast => {
  switch (ast._tag) {
    case "Declaration":
      return (0, _Function.pipe)(getHook(ast), O.match(() => go(ast.type), handler => handler(...ast.typeParameters.map(go))));
    case "Literal":
      return fc => fc.constant(ast.literal);
    case "UniqueSymbol":
      return fc => fc.constant(ast.symbol);
    case "UndefinedKeyword":
      return fc => fc.constant(undefined);
    case "VoidKeyword":
      return fc => fc.constant(undefined);
    case "NeverKeyword":
      return () => {
        throw new Error("cannot build an Arbitrary for `never`");
      };
    case "UnknownKeyword":
      return fc => fc.anything();
    case "AnyKeyword":
      return fc => fc.anything();
    case "StringKeyword":
      return fc => fc.string();
    case "NumberKeyword":
      return fc => fc.float();
    case "BooleanKeyword":
      return fc => fc.boolean();
    case "BigIntKeyword":
      return fc => fc.bigInt();
    case "SymbolKeyword":
      return fc => fc.string().map(s => Symbol.for(s));
    case "ObjectKeyword":
      return fc => fc.oneof(fc.object(), fc.array(fc.anything()));
    case "TemplateLiteral":
      {
        return fc => {
          const components = [fc.constant(ast.head)];
          for (const span of ast.spans) {
            components.push(fc.string({
              maxLength: 5
            }));
            components.push(fc.constant(span.literal));
          }
          return fc.tuple(...components).map(spans => spans.join(""));
        };
      }
    case "Tuple":
      {
        const elements = ast.elements.map(e => go(e.type));
        const rest = (0, _Function.pipe)(ast.rest, O.map(RA.mapNonEmpty(go)));
        return fc => {
          // ---------------------------------------------
          // handle elements
          // ---------------------------------------------
          let output = fc.tuple(...elements.map(arb => arb(fc)));
          if (elements.length > 0 && O.isNone(rest)) {
            const firstOptionalIndex = ast.elements.findIndex(e => e.isOptional);
            if (firstOptionalIndex !== -1) {
              output = output.chain(as => fc.integer({
                min: firstOptionalIndex,
                max: elements.length - 1
              }).map(i => as.slice(0, i)));
            }
          }
          // ---------------------------------------------
          // handle rest element
          // ---------------------------------------------
          if (O.isSome(rest)) {
            const head = RA.headNonEmpty(rest.value);
            const tail = RA.tailNonEmpty(rest.value);
            output = output.chain(as => fc.array(head(fc), {
              maxLength: 5
            }).map(rest => [...as, ...rest]));
            // ---------------------------------------------
            // handle post rest elements
            // ---------------------------------------------
            for (let j = 0; j < tail.length; j++) {
              output = output.chain(as => tail[j](fc).map(a => [...as, a]));
            }
          }
          return output;
        };
      }
    case "TypeLiteral":
      {
        const propertySignaturesTypes = ast.propertySignatures.map(f => go(f.type));
        const indexSignatures = ast.indexSignatures.map(is => [go(is.parameter), go(is.type)]);
        return fc => {
          const arbs = {};
          const requiredKeys = [];
          // ---------------------------------------------
          // handle property signatures
          // ---------------------------------------------
          for (let i = 0; i < propertySignaturesTypes.length; i++) {
            const ps = ast.propertySignatures[i];
            const name = ps.name;
            if (!ps.isOptional) {
              requiredKeys.push(name);
            }
            arbs[name] = propertySignaturesTypes[i](fc);
          }
          let output = fc.record(arbs, {
            requiredKeys
          });
          // ---------------------------------------------
          // handle index signatures
          // ---------------------------------------------
          for (let i = 0; i < indexSignatures.length; i++) {
            const parameter = indexSignatures[i][0](fc);
            const type = indexSignatures[i][1](fc);
            output = output.chain(o => {
              return record(fc, parameter, type).map(d => ({
                ...d,
                ...o
              }));
            });
          }
          return output;
        };
      }
    case "Union":
      {
        const types = ast.types.map(go);
        return fc => fc.oneof(...types.map(arb => arb(fc)));
      }
    case "Lazy":
      return (0, _Function.pipe)(getHook(ast), O.match(() => {
        const f = () => go(ast.f());
        const get = I.memoize(f);
        return fc => fc.constant(null).chain(() => get()(fc));
      }, handler => handler()));
    case "Enums":
      {
        if (ast.enums.length === 0) {
          throw new Error("cannot build an Arbitrary for an empty enum");
        }
        return fc => fc.oneof(...ast.enums.map(([_, value]) => fc.constant(value)));
      }
    case "Refinement":
    case "Transform":
      {
        const to = go(ast.to);
        return (0, _Function.pipe)(getHook(ast), O.match(() => fc => to(fc).filter(a => {
          const computed = (0, _ParseResult.eitherOrUndefined)(ast.decode(a));
          if (computed) {
            return E.isRight(computed);
          } else {
            return false;
          }
        }), handler => handler(to)));
      }
  }
};
//# sourceMappingURL=Arbitrary.js.map