"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.voidKeyword = exports.unknownKeyword = exports.undefinedKeyword = exports.symbolKeyword = exports.stringKeyword = exports.sortByWeightDesc = exports.setAnnotation = exports.reverse = exports.required = exports.pick = exports.partial = exports.omit = exports.objectKeyword = exports.numberKeyword = exports.neverKeyword = exports.mergeAnnotations = exports.keyof = exports.isUnknownKeyword = exports.isUniqueSymbol = exports.isUnion = exports.isTypeLiteral = exports.isTuple = exports.isTransform = exports.isTemplateLiteral = exports.isSymbolKeyword = exports.isStringKeyword = exports.isRefinement = exports.isNumberKeyword = exports.isNeverKeyword = exports.isLiteral = exports.isLazy = exports.isDeclaration = exports.isBooleanKeyword = exports.isBigIntKeyword = exports.isAnyKeyword = exports.hasTransformation = exports.getTo = exports.getFrom = exports.getCompiler = exports.getAnnotation = exports.createUniqueSymbol = exports.createUnion = exports.createTypeLiteral = exports.createTuple = exports.createTransform = exports.createTemplateLiteral = exports.createRefinement = exports.createRecord = exports.createPropertySignature = exports.createLiteral = exports.createLazy = exports.createIndexSignature = exports.createEnums = exports.createElement = exports.createDeclaration = exports.booleanKeyword = exports.bigIntKeyword = exports.appendRestElement = exports.appendElement = exports.anyKeyword = exports._getWeight = exports._getPropertySignatures = exports._getParameterKeyof = exports._getCardinality = exports.TypeAnnotationId = exports.TitleAnnotationId = exports.MessageAnnotationId = exports.JSONSchemaAnnotationId = exports.IdentifierAnnotationId = exports.ExamplesAnnotationId = exports.DocumentationAnnotationId = exports.DescriptionAnnotationId = exports.BrandAnnotationId = void 0;
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Number = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Number"));
var O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var _String = /*#__PURE__*/require("@effect/data/String");
var Order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/typeclass/Order"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 */

/**
 * @category annotations
 * @since 1.0.0
 */
const BrandAnnotationId = "@effect/schema/BrandAnnotationId";
/**
 * @category annotations
 * @since 1.0.0
 */
exports.BrandAnnotationId = BrandAnnotationId;
const TypeAnnotationId = "@effect/schema/TypeAnnotationId";
/**
 * @category annotations
 * @since 1.0.0
 */
exports.TypeAnnotationId = TypeAnnotationId;
const MessageAnnotationId = "@effect/schema/MessageAnnotationId";
/**
 * @category annotations
 * @since 1.0.0
 */
exports.MessageAnnotationId = MessageAnnotationId;
const IdentifierAnnotationId = "@effect/schema/IdentifierAnnotationId";
/**
 * @category annotations
 * @since 1.0.0
 */
exports.IdentifierAnnotationId = IdentifierAnnotationId;
const TitleAnnotationId = "@effect/schema/TitleAnnotationId";
/**
 * @category annotations
 * @since 1.0.0
 */
exports.TitleAnnotationId = TitleAnnotationId;
const DescriptionAnnotationId = "@effect/schema/DescriptionAnnotationId";
/**
 * @category annotations
 * @since 1.0.0
 */
exports.DescriptionAnnotationId = DescriptionAnnotationId;
const ExamplesAnnotationId = "@effect/schema/ExamplesAnnotationId";
/**
 * @category annotations
 * @since 1.0.0
 */
exports.ExamplesAnnotationId = ExamplesAnnotationId;
const JSONSchemaAnnotationId = "@effect/schema/JSONSchemaAnnotationId";
/**
 * @category annotations
 * @since 1.0.0
 */
exports.JSONSchemaAnnotationId = JSONSchemaAnnotationId;
const DocumentationAnnotationId = "@effect/schema/DocumentationAnnotationId";
/**
 * @since 1.0.0
 */
exports.DocumentationAnnotationId = DocumentationAnnotationId;
const hasTransformation = ast => isRefinement(ast) || isTransform(ast) || isLazy(ast) || "hasTransformation" in ast && ast.hasTransformation;
/**
 * @since 1.0.0
 */
exports.hasTransformation = hasTransformation;
const getAnnotation = key => annotated => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? O.some(annotated.annotations[key]) : O.none();
/**
 * @category constructors
 * @since 1.0.0
 */
exports.getAnnotation = getAnnotation;
const createDeclaration = (typeParameters, type, decode, annotations = {}) => ({
  _tag: "Declaration",
  typeParameters,
  type,
  decode,
  annotations,
  hasTransformation: hasTransformation(type) || typeParameters.some(hasTransformation)
});
/**
 * @category guards
 * @since 1.0.0
 */
exports.createDeclaration = createDeclaration;
const isDeclaration = ast => ast._tag === "Declaration";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isDeclaration = isDeclaration;
const createLiteral = literal => ({
  _tag: "Literal",
  literal,
  annotations: {}
});
/**
 * @category guards
 * @since 1.0.0
 */
exports.createLiteral = createLiteral;
const isLiteral = ast => ast._tag === "Literal";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isLiteral = isLiteral;
const createUniqueSymbol = (symbol, annotations = {}) => ({
  _tag: "UniqueSymbol",
  symbol,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
exports.createUniqueSymbol = createUniqueSymbol;
const isUniqueSymbol = ast => ast._tag === "UniqueSymbol";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isUniqueSymbol = isUniqueSymbol;
const undefinedKeyword = {
  _tag: "UndefinedKeyword",
  annotations: {
    [TitleAnnotationId]: "undefined"
  }
};
/**
 * @category constructors
 * @since 1.0.0
 */
exports.undefinedKeyword = undefinedKeyword;
const voidKeyword = {
  _tag: "VoidKeyword",
  annotations: {
    [TitleAnnotationId]: "void"
  }
};
/**
 * @category constructors
 * @since 1.0.0
 */
exports.voidKeyword = voidKeyword;
const neverKeyword = {
  _tag: "NeverKeyword",
  annotations: {
    [TitleAnnotationId]: "never"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.neverKeyword = neverKeyword;
const isNeverKeyword = ast => ast._tag === "NeverKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isNeverKeyword = isNeverKeyword;
const unknownKeyword = {
  _tag: "UnknownKeyword",
  annotations: {
    [TitleAnnotationId]: "unknown"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.unknownKeyword = unknownKeyword;
const isUnknownKeyword = ast => ast._tag === "UnknownKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isUnknownKeyword = isUnknownKeyword;
const anyKeyword = {
  _tag: "AnyKeyword",
  annotations: {
    [TitleAnnotationId]: "any"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.anyKeyword = anyKeyword;
const isAnyKeyword = ast => ast._tag === "AnyKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isAnyKeyword = isAnyKeyword;
const stringKeyword = {
  _tag: "StringKeyword",
  annotations: {
    [TitleAnnotationId]: "string"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.stringKeyword = stringKeyword;
const isStringKeyword = ast => ast._tag === "StringKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isStringKeyword = isStringKeyword;
const numberKeyword = {
  _tag: "NumberKeyword",
  annotations: {
    [TitleAnnotationId]: "number"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.numberKeyword = numberKeyword;
const isNumberKeyword = ast => ast._tag === "NumberKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isNumberKeyword = isNumberKeyword;
const booleanKeyword = {
  _tag: "BooleanKeyword",
  annotations: {
    [TitleAnnotationId]: "boolean"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.booleanKeyword = booleanKeyword;
const isBooleanKeyword = ast => ast._tag === "BooleanKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isBooleanKeyword = isBooleanKeyword;
const bigIntKeyword = {
  _tag: "BigIntKeyword",
  annotations: {
    [TitleAnnotationId]: "bigint"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.bigIntKeyword = bigIntKeyword;
const isBigIntKeyword = ast => ast._tag === "BigIntKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isBigIntKeyword = isBigIntKeyword;
const symbolKeyword = {
  _tag: "SymbolKeyword",
  annotations: {
    [TitleAnnotationId]: "symbol"
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.symbolKeyword = symbolKeyword;
const isSymbolKeyword = ast => ast._tag === "SymbolKeyword";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isSymbolKeyword = isSymbolKeyword;
const objectKeyword = {
  _tag: "ObjectKeyword",
  annotations: {
    [TitleAnnotationId]: "object"
  }
};
/**
 * @category constructors
 * @since 1.0.0
 */
exports.objectKeyword = objectKeyword;
const createEnums = enums => ({
  _tag: "Enums",
  enums,
  annotations: {}
});
/**
 * @category constructors
 * @since 1.0.0
 */
exports.createEnums = createEnums;
const createTemplateLiteral = (head, spans) => RA.isNonEmptyReadonlyArray(spans) ? {
  _tag: "TemplateLiteral",
  head,
  spans,
  annotations: {}
} : createLiteral(head);
/**
 * @category guards
 * @since 1.0.0
 */
exports.createTemplateLiteral = createTemplateLiteral;
const isTemplateLiteral = ast => ast._tag === "TemplateLiteral";
/**
 * @since 1.0.0
 */
exports.isTemplateLiteral = isTemplateLiteral;
const createElement = (type, isOptional) => ({
  type,
  isOptional
});
/**
 * @category constructors
 * @since 1.0.0
 */
exports.createElement = createElement;
const createTuple = (elements, rest, isReadonly, annotations = {}) => ({
  _tag: "Tuple",
  elements,
  rest,
  isReadonly,
  annotations,
  hasTransformation: elements.some(e => hasTransformation(e.type)) || O.isSome(rest) && rest.value.some(hasTransformation)
});
/**
 * @category guards
 * @since 1.0.0
 */
exports.createTuple = createTuple;
const isTuple = ast => ast._tag === "Tuple";
/**
 * @since 1.0.0
 */
exports.isTuple = isTuple;
const createPropertySignature = (name, type, isOptional, isReadonly, annotations = {}) => ({
  name,
  type,
  isOptional,
  isReadonly,
  annotations
});
/**
 * @since 1.0.0
 */
exports.createPropertySignature = createPropertySignature;
const createIndexSignature = (parameter, type, isReadonly) => {
  if (isNeverKeyword(_getParameterKeyof(parameter))) {
    throw new Error("An index signature parameter type must be 'string', 'symbol', a template literal type or a refinement of the previous types");
  }
  return {
    parameter,
    type,
    isReadonly
  };
};
/**
 * @category constructors
 * @since 1.0.0
 */
exports.createIndexSignature = createIndexSignature;
const createTypeLiteral = (propertySignatures, indexSignatures, annotations = {}) => ({
  _tag: "TypeLiteral",
  propertySignatures: sortByCardinalityAsc(propertySignatures),
  indexSignatures: sortByCardinalityAsc(indexSignatures),
  annotations,
  hasTransformation: propertySignatures.some(p => hasTransformation(p.type)) || indexSignatures.some(is => hasTransformation(is.type))
});
/**
 * @category guards
 * @since 1.0.0
 */
exports.createTypeLiteral = createTypeLiteral;
const isTypeLiteral = ast => ast._tag === "TypeLiteral";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isTypeLiteral = isTypeLiteral;
const createUnion = (candidates, annotations = {}) => {
  const types = unify(candidates);
  switch (types.length) {
    case 0:
      return neverKeyword;
    case 1:
      return types[0];
    default:
      {
        return {
          _tag: "Union",
          types: sortByWeightDesc(types),
          annotations,
          hasTransformation: types.some(hasTransformation)
        };
      }
  }
};
/**
 * @category guards
 * @since 1.0.0
 */
exports.createUnion = createUnion;
const isUnion = ast => ast._tag === "Union";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isUnion = isUnion;
const createLazy = (f, annotations = {}) => ({
  _tag: "Lazy",
  f,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
exports.createLazy = createLazy;
const isLazy = ast => ast._tag === "Lazy";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isLazy = isLazy;
const createRefinement = (from, to, decode, encode, annotations = {}) => ({
  _tag: "Refinement",
  from,
  to,
  decode,
  encode,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
exports.createRefinement = createRefinement;
const isRefinement = ast => ast._tag === "Refinement";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isRefinement = isRefinement;
const createTransform = (from, to, decode, encode, annotations = {}) => ({
  _tag: "Transform",
  from,
  to,
  decode,
  encode,
  annotations
});
/**
 * @category guards
 * @since 1.0.0
 */
exports.createTransform = createTransform;
const isTransform = ast => ast._tag === "Transform";
// -------------------------------------------------------------------------------------
// API
// -------------------------------------------------------------------------------------
/**
 * Adds a group of annotations, potentially overwriting existing annotations.
 *
 * @since 1.0.0
 */
exports.isTransform = isTransform;
const mergeAnnotations = (ast, annotations) => ({
  ...ast,
  annotations: {
    ...ast.annotations,
    ...annotations
  }
});
/**
 * Adds an annotation, potentially overwriting the existing annotation with the specified id.
 *
 * @since 1.0.0
 */
exports.mergeAnnotations = mergeAnnotations;
const setAnnotation = (ast, id, value) => ({
  ...ast,
  annotations: {
    ...ast.annotations,
    [id]: value
  }
});
/**
 * Adds a rest element to the end of a tuple, or throws an exception if the rest element is already present.
 *
 * @since 1.0.0
 */
exports.setAnnotation = setAnnotation;
const appendRestElement = (ast, restElement) => {
  if (O.isSome(ast.rest)) {
    // example: `type A = [...string[], ...number[]]` is illegal
    throw new Error("A rest element cannot follow another rest element. ts(1265)");
  }
  return createTuple(ast.elements, O.some([restElement]), ast.isReadonly);
};
/**
 * Appends an element to a tuple or throws an exception in the following cases:
 * - A required element cannot follow an optional element. ts(1257)
 * - An optional element cannot follow a rest element. ts(1266)
 *
 * @since 1.0.0
 */
exports.appendRestElement = appendRestElement;
const appendElement = (ast, newElement) => {
  if (ast.elements.some(e => e.isOptional) && !newElement.isOptional) {
    throw new Error("A required element cannot follow an optional element. ts(1257)");
  }
  return (0, _Function.pipe)(ast.rest, O.match(() => createTuple([...ast.elements, newElement], O.none(), ast.isReadonly), rest => {
    if (newElement.isOptional) {
      throw new Error("An optional element cannot follow a rest element. ts(1266)");
    }
    return createTuple(ast.elements, O.some([...rest, newElement.type]), ast.isReadonly);
  }));
};
/**
 * Equivalent at runtime to the TypeScript type-level `keyof` operator.
 *
 * @since 1.0.0
 */
exports.appendElement = appendElement;
const keyof = ast => createUnion(_keyof(ast));
/**
 * Create a record with the specified key type and value type.
 *
 * @since 1.0.0
 */
exports.keyof = keyof;
const createRecord = (key, value, isReadonly) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go = key => {
    switch (key._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(createIndexSignature(key, value, isReadonly));
        break;
      case "Literal":
        if ((0, _String.isString)(key.literal) || (0, Number.isNumber)(key.literal)) {
          propertySignatures.push(createPropertySignature(key.literal, value, false, isReadonly));
        }
        break;
      case "UniqueSymbol":
        propertySignatures.push(createPropertySignature(key.symbol, value, false, isReadonly));
        break;
      case "Union":
        key.types.forEach(go);
        break;
      default:
        throw new Error(`createRecord: Unsupported key ${key._tag}`);
    }
  };
  go(key);
  return createTypeLiteral(propertySignatures, indexSignatures);
};
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Pick`.
 *
 * @since 1.0.0
 */
exports.createRecord = createRecord;
const pick = (ast, keys) => createTypeLiteral(_getPropertySignatures(ast).filter(ps => keys.includes(ps.name)), []);
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Omit`.
 *
 * @since 1.0.0
 */
exports.pick = pick;
const omit = (ast, keys) => createTypeLiteral(_getPropertySignatures(ast).filter(ps => !keys.includes(ps.name)), []);
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Partial`.
 *
 * @since 1.0.0
 */
exports.omit = omit;
const partial = ast => {
  switch (ast._tag) {
    case "Tuple":
      return createTuple(ast.elements.map(e => createElement(e.type, true)), (0, _Function.pipe)(ast.rest, O.map(rest => [createUnion([...rest, undefinedKeyword])])), ast.isReadonly);
    case "TypeLiteral":
      return createTypeLiteral(ast.propertySignatures.map(f => createPropertySignature(f.name, f.type, true, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return createUnion(ast.types.map(member => partial(member)));
    case "Lazy":
      return createLazy(() => partial(ast.f()));
    case "Declaration":
      throw new Error("`partial` cannot handle declarations");
    case "Refinement":
      throw new Error("`partial` cannot handle refinements");
    case "Transform":
      throw new Error("`partial` cannot handle transformations");
    default:
      return ast;
  }
};
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Required`.
 *
 * @since 1.0.0
 */
exports.partial = partial;
const required = ast => {
  switch (ast._tag) {
    case "Tuple":
      return createTuple(ast.elements.map(e => createElement(e.type, false)), (0, _Function.pipe)(ast.rest, O.map(rest => {
        const u = createUnion([...rest]);
        return RA.mapNonEmpty(rest, () => u);
      })), ast.isReadonly);
    case "TypeLiteral":
      return createTypeLiteral(ast.propertySignatures.map(f => createPropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return createUnion(ast.types.map(member => required(member)));
    case "Lazy":
      return createLazy(() => required(ast.f()));
    case "Declaration":
      throw new Error("`required` cannot handle declarations");
    case "Refinement":
      throw new Error("`required` cannot handle refinements");
    case "Transform":
      throw new Error("`required` cannot handle transformations");
    default:
      return ast;
  }
};
/**
 * @since 1.0.0
 */
exports.required = required;
const getCompiler = match => {
  const compile = ast => match[ast._tag](ast, compile);
  return compile;
};
/**
 * @since 1.0.0
 */
exports.getCompiler = getCompiler;
const getTo = ast => {
  if (hasTransformation(ast)) {
    switch (ast._tag) {
      case "Declaration":
        return createDeclaration(ast.typeParameters.map(getTo), getTo(ast.type), ast.decode, ast.annotations);
      case "Tuple":
        return createTuple(ast.elements.map(e => ({
          ...e,
          type: getTo(e.type)
        })), O.map(ast.rest, RA.mapNonEmpty(getTo)), ast.isReadonly, ast.annotations);
      case "TypeLiteral":
        return createTypeLiteral(ast.propertySignatures.map(p => ({
          ...p,
          type: getTo(p.type)
        })), ast.indexSignatures.map(is => ({
          ...is,
          type: getTo(is.type)
        })), ast.annotations);
      case "Union":
        return createUnion(ast.types.map(getTo), ast.annotations);
      case "Lazy":
        return createLazy(() => getTo(ast.f()), ast.annotations);
      case "Refinement":
        return createRefinement(ast.to, ast.to, ast.decode, ast.decode, ast.annotations);
      case "Transform":
        return ast.to;
    }
  }
  return ast;
};
/**
 * @since 1.0.0
 */
exports.getTo = getTo;
const getFrom = ast => {
  if (hasTransformation(ast)) {
    switch (ast._tag) {
      case "Declaration":
        return createDeclaration(ast.typeParameters.map(getFrom), getFrom(ast.type), ast.decode, ast.annotations);
      case "Tuple":
        return createTuple(ast.elements.map(e => ({
          ...e,
          type: getFrom(e.type)
        })), O.map(ast.rest, RA.mapNonEmpty(getFrom)), ast.isReadonly);
      case "TypeLiteral":
        return createTypeLiteral(ast.propertySignatures.map(p => ({
          ...p,
          type: getFrom(p.type)
        })), ast.indexSignatures.map(is => ({
          ...is,
          type: getFrom(is.type)
        })));
      case "Union":
        return createUnion(ast.types.map(getFrom));
      case "Lazy":
        return createLazy(() => getFrom(ast.f()));
      case "Refinement":
      case "Transform":
        return getFrom(ast.from);
    }
  }
  return ast;
};
/**
 * @since 1.0.0
 */
exports.getFrom = getFrom;
const reverse = ast => {
  if (hasTransformation(ast)) {
    switch (ast._tag) {
      case "Declaration":
        return createDeclaration(ast.typeParameters.map(reverse), ast.type, ast.decode, ast.annotations);
      case "Tuple":
        return createTuple(ast.elements.map(e => ({
          ...e,
          type: reverse(e.type)
        })), O.map(ast.rest, RA.mapNonEmpty(reverse)), ast.isReadonly);
      case "TypeLiteral":
        return createTypeLiteral(ast.propertySignatures.map(p => ({
          ...p,
          type: reverse(p.type)
        })), ast.indexSignatures.map(is => ({
          ...is,
          type: reverse(is.type)
        })));
      case "Union":
        return createUnion(ast.types.map(reverse));
      case "Lazy":
        return createLazy(() => reverse(ast.f()));
      case "Refinement":
        return createRefinement(reverse(ast.to), reverse(ast.from), ast.encode, ast.decode);
      case "Transform":
        return createTransform(reverse(ast.to), reverse(ast.from), ast.encode, ast.decode);
    }
  }
  return ast;
};
// -------------------------------------------------------------------------------------
// internal
// -------------------------------------------------------------------------------------
/** @internal */
exports.reverse = reverse;
const _getCardinality = ast => {
  switch (ast._tag) {
    case "Declaration":
      return _getCardinality(ast.type);
    case "NeverKeyword":
      return 0;
    case "Literal":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "UniqueSymbol":
      return 1;
    case "BooleanKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
    case "ObjectKeyword":
      return 4;
    case "UnknownKeyword":
    case "AnyKeyword":
      return 6;
    case "Refinement":
    case "Transform":
      return _getCardinality(ast.to);
    default:
      return 5;
  }
};
exports._getCardinality = _getCardinality;
const sortByCardinalityAsc = /*#__PURE__*/RA.sort( /*#__PURE__*/(0, _Function.pipe)(Number.Order, /*#__PURE__*/Order.contramap(({
  type
}) => _getCardinality(type))));
/** @internal */
const _getWeight = ast => {
  switch (ast._tag) {
    case "Declaration":
      return _getWeight(ast.type);
    case "Tuple":
      return ast.elements.length + (O.isSome(ast.rest) ? ast.rest.value.length : 0);
    case "TypeLiteral":
      {
        const out = ast.propertySignatures.length + ast.indexSignatures.length;
        return out === 0 ? -2 : out;
      }
    case "Union":
      return ast.types.reduce((n, member) => n + _getWeight(member), 0);
    case "Lazy":
      return 10;
    case "Refinement":
    case "Transform":
      return _getWeight(ast.to);
    case "ObjectKeyword":
      return -1;
    case "UnknownKeyword":
    case "AnyKeyword":
      return -2;
    default:
      return 0;
  }
};
/** @internal */
exports._getWeight = _getWeight;
const sortByWeightDesc = /*#__PURE__*/RA.sort( /*#__PURE__*/Order.reverse( /*#__PURE__*/Order.contramap(Number.Order, _getWeight)));
exports.sortByWeightDesc = sortByWeightDesc;
const unify = candidates => {
  let out = (0, _Function.pipe)(candidates, RA.flatMap(ast => {
    switch (ast._tag) {
      case "NeverKeyword":
        return [];
      case "Union":
        return ast.types;
      default:
        return [ast];
    }
  }));
  if (out.some(isAnyKeyword)) {
    return [anyKeyword];
  }
  if (out.some(isUnknownKeyword)) {
    return [unknownKeyword];
  }
  let i;
  if ((i = out.findIndex(isStringKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isStringKeyword(m) && !(isLiteral(m) && typeof m.literal === "string"));
  }
  if ((i = out.findIndex(isNumberKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isNumberKeyword(m) && !(isLiteral(m) && typeof m.literal === "number"));
  }
  if ((i = out.findIndex(isBooleanKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isBooleanKeyword(m) && !(isLiteral(m) && typeof m.literal === "boolean"));
  }
  if ((i = out.findIndex(isBigIntKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isBigIntKeyword(m) && !(isLiteral(m) && typeof m.literal === "bigint"));
  }
  if ((i = out.findIndex(isSymbolKeyword)) !== -1) {
    out = out.filter((m, j) => j === i || !isSymbolKeyword(m) && !isUniqueSymbol(m));
  }
  return out;
};
/** @internal */
const _getParameterKeyof = ast => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return _getParameterKeyof(ast.to);
  }
  return neverKeyword;
};
exports._getParameterKeyof = _getParameterKeyof;
const _keyof = ast => {
  switch (ast._tag) {
    case "Declaration":
      return _keyof(ast.type);
    case "NeverKeyword":
    case "AnyKeyword":
      return [stringKeyword, numberKeyword, symbolKeyword];
    case "StringKeyword":
      return [createLiteral("length")];
    case "TypeLiteral":
      return ast.propertySignatures.map(p => typeof p.name === "symbol" ? createUniqueSymbol(p.name) : createLiteral(p.name)).concat(ast.indexSignatures.map(is => _getParameterKeyof(is.parameter)));
    case "Union":
      {
        return _getPropertySignatures(ast).map(p => typeof p.name === "symbol" ? createUniqueSymbol(p.name) : createLiteral(p.name));
      }
    case "Lazy":
      return _keyof(ast.f());
    case "Refinement":
    case "Transform":
      return _keyof(ast.to);
    default:
      return [];
  }
};
/** @internal */
const _getPropertySignatures = ast => {
  switch (ast._tag) {
    case "Declaration":
      return _getPropertySignatures(ast.type);
    case "Tuple":
      return ast.elements.map((element, i) => createPropertySignature(i, element.type, element.isOptional, ast.isReadonly));
    case "TypeLiteral":
      return ast.propertySignatures;
    case "Union":
      {
        const propertySignatures = ast.types.map(_getPropertySignatures);
        return (0, _Function.pipe)(propertySignatures[0], RA.filterMap(({
          name
        }) => {
          if (propertySignatures.every(ps => ps.some(p => p.name === name))) {
            const members = (0, _Function.pipe)(propertySignatures, RA.flatMap(ps => ps.filter(p => p.name === name)));
            return O.some(createPropertySignature(name, createUnion(members.map(p => p.type)), members.some(p => p.isOptional), members.some(p => p.isReadonly)));
          }
          return O.none();
        }));
      }
    case "Lazy":
      return _getPropertySignatures(ast.f());
    case "Refinement":
      throw new Error("cannot compute property signatures for refinements");
    case "Transform":
      throw new Error("cannot compute property signatures for transformations");
    default:
      return [];
  }
};
exports._getPropertySignatures = _getPropertySignatures;
//# sourceMappingURL=AST.js.map