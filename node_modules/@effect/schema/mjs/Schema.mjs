/**
 * @since 1.0.0
 */
import * as B from "@effect/data/Bigint";
import { RefinedConstructorsTypeId } from "@effect/data/Brand";
import * as C from "@effect/data/Chunk";
import * as D from "@effect/data/Data";
import { untracedMethod } from "@effect/data/Debug";
import * as E from "@effect/data/Either";
import * as Equal from "@effect/data/Equal";
import { dual, identity, pipe } from "@effect/data/Function";
import * as N from "@effect/data/Number";
import * as O from "@effect/data/Option";
import { isDate } from "@effect/data/Predicate";
import * as RA from "@effect/data/ReadonlyArray";
import * as AST from "@effect/schema/AST";
import * as I from "@effect/schema/internal/common";
import * as P from "@effect/schema/Parser";
import * as PR from "@effect/schema/ParseResult";
import { formatErrors } from "@effect/schema/TreeFormatter";
/**
 * @since 1.0.0
 */
export const from = schema => make(AST.getFrom(schema.ast));
/**
 * @since 1.0.0
 */
export const to = schema => make(AST.getTo(schema.ast));
/**
 * @since 1.0.0
 */
export const reverse = schema => make(AST.reverse(schema.ast));
/* c8 ignore start */
export {
/**
 * @category validation
 * @since 1.0.0
 */
asserts,
/**
 * @category decoding
 * @since 1.0.0
 */
decode,
/**
 * @category decoding
 * @since 1.0.0
 */
decodeEffect,
/**
 * @category decoding
 * @since 1.0.0
 */
decodeEither,
/**
 * @category decoding
 * @since 1.0.0
 */
decodeOption,
/**
 * @category decoding
 * @since 1.0.0
 */
decodePromise,
/**
 * @category decoding
 * @since 1.0.0
 */
decodeResult,
/**
 * @category encoding
 * @since 1.0.0
 */
encode,
/**
 * @category encoding
 * @since 1.0.0
 */
encodeEffect,
/**
 * @category encoding
 * @since 1.0.0
 */
encodeEither,
/**
 * @category encoding
 * @since 1.0.0
 */
encodeOption,
/**
 * @category encoding
 * @since 1.0.0
 */
encodePromise,
/**
 * @category encoding
 * @since 1.0.0
 */
encodeResult,
/**
 * @category validation
 * @since 1.0.0
 */
is,
/**
 * @category parsing
 * @since 1.0.0
 */
parse,
/**
 * @category parsing
 * @since 1.0.0
 */
parseEffect,
/**
 * @category parsing
 * @since 1.0.0
 */
parseEither,
/**
 * @category parsing
 * @since 1.0.0
 */
parseOption,
/**
 * @category parsing
 * @since 1.0.0
 */
parsePromise,
/**
 * @category parsing
 * @since 1.0.0
 */
parseResult,
/**
 * @category validation
 * @since 1.0.0
 */
validate,
/**
 * @category validation
 * @since 1.0.0
 */
validateEffect,
/**
 * @category validation
 * @since 1.0.0
 */
validateEither,
/**
 * @category validation
 * @since 1.0.0
 */
validateOption,
/**
 * @category validation
 * @since 1.0.0
 */
validatePromise,
/**
 * @category validation
 * @since 1.0.0
 */
validateResult } from "@effect/schema/Parser";
/* c8 ignore end */
// ---------------------------------------------
// constructors
// ---------------------------------------------
/**
 * @category constructors
 * @since 1.0.0
 */
export const make = I.makeSchema;
const makeLiteral = value => make(AST.createLiteral(value));
/**
 * @category constructors
 * @since 1.0.0
 */
export const literal = (...literals) => union(...literals.map(literal => makeLiteral(literal)));
/**
 * @category constructors
 * @since 1.0.0
 */
export const uniqueSymbol = (symbol, annotations) => make(AST.createUniqueSymbol(symbol, annotations));
/**
 * @category constructors
 * @since 1.0.0
 */
export const enums = enums => make(AST.createEnums(Object.keys(enums).filter(key => typeof enums[enums[key]] !== "number").map(key => [key, enums[key]])));
/**
 * @category constructors
 * @since 1.0.0
 */
export const templateLiteral = (...[head, ...tail]) => {
  let types = getTemplateLiterals(head.ast);
  for (const span of tail) {
    types = pipe(types, RA.flatMap(a => getTemplateLiterals(span.ast).map(b => combineTemplateLiterals(a, b))));
  }
  return make(AST.createUnion(types));
};
const combineTemplateLiterals = (a, b) => {
  if (AST.isLiteral(a)) {
    return AST.isLiteral(b) ? AST.createLiteral(String(a.literal) + String(b.literal)) : AST.createTemplateLiteral(String(a.literal) + b.head, b.spans);
  }
  if (AST.isLiteral(b)) {
    return AST.createTemplateLiteral(a.head, pipe(a.spans, RA.modifyNonEmptyLast(span => ({
      ...span,
      literal: span.literal + String(b.literal)
    }))));
  }
  return AST.createTemplateLiteral(a.head, pipe(a.spans, RA.modifyNonEmptyLast(span => ({
    ...span,
    literal: span.literal + String(b.head)
  })), RA.appendAll(b.spans)));
};
const getTemplateLiterals = ast => {
  switch (ast._tag) {
    case "Literal":
      return [ast];
    case "NumberKeyword":
    case "StringKeyword":
      return [AST.createTemplateLiteral("", [{
        type: ast,
        literal: ""
      }])];
    case "Union":
      return pipe(ast.types, RA.flatMap(getTemplateLiterals));
    default:
      throw new Error(`Unsupported template literal span ${ast._tag}`);
  }
};
/**
  @category combinators
  @since 1.0.0
*/
export const declare = (typeParameters, type, decode, annotations) => make(AST.createDeclaration(typeParameters.map(tp => tp.ast), type.ast, (...typeParameters) => decode(...typeParameters.map(make)), annotations));
// ---------------------------------------------
// combinators
// ---------------------------------------------
/**
 * @category combinators
 * @since 1.0.0
 */
export const union = (...members) => make(AST.createUnion(members.map(m => m.ast)));
/**
 * @category combinators
 * @since 1.0.0
 */
export const nullable = self => union(_null, self);
/**
 * @category combinators
 * @since 1.0.0
 */
export const keyof = schema => make(AST.keyof(schema.ast));
/**
 * @category combinators
 * @since 1.0.0
 */
export const tuple = (...elements) => make(AST.createTuple(elements.map(schema => AST.createElement(schema.ast, false)), O.none(), true));
/**
 * @category combinators
 * @since 1.0.0
 */
export const rest = rest => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendRestElement(self.ast, rest.ast));
  }
  throw new Error("`rest` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const element = element => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendElement(self.ast, AST.createElement(element.ast, false)));
  }
  throw new Error("`element` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const optionalElement = element => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendElement(self.ast, AST.createElement(element.ast, true)));
  }
  throw new Error("`optionalElement` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const array = item => make(AST.createTuple([], O.some([item.ast]), true));
/**
 * @category combinators
 * @since 1.0.0
 */
export const nonEmptyArray = item => pipe(tuple(item), rest(item));
/**
 * @since 1.0.0
 */
export const OptionalSchemaId = /*#__PURE__*/Symbol.for("@effect/schema/Schema/OptionalSchema");
const isOptionalSchema = schema => "_id" in schema && schema["_id"] === OptionalSchemaId;
/**
 * @since 1.0.0
 */
export const optional = schema => {
  const out = make(schema.ast);
  out["_id"] = OptionalSchemaId;
  return out;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const struct = fields => make(AST.createTypeLiteral(I.ownKeys(fields).map(key => AST.createPropertySignature(key, fields[key].ast, isOptionalSchema(fields[key]), true)), []));
/**
 * @category combinators
 * @since 1.0.0
 */
export const pick = (...keys) => self => make(AST.pick(self.ast, keys));
/**
 * @category combinators
 * @since 1.0.0
 */
export const omit = (...keys) => self => make(AST.omit(self.ast, keys));
/**
 * Returns an object containing all property signatures of a given schema.
 *
 * ```
 * Schema<A> -> { [K in keyof A]: Schema<A[K]> }
 * ```
 *
 * @param schema - The schema to extract property signatures from.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const Person = S.struct({
 *   name: S.string,
 *   age: S.number
 * })
 *
 * const shape = S.getPropertySignatures(Person)
 *
 * assert.deepStrictEqual(shape.name, S.string)
 * assert.deepStrictEqual(shape.age, S.number)
 *
 * @since 1.0.0
 */
export const getPropertySignatures = schema => {
  const out = {};
  const propertySignatures = AST._getPropertySignatures(schema.ast);
  for (const propertySignature of propertySignatures) {
    out[propertySignature.name] = make(propertySignature.type);
  }
  return out;
};
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "@effect/data/Function"
 *
 * const Int = pipe(S.number, S.int(), S.brand("Int"))
 * type Int = S.To<typeof Int> // number & Brand<"Int">
 *
 * @category combinators
 * @since 1.0.0
 */
export const brand = (brand, options) => self => {
  const annotations = toAnnotations(options);
  annotations[AST.BrandAnnotationId] = [...getBrands(self.ast), brand];
  const ast = AST.mergeAnnotations(self.ast, annotations);
  const schema = make(ast);
  const validate = P.validate(schema);
  const validateOption = P.validateOption(schema);
  const validateEither = P.validateEither(schema);
  const is = P.is(schema);
  const out = Object.assign(input => validate(input), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    ast,
    option: input => validateOption(input),
    either: input => E.mapLeft(validateEither(input), e => [{
      meta: input,
      message: formatErrors(e.errors)
    }]),
    refine: input => is(input)
  });
  return out;
};
const getBrands = ast => ast.annotations[AST.BrandAnnotationId] || [];
/**
 * @category combinators
 * @since 1.0.0
 */
export const partial = self => make(AST.partial(self.ast));
/**
 * @category combinators
 * @since 1.0.0
 */
export const required = self => make(AST.required(self.ast));
/**
 * @category combinators
 * @since 1.0.0
 */
export const record = (key, value) => make(AST.createRecord(key.ast, value.ast, true));
const isOverlappingPropertySignatures = (x, y) => x.propertySignatures.some(px => y.propertySignatures.some(py => px.name === py.name));
const isOverlappingIndexSignatures = (x, y) => x.indexSignatures.some(ix => y.indexSignatures.some(iy => {
  const keyofx = AST._getParameterKeyof(ix.parameter);
  const keyofy = AST._getParameterKeyof(iy.parameter);
  // there cannot be two string index signatures or two symbol index signatures at the same time
  return AST.isStringKeyword(keyofx) && AST.isStringKeyword(keyofy) || AST.isSymbolKeyword(keyofx) && AST.isSymbolKeyword(keyofy);
}));
const intersectUnionMembers = (xs, ys) => {
  if (xs.every(AST.isTypeLiteral) && ys.every(AST.isTypeLiteral)) {
    return AST.createUnion(xs.flatMap(x => ys.map(y => {
      if (isOverlappingPropertySignatures(x, y)) {
        throw new Error("`extend` cannot handle overlapping property signatures");
      }
      if (isOverlappingIndexSignatures(x, y)) {
        throw new Error("`extend` cannot handle overlapping index signatures");
      }
      return AST.createTypeLiteral(x.propertySignatures.concat(y.propertySignatures), x.indexSignatures.concat(y.indexSignatures));
    })));
  }
  throw new Error("`extend` can only handle type literals or unions of type literals");
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const extend = that => self => make(intersectUnionMembers(AST.isUnion(self.ast) ? self.ast.types : [self.ast], AST.isUnion(that.ast) ? that.ast.types : [that.ast]));
/**
 * @category combinators
 * @since 1.0.0
 */
export const lazy = (f, annotations) => make(AST.createLazy(() => f().ast, annotations));
const toAnnotations = options => {
  const annotations = {};
  if (options?.typeId !== undefined) {
    const typeId = options?.typeId;
    if (typeof typeId === "object") {
      annotations[AST.TypeAnnotationId] = typeId.id;
      annotations[typeId.id] = typeId.params;
    } else {
      annotations[AST.TypeAnnotationId] = typeId;
    }
  }
  if (options?.message !== undefined) {
    annotations[AST.MessageAnnotationId] = options?.message;
  }
  if (options?.identifier !== undefined) {
    annotations[AST.IdentifierAnnotationId] = options?.identifier;
  }
  if (options?.title !== undefined) {
    annotations[AST.TitleAnnotationId] = options?.title;
  }
  if (options?.description !== undefined) {
    annotations[AST.DescriptionAnnotationId] = options?.description;
  }
  if (options?.examples !== undefined) {
    annotations[AST.ExamplesAnnotationId] = options?.examples;
  }
  if (options?.documentation !== undefined) {
    annotations[AST.DocumentationAnnotationId] = options?.documentation;
  }
  if (options?.jsonSchema !== undefined) {
    annotations[AST.JSONSchemaAnnotationId] = options?.jsonSchema;
  }
  return annotations;
};
export function filter(predicate, options) {
  return self => {
    const decode = a => predicate(a) ? PR.success(a) : PR.failure(PR.type(ast, a));
    const ast = AST.createRefinement(self.ast, AST.getTo(self.ast), decode, decode, toAnnotations(options));
    return make(ast);
  };
}
/**
  Create a new `Schema` by transforming the input and output of an existing `Schema`
  using the provided decoding functions.

  @category combinators
  @since 1.0.0
 */
export const transformResult = /*#__PURE__*/dual(4, (from, to, decode, encode) => make(AST.createTransform(from.ast, to.ast, decode, encode)));
/**
  Create a new `Schema` by transforming the input and output of an existing `Schema`
  using the provided mapping functions.

  @category combinators
  @since 1.0.0
*/
export const transform = /*#__PURE__*/dual(4, (from, to, decode, encode) => transformResult(from, to, a => E.right(decode(a)), b => E.right(encode(b))));
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "@effect/data/Function"
 *
 * const Circle = S.struct({ radius: S.number })
 * const Square = S.struct({ sideLength: S.number })
 * const Shape = S.union(
 *   pipe(Circle, S.attachPropertySignature("kind", "circle")),
 *   pipe(Square, S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decode(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
export const attachPropertySignature = (key, value) => schema => transform(schema, pipe(to(schema), extend(struct({
  [key]: literal(value)
}))), a => ({
  ...a,
  [key]: value
}), ({
  [key]: _key,
  ...rest
}) => rest);
// ---------------------------------------------
// annotations
// ---------------------------------------------
/**
 * @category combinators
 * @since 1.0.0
 */
export const annotations = annotations => self => make(AST.mergeAnnotations(self.ast, annotations));
/**
 * @category annotations
 * @since 1.0.0
 */
export const message = message => self => make(AST.setAnnotation(self.ast, AST.MessageAnnotationId, message));
/**
 * @category annotations
 * @since 1.0.0
 */
export const identifier = identifier => self => make(AST.setAnnotation(self.ast, AST.IdentifierAnnotationId, identifier));
/**
 * @category annotations
 * @since 1.0.0
 */
export const title = title => self => make(AST.setAnnotation(self.ast, AST.TitleAnnotationId, title));
/**
 * @category annotations
 * @since 1.0.0
 */
export const description = description => self => make(AST.setAnnotation(self.ast, AST.DescriptionAnnotationId, description));
/**
 * @category annotations
 * @since 1.0.0
 */
export const examples = examples => self => make(AST.setAnnotation(self.ast, AST.ExamplesAnnotationId, examples));
/**
 * @category annotations
 * @since 1.0.0
 */
export const documentation = documentation => self => make(AST.setAnnotation(self.ast, AST.DocumentationAnnotationId, documentation));
// ---------------------------------------------
// data
// ---------------------------------------------
const _undefined = /*#__PURE__*/make(AST.undefinedKeyword);
const _void = /*#__PURE__*/make(AST.voidKeyword);
const _null = /*#__PURE__*/make( /*#__PURE__*/AST.createLiteral(null));
export {
/**
 * @category primitives
 * @since 1.0.0
 */
_null as null,
/**
 * @category primitives
 * @since 1.0.0
 */
_undefined as undefined,
/**
 * @category primitives
 * @since 1.0.0
 */
_void as void };
/**
 * @category primitives
 * @since 1.0.0
 */
export const never = /*#__PURE__*/make(AST.neverKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const unknown = /*#__PURE__*/make(AST.unknownKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const any = /*#__PURE__*/make(AST.anyKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const string = /*#__PURE__*/make(AST.stringKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const number = /*#__PURE__*/make(AST.numberKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const boolean = /*#__PURE__*/make(AST.booleanKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const bigint = /*#__PURE__*/make(AST.bigIntKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const symbol = /*#__PURE__*/make(AST.symbolKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const object = /*#__PURE__*/make(AST.objectKeyword);
// ---------------------------------------------
// data/Bigint
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanBigintTypeId = "@effect/schema/GreaterThanBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const greaterThanBigint = (min, options) => self => pipe(self, filter(a => a > min, {
  typeId: GreaterThanBigintTypeId,
  description: `a bigint greater than ${min}n`,
  jsonSchema: {
    exclusiveMinimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanOrEqualToBigintTypeId = "@effect/schema/GreaterThanOrEqualToBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const greaterThanOrEqualToBigint = (min, options) => self => pipe(self, filter(a => a >= min, {
  typeId: GreaterThanOrEqualToBigintTypeId,
  description: `a bigint greater than or equal to ${min}n`,
  jsonSchema: {
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanBigintTypeId = "@effect/schema/LessThanBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const lessThanBigint = (max, options) => self => pipe(self, filter(a => a < max, {
  typeId: LessThanBigintTypeId,
  description: `a bigint less than ${max}n`,
  jsonSchema: {
    exclusiveMaximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanOrEqualToBigintTypeId = "@effect/schema/LessThanOrEqualToBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const lessThanOrEqualToBigint = (max, options) => self => pipe(self, filter(a => a <= max, {
  typeId: LessThanOrEqualToBigintTypeId,
  description: `a bigint less than or equal to ${max}n`,
  jsonSchema: {
    maximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const BetweenBigintTypeId = "@effect/schema/BetweenBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const betweenBigint = (min, max, options) => self => pipe(self, filter(a => a >= min && a <= max, {
  typeId: BetweenBigintTypeId,
  description: `a bigint between ${min}n and ${max}n`,
  jsonSchema: {
    maximum: max,
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const PositiveBigintTypeId = "@effect/schema/PositiveBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const positiveBigint = options => greaterThanBigint(0n, {
  typeId: PositiveBigintTypeId,
  description: "a positive bigint",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
export const NegativeBigintTypeId = "@effect/schema/NegativeBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const negativeBigint = options => lessThanBigint(0n, {
  typeId: NegativeBigintTypeId,
  description: "a negative bigint",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
export const NonNegativeBigintTypeId = "@effect/schema/NonNegativeBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const nonNegativeBigint = options => greaterThanOrEqualToBigint(0n, {
  typeId: NonNegativeBigintTypeId,
  description: "a non-negative bigint",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
export const NonPositiveBigintTypeId = "@effect/schema/NonPositiveBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export const nonPositiveBigint = options => lessThanOrEqualToBigint(0n, {
  typeId: NonPositiveBigintTypeId,
  description: "a non-positive bigint",
  ...options
});
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint
 * @since 1.0.0
 */
export const clampBigint = (min, max) => self => transform(self, pipe(self, to, betweenBigint(min, max)), self => B.clamp(self, min, max), identity);
// ---------------------------------------------
// data/Brand
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
export const BrandTypeId = "@effect/schema/BrandTypeId";
/**
 * @category combinators
 * @since 1.0.0
 */
export const fromBrand = (constructor, options) => self => {
  const decode = untracedMethod(() => a => E.mapLeft(constructor.either(a), brandErrors => PR.parseError([PR.type(ast, a, brandErrors.map(v => v.message).join(", "))])));
  const ast = AST.createRefinement(self.ast, AST.getTo(self.ast), decode, decode, toAnnotations({
    typeId: BrandTypeId,
    ...options
  }));
  return make(ast);
};
// ---------------------------------------------
// data/Chunk
// ---------------------------------------------
const chunkArbitrary = item => fc => fc.array(item(fc)).map(C.fromIterable);
const chunkPretty = item => c => `Chunk(${C.toReadonlyArray(c).map(item).join(", ")})`;
/**
 * @category constructors
 * @since 1.0.0
 */
export const chunkFromSelf = item => {
  const schema = declare([item], struct({
    _id: uniqueSymbol(Symbol.for("@effect/data/Chunk")),
    length: number
  }), item => {
    const parse = P.parseResult(array(item));
    return (u, options) => !C.isChunk(u) ? PR.failure(PR.type(schema.ast, u)) : PR.map(parse(C.toReadonlyArray(u), options), C.fromIterable);
  }, {
    [AST.IdentifierAnnotationId]: "Chunk",
    [I.PrettyHookId]: chunkPretty,
    [I.ArbitraryHookId]: chunkArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const chunk = item => transform(array(item), to(chunkFromSelf(item)), C.fromIterable, C.toReadonlyArray);
// ---------------------------------------------
// data/Data
// ---------------------------------------------
const toData = a => Array.isArray(a) ? D.array(a) : D.struct(a);
const dataArbitrary = item => fc => item(fc).map(toData);
const dataPretty = item => d => `Data(${item(d)})`;
/**
 * @category combinators
 * @since 1.0.0
 */
export const dataFromSelf = item => {
  const schema = declare([item], item, item => {
    const parse = P.parseResult(item);
    return (u, options) => !Equal.isEqual(u) ? PR.failure(PR.type(schema.ast, u)) : PR.map(parse(u, options), toData);
  }, {
    [AST.IdentifierAnnotationId]: "Data",
    [I.PrettyHookId]: dataPretty,
    [I.ArbitraryHookId]: dataArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const data = item => transform(item, to(dataFromSelf(item)), toData, a => Array.isArray(a) ? Array.from(a) : Object.assign({}, a));
// ---------------------------------------------
// data/Date
// ---------------------------------------------
const dateArbitrary = () => fc => fc.date();
const datePretty = () => date => `new Date(${JSON.stringify(date)})`;
/**
 * @category constructors
 * @since 1.0.0
 */
export const date = /*#__PURE__*/declare([], /*#__PURE__*/struct({}), () => u => !isDate(u) ? PR.failure(PR.type(date.ast, u)) : PR.success(u), {
  [AST.IdentifierAnnotationId]: "Date",
  [I.PrettyHookId]: datePretty,
  [I.ArbitraryHookId]: dateArbitrary
});
/**
  Transforms a `string` into a `Date` by parsing the string using `Date.parse`.

  @category date
  @since 1.0.0
*/
export const dateFromString = /*#__PURE__*/transformResult(string, date, s => {
  const n = Date.parse(s);
  return isNaN(n) ? PR.failure(PR.type(dateFromString.ast, s)) : PR.success(new Date(n));
}, n => PR.success(n.toISOString()));
// ---------------------------------------------
// data/Either
// ---------------------------------------------
const eitherArbitrary = (left, right) => fc => fc.oneof(left(fc).map(E.left), right(fc).map(E.right));
const eitherPretty = (left, right) => E.match(e => `left(${left(e)})`, a => `right(${right(a)})`);
const eitherInline = (left, right) => union(struct({
  _tag: literal("Left"),
  left
}), struct({
  _tag: literal("Right"),
  right
}));
/**
 * @category combinators
 * @since 1.0.0
 */
export const eitherFromSelf = (left, right) => {
  const schema = declare([left, right], eitherInline(left, right), (left, right) => {
    const parseLeft = P.parseResult(left);
    const parseRight = P.parseResult(right);
    return (u, options) => !E.isEither(u) ? PR.failure(PR.type(schema.ast, u)) : E.isLeft(u) ? PR.map(parseLeft(u.left, options), E.left) : PR.map(parseRight(u.right, options), E.right);
  }, {
    [AST.IdentifierAnnotationId]: "Either",
    [I.PrettyHookId]: eitherPretty,
    [I.ArbitraryHookId]: eitherArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const either = (left, right) => transform(eitherInline(left, right), to(eitherFromSelf(left, right)), a => a._tag === "Left" ? E.left(a.left) : E.right(a.right), E.match(left => ({
  _tag: "Left",
  left
}), right => ({
  _tag: "Right",
  right
})));
const arbitraryJson = fc => fc.jsonValue().map(json => json);
/**
 * @category constructors
 * @since 1.0.0
 */
export const json = /*#__PURE__*/lazy(() => union(_null, string, number, boolean, array(json), record(string, json)), {
  [I.ArbitraryHookId]: () => arbitraryJson
});
// ---------------------------------------------
// data/Number
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
export const FiniteTypeId = "@effect/schema/FiniteTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const finite = options => self => pipe(self, filter(a => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanTypeId = "@effect/schema/GreaterThanTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const greaterThan = (min, options) => self => pipe(self, filter(a => a > min, {
  typeId: GreaterThanTypeId,
  description: `a number greater than ${min}`,
  jsonSchema: {
    exclusiveMinimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanOrEqualToTypeId = "@effect/schema/GreaterThanOrEqualToTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const greaterThanOrEqualTo = (min, options) => self => pipe(self, filter(a => a >= min, {
  typeId: GreaterThanOrEqualToTypeId,
  description: `a number greater than or equal to ${min}`,
  jsonSchema: {
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const MultipleOfTypeId = "@effect/schema/MultipleOfTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const multipleOf = (divisor, options) => self => pipe(self, filter(a => N.remainder(a, divisor) === 0, {
  typeId: MultipleOfTypeId,
  description: `a number divisible by ${divisor}`,
  jsonSchema: {
    multipleOf: Math.abs(divisor)
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const IntTypeId = "@effect/schema/IntTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const int = options => self => pipe(self, filter(a => Number.isInteger(a), {
  typeId: IntTypeId,
  description: "integer",
  jsonSchema: {
    type: "integer"
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanTypeId = "@effect/schema/LessThanTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const lessThan = (max, options) => self => pipe(self, filter(a => a < max, {
  typeId: LessThanTypeId,
  description: `a number less than ${max}`,
  jsonSchema: {
    exclusiveMaximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanOrEqualToTypeId = "@effect/schema/LessThanOrEqualToTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const lessThanOrEqualTo = (max, options) => self => pipe(self, filter(a => a <= max, {
  typeId: LessThanOrEqualToTypeId,
  description: `a number less than or equal to ${max}`,
  jsonSchema: {
    maximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const BetweenTypeId = "@effect/schema/BetweenTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const between = (min, max, options) => self => pipe(self, filter(a => a >= min && a <= max, {
  typeId: BetweenTypeId,
  description: `a number between ${min} and ${max}`,
  jsonSchema: {
    maximum: max,
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const NonNaNTypeId = "@effect/schema/NonNaNTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const nonNaN = options => self => pipe(self, filter(a => !Number.isNaN(a), {
  typeId: NonNaNTypeId,
  description: "a number NaN excluded",
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const PositiveTypeId = "@effect/schema/PositiveTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const positive = options => greaterThan(0, {
  typeId: PositiveTypeId,
  description: "a positive number",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
export const NegativeTypeId = "@effect/schema/NegativeTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const negative = options => lessThan(0, {
  typeId: NegativeTypeId,
  description: "a negative number",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
export const NonNegativeTypeId = "@effect/schema/NonNegativeTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const nonNegative = options => greaterThanOrEqualTo(0, {
  typeId: NonNegativeTypeId,
  description: "a non-negative number",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
export const NonPositiveTypeId = "@effect/schema/NonPositiveTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export const nonPositive = options => lessThanOrEqualTo(0, {
  typeId: NonPositiveTypeId,
  description: "a non-positive number",
  ...options
});
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number
 * @since 1.0.0
 */
export const clamp = (min, max) => self => transform(self, pipe(self, to, between(min, max)), self => N.clamp(self, min, max), identity);
/**
  Transforms a `string` into a `number` by parsing the string using `parseFloat`.

  The following special string values are supported: "NaN", "Infinity", "-Infinity".

  @category number
  @since 1.0.0
*/
export const numberFromString = self => {
  const schema = transformResult(self, number, s => {
    if (s === "NaN") {
      return PR.success(NaN);
    }
    if (s === "Infinity") {
      return PR.success(Infinity);
    }
    if (s === "-Infinity") {
      return PR.success(-Infinity);
    }
    const n = parseFloat(s);
    return isNaN(n) ? PR.failure(PR.type(schema.ast, s)) : PR.success(n);
  }, n => PR.success(String(n)));
  return schema;
};
// ---------------------------------------------
// data/Object
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
export const InstanceOfTypeId = "@effect/schema/InstanceOfTypeId";
/**
 * @category constructors
 * @since 1.0.0
 */
export const instanceOf = (constructor, options) => {
  const schema = declare([], struct({}), () => input => input instanceof constructor ? PR.success(input) : PR.failure(PR.type(schema.ast, input)), {
    [AST.TypeAnnotationId]: InstanceOfTypeId,
    [InstanceOfTypeId]: {
      constructor
    },
    [AST.DescriptionAnnotationId]: `an instance of ${constructor.name}`,
    ...options
  });
  return schema;
};
// ---------------------------------------------
// data/Option
// ---------------------------------------------
const optionArbitrary = value => fc => fc.oneof(fc.constant(O.none()), value(fc).map(O.some));
const optionPretty = value => O.match(() => "none()", a => `some(${value(a)})`);
const optionInline = value => union(struct({
  _tag: literal("None")
}), struct({
  _tag: literal("Some"),
  value
}));
/**
 * @category combinators
 * @since 1.0.0
 */
export const optionFromSelf = value => {
  const schema = declare([value], optionInline(value), value => {
    const parse = P.parseResult(value);
    return (u, options) => !O.isOption(u) ? PR.failure(PR.type(schema.ast, u)) : O.isNone(u) ? PR.success(O.none()) : PR.map(parse(u.value, options), O.some);
  }, {
    [AST.IdentifierAnnotationId]: "Option",
    [I.PrettyHookId]: optionPretty,
    [I.ArbitraryHookId]: optionArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const option = value => transform(optionInline(value), to(optionFromSelf(value)), a => a._tag === "None" ? O.none() : O.some(a.value), O.match(() => ({
  _tag: "None"
}), value => ({
  _tag: "Some",
  value
})));
/**
 * @category option
 * @since 1.0.0
 */
export const optionFromNullable = value => transform(union(_undefined, _null, value), to(optionFromSelf(value)), O.fromNullable, O.getOrNull);
/**
 * @category option
 * @since 1.0.0
 */
export const optionsFromOptionals = fields => schema => {
  const ast = schema.ast;
  if (AST.isTypeLiteral(ast) || AST.isTransform(ast)) {
    const ownKeys = I.ownKeys(fields);
    const len = ownKeys.length;
    const from = AST.getFrom(schema.ast);
    const to = AST.getTo(schema.ast);
    if (AST.isTypeLiteral(from) && AST.isTypeLiteral(to)) {
      if (from.propertySignatures.some(px => ownKeys.some(name => px.name === name)) || to.propertySignatures.some(px => ownKeys.some(name => px.name === name))) {
        throw new Error("`optionsFromOptionals` cannot handle overlapping property signatures");
      }
      const decode = AST.isTypeLiteral(ast) ? PR.success : ast.decode;
      const encode = AST.isTypeLiteral(ast) ? PR.success : ast.encode;
      const from2 = AST.createTypeLiteral(from.propertySignatures.concat(ownKeys.map(key => AST.createPropertySignature(key, fields[key].ast, true, true))), from.indexSignatures);
      const to2 = AST.createTypeLiteral(to.propertySignatures.concat(ownKeys.map(key => AST.createPropertySignature(key, optionFromSelf(fields[key]).ast, false, true))), to.indexSignatures);
      const out = AST.createTransform(from2, to2, input => {
        const o = {
          ...input
        };
        const n = {};
        for (let i = 0; i < len; i++) {
          const key = ownKeys[i];
          delete o[key];
          n[key] = O.fromNullable(input[key]);
        }
        return PR.map(decode(o), o => ({
          ...o,
          ...n
        }));
      }, a => {
        const o = {
          ...a
        };
        const n = {};
        for (let i = 0; i < len; i++) {
          const key = ownKeys[i];
          delete o[key];
          if (O.isSome(a[key])) {
            n[key] = a[key].value;
          }
        }
        return PR.map(encode(o), o => ({
          ...o,
          ...n
        }));
      });
      return make(out);
    }
  }
  throw new Error("`optionsFromOptionals` can only handle type literals or transformations between type literals");
};
// ---------------------------------------------
// data/ReadonlyArray
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
export const MinItemsTypeId = "@effect/schema/MinItemsTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export const minItems = (n, options) => self => pipe(self, filter(a => a.length >= n, {
  typeId: MinItemsTypeId,
  description: `an array of at least ${n} items`,
  jsonSchema: {
    minItems: n
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const MaxItemsTypeId = "@effect/schema/MaxItemsTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export const maxItems = (n, options) => self => pipe(self, filter(a => a.length <= n, {
  typeId: MaxItemsTypeId,
  description: `an array of at most ${n} items`,
  jsonSchema: {
    maxItems: n
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const ItemsCountTypeId = "@effect/schema/ItemsCountTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export const itemsCount = (n, options) => self => pipe(self, filter(a => a.length === n, {
  typeId: ItemsCountTypeId,
  description: `an array of exactly ${n} items`,
  jsonSchema: {
    minItems: n,
    maxItems: n
  },
  ...options
}));
// ---------------------------------------------
// data/ReadonlyMap
// ---------------------------------------------
const isMap = u => u instanceof Map;
const readonlyMapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => new Map(as));
const readonlyMapPretty = (key, value) => map => `new Map([${Array.from(map.entries()).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
/**
 * @category constructors
 * @since 1.0.0
 */
export const readonlyMapFromSelf = (key, value) => {
  const schema = declare([key, value], struct({
    size: number
  }), (key, value) => {
    const parse = P.parseResult(array(tuple(key, value)));
    return (u, options) => !isMap(u) ? PR.failure(PR.type(schema.ast, u)) : PR.map(parse(Array.from(u.entries()), options), as => new Map(as));
  }, {
    [AST.IdentifierAnnotationId]: "ReadonlyMap",
    [I.PrettyHookId]: readonlyMapPretty,
    [I.ArbitraryHookId]: readonlyMapArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const readonlyMap = (key, value) => transform(array(tuple(key, value)), to(readonlyMapFromSelf(key, value)), as => new Map(as), map => Array.from(map.entries()));
// ---------------------------------------------
// data/ReadonlySet
// ---------------------------------------------
const isSet = u => u instanceof Set;
const readonlySetArbitrary = item => fc => fc.array(item(fc)).map(as => new Set(as));
const readonlySetPretty = item => set => `new Set([${Array.from(set.values()).map(a => item(a)).join(", ")}])`;
/**
 * @category constructors
 * @since 1.0.0
 */
export const readonlySetFromSelf = item => {
  const schema = declare([item], struct({
    size: number
  }), item => {
    const parse = P.parseResult(array(item));
    return (u, options) => !isSet(u) ? PR.failure(PR.type(schema.ast, u)) : PR.map(parse(Array.from(u.values()), options), as => new Set(as));
  }, {
    [AST.IdentifierAnnotationId]: "ReadonlySet",
    [I.PrettyHookId]: readonlySetPretty,
    [I.ArbitraryHookId]: readonlySetArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const readonlySet = item => transform(array(item), to(readonlySetFromSelf(item)), as => new Set(as), set => Array.from(set));
// ---------------------------------------------
// data/String
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
export const TrimmedTypeId = "@effect/schema/TrimmedTypeId";
const trimmedRegex = /^\S.*\S$|^\S$|^$/;
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string
 * @since 1.0.0
 */
export const trimmed = options => self => pipe(self, filter(a => trimmedRegex.test(a), {
  typeId: TrimmedTypeId,
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    type: "string",
    pattern: trimmedRegex.source
  },
  ...options
}));
/**
 * @category string
 * @since 1.0.0
 */
export const maxLength = (maxLength, options) => self => pipe(self, filter(a => a.length <= maxLength, {
  description: `a string at most ${maxLength} character(s) long`,
  jsonSchema: {
    maxLength
  },
  ...options
}));
/**
 * @category string
 * @since 1.0.0
 */
export const minLength = (minLength, options) => self => pipe(self, filter(a => a.length >= minLength, {
  description: `a string at least ${minLength} character(s) long`,
  jsonSchema: {
    minLength
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const PatternTypeId = "@effect/schema/PatternTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export const pattern = (regex, options) => self => {
  const pattern = regex.source;
  return pipe(self, filter(a => {
    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    typeId: {
      id: PatternTypeId,
      params: {
        regex
      }
    },
    description: `a string matching the pattern ${pattern}`,
    jsonSchema: {
      pattern
    },
    ...options
  }));
};
/**
 * @category type id
 * @since 1.0.0
 */
export const StartsWithTypeId = "@effect/schema/StartsWithTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export const startsWith = (startsWith, options) => self => pipe(self, filter(a => a.startsWith(startsWith), {
  typeId: {
    id: StartsWithTypeId,
    params: {
      startsWith
    }
  },
  description: `a string starting with ${JSON.stringify(startsWith)}`,
  jsonSchema: {
    pattern: `^${startsWith}`
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const EndsWithTypeId = "@effect/schema/EndsWithTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export const endsWith = (endsWith, options) => self => pipe(self, filter(a => a.endsWith(endsWith), {
  typeId: {
    id: EndsWithTypeId,
    params: {
      endsWith
    }
  },
  description: `a string ending with ${JSON.stringify(endsWith)}`,
  jsonSchema: {
    pattern: `^.*${endsWith}$`
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const IncludesTypeId = "@effect/schema/IncludesTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export const includes = (searchString, options) => self => pipe(self, filter(a => a.includes(searchString), {
  typeId: {
    id: IncludesTypeId,
    params: {
      includes: searchString
    }
  },
  description: `a string including ${JSON.stringify(searchString)}`,
  jsonSchema: {
    pattern: `.*${searchString}.*`
  },
  ...options
}));
/**
 * The `trim` parser allows removing whitespaces from the beginning and end of a string.
 *
 * @category string
 * @since 1.0.0
 */
export const trim = self => transform(self, pipe(to(self), trimmed()), s => s.trim(), identity);
/**
 * @category type id
 * @since 1.0.0
 */
export const UUIDTypeId = "@effect/schema/UUIDTypeId";
const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * @category constructors
 * @since 1.0.0
 */
export const UUID = /*#__PURE__*/pipe(string, /*#__PURE__*/pattern(uuidRegex, {
  typeId: UUIDTypeId
}), /*#__PURE__*/annotations({
  [I.ArbitraryHookId]: () => fc => fc.uuid()
}));
/**
 * @category string
 * @since 1.0.0
 */
export const length = (length, options) => self => minLength(length, options)(maxLength(length)(self));
/**
 * @category string
 * @since 1.0.0
 */
export const nonEmpty = options => minLength(1, options);
//# sourceMappingURL=Schema.mjs.map