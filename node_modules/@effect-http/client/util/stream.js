import * as tsplus_module_1 from "@effect/data/Option";
import * as tsplus_module_2 from "@effect/io/Effect";
import * as tsplus_module_3 from "@effect/stream/Stream";
import * as tsplus_module_4 from "@effect/io/Scope";
import * as tsplus_module_5 from "@effect/io/Exit";
import * as tsplus_module_6 from "@effect/data/Chunk";
export const fromReadableStream = (evaluate) => tsplus_module_3.unwrapScoped(tsplus_module_2.map(tsplus_module_2.acquireRelease(tsplus_module_2.sync(() => evaluate().getReader()), reader => tsplus_module_2.promise(() => reader.cancel())), reader => tsplus_module_3.repeatEffectOption(tsplus_module_2.flatMap(tsplus_module_2.tryCatchPromise(() => reader.read(), _ => tsplus_module_1.some(_)), ({ value, done }) => done ? tsplus_module_2.fail(tsplus_module_1.none()) : tsplus_module_2.succeed(value)))));
export const toReadableStream = (source) => {
    let pull;
    let scope;
    return new ReadableStream({
        start(controller) {
            scope = tsplus_module_2.runSync(tsplus_module_4.make());
            pull = tsplus_module_2.asUnit(tsplus_module_2.catchTag(tsplus_module_2.catchTag(tsplus_module_2.tapErrorCause(tsplus_module_2.tap(tsplus_module_2.runSync(tsplus_module_4.use(tsplus_module_3.toPull(source), scope)), _ => tsplus_module_2.sync(() => {
                tsplus_module_6.forEach(_, _ => {
                    controller.enqueue(_);
                });
            })), () => tsplus_module_4.close(scope, tsplus_module_5.unit())), "None", () => tsplus_module_2.sync(() => {
                controller.close();
            })), "Some", e => tsplus_module_2.sync(() => {
                controller.error(e.value);
            })));
        },
        pull() {
            return tsplus_module_2.runPromise(pull);
        },
        cancel() {
            return tsplus_module_2.runPromise(tsplus_module_4.close(scope, tsplus_module_5.unit()));
        },
    });
};
//# sourceMappingURL=stream.js.map