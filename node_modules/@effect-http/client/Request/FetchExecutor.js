import * as tsplus_module_1 from "@effect/io/Effect";
import * as tsplus_module_2 from "@effect/data/Option";
import * as tsplus_module_3 from "@effect/data/Chunk";
import * as tsplus_module_4 from "@effect/data/Function";
import * as tsplus_module_5 from "@effect-http/client/Request";
import * as tsplus_module_6 from "@effect-http/client/Request/Executor";
import * as tsplus_module_7 from "@effect/io/Layer";
import { RequestError, } from "../Error.js";
import * as response from "../Response.js";
import { toReadableStream } from "../util/stream.js";
import * as executor from "./Executor.js";
/**
 * A request executor that uses the global fetch function.
 *
 * It performs no validation on the response status code.
 *
 * @since 1.0.0
 */
export const fetch = (options = {}) => request => tsplus_module_1.flatMap(tsplus_module_1.tryCatch(() => new URL(request.url), _ => new RequestError(request, _)), url => {
    tsplus_module_3.forEach(request.urlParams, ([key, value]) => {
        url.searchParams.append(key, value);
    });
    const headers = new Headers([...request.headers]);
    const body = tsplus_module_2.getOrUndefined(tsplus_module_2.map(request.body, convertBody));
    return tsplus_module_1.map(tsplus_module_1.tryCatchPromiseInterrupt(signal => globalThis.fetch(url, {
        ...options,
        method: request.method,
        headers,
        body,
        signal,
    }), _ => new RequestError(request, _)), response.fromWeb);
});
/**
 * A request executor that uses the global fetch function.
 *
 * It filters out responses with a status code outside the range 200-299.
 *
 * @since 1.0.0
 */
export const fetchOk = tsplus_module_4.flow(fetch, executor.filterStatusOk);
/**
 * @since 1.0.0
 * @tsplus pipeable effect-http/client/Request fetch
 */
export const fetch_ = fetchOk;
/**
 * A request executor that uses the global fetch function.
 *
 * It sets the Accept header to "application/json" and decodes the response
 * body.
 *
 * @since 1.0.0
 */
export const fetchJson = tsplus_module_4.flow(fetchOk, executor.contramap(_ => tsplus_module_5.acceptJson(_)), executor.mapEffect(_ => _.json));
/**
 * @tsplus pipeable effect-http/client/Request fetchJson
 */
export const fetchJson_ = fetchJson;
/**
 * A request executor that uses the global fetch function.
 *
 * It decodes the response body using the given schema.
 *
 * @since 1.0.0
 */
export const fetchDecode = (schema, options, requestInit) => tsplus_module_6.mapEffect(_ => _.decode(schema, options))(tsplus_module_6.contramap(_ => tsplus_module_5.acceptJson(_))(fetchOk(requestInit)));
/**
 * @tsplus pipeable effect-http/client/Request fetchDecode
 */
export const fetchDecode_ = fetchDecode;
const convertBody = (body) => {
    switch (body._tag) {
        case "FormDataBody":
        case "RawBody":
            return body.value;
        case "StreamBody":
            return toReadableStream(body.value);
    }
};
export const LiveFetchRequestExecutor = tsplus_module_7.succeed(executor.HttpRequestExecutor, { execute: fetch() });
//# sourceMappingURL=FetchExecutor.js.map