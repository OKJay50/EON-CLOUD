import { Effect } from "@effect/io/Effect";
import { Schedule } from "@effect/io/Schedule";
import { Predicate } from "@effect/data/Predicate";
import { RequestError, StatusCodeError } from "../Error.js";
import { Request } from "../Request.js";
import { Response } from "../Response.js";
/**
 * Represents a function that can execute a request.
 *
 * It takes a `Request` and returns an Effect that returns the result.
 *
 * @tsplus type effect-http/client/RequestExecutor
 * @since 1.0.0
 */
export interface RequestExecutor<R, E, A> {
    (request: Request): Effect<R, E, A>;
}
/**
 * Represents a service that can execute a request.
 *
 * Can be used for embedding a RequestExecutor into a Layer.
 *
 * @since 1.0.0
 */
export interface HttpRequestExecutor {
    readonly execute: RequestExecutor<never, RequestError, Response>;
}
/**
 * A tag for the HttpRequestExecutor service.
 *
 * @since 1.0.0
 */
export declare const HttpRequestExecutor: import("@effect/data/Context").Tag<HttpRequestExecutor, HttpRequestExecutor>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor contramap
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const contramap: (f: (a: Request) => Request) => <R, E, A>(self: RequestExecutor<R, E, A>) => RequestExecutor<R, E, A>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor contramapEffect
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const contramapEffect: <R2, E2>(f: (a: Request) => import("../_common.js").Effect<R2, E2, Request>) => <R1, E1, A>(self: RequestExecutor<R1, E1, A>) => RequestExecutor<R2 | R1, E2 | E1, A>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor map
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const map: <A, B>(f: (a: A) => B) => <R, E>(self: RequestExecutor<R, E, A>) => RequestExecutor<R, E, B>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor mapEffect
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const mapEffect: <R2, E2, A, B>(f: (a: A) => import("../_common.js").Effect<R2, E2, B>) => <R1, E1>(self: RequestExecutor<R1, E1, A>) => RequestExecutor<R2 | R1, E2 | E1, B>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor filterStatus
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const filterStatus: (f: (status: number) => boolean) => <R, E>(self: RequestExecutor<R, E, Response>) => RequestExecutor<R, E | StatusCodeError, Response>;
/**
 * @tsplus getter effect-http/client/RequestExecutor filterStatusOk
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const filterStatusOk: <R, E>(self: RequestExecutor<R, E, Response>) => RequestExecutor<R, E | StatusCodeError, Response>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor filterOrElseWith
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const filterOrElseWith: <A, R2, E2, B>(f: Predicate<A>, orElse: (a: A) => import("../_common.js").Effect<R2, E2, B>) => <R, E>(self: RequestExecutor<R, E, A>) => RequestExecutor<R2 | R, E2 | E, A | B>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor retry
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const retry: <R1, E, B>(policy: import("../_common.js").Schedule<R1, E, B>) => <R, A>(self: RequestExecutor<R, E, A>) => RequestExecutor<R1 | R, E, A>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor catchTag
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const catchTag: <K extends E["_tag"] & string, E extends {
    _tag: string;
}, R1, E1, A1>(tag: K, f: (e: Extract<E, {
    _tag: K;
}>) => import("../_common.js").Effect<R1, E1, A1>) => <R, A>(self: RequestExecutor<R, E, A>) => RequestExecutor<R1 | R, E1 | Exclude<E, {
    _tag: K;
}>, A1 | A>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor catchTags
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const catchTags: <E extends {
    _tag: string;
}, Cases extends { [K in E["_tag"]]+?: ((error: Extract<E, {
    _tag: K;
}>) => Effect<any, any, any>) | undefined; }>(cases: Cases) => <R, A>(self: RequestExecutor<R, E, A>) => RequestExecutor<R | { [K_1 in keyof Cases]: Cases[K_1] extends (...args: Array<any>) => import("../_common.js").Effect<infer R_1, any, any> ? R_1 : never; }[keyof Cases], Exclude<E, {
    _tag: keyof Cases;
}> | { [K_2 in keyof Cases]: Cases[K_2] extends (...args: Array<any>) => import("../_common.js").Effect<any, infer E_1, any> ? E_1 : never; }[keyof Cases], A | { [K_3 in keyof Cases]: Cases[K_3] extends (...args: Array<any>) => import("../_common.js").Effect<any, any, infer A_1> ? A_1 : never; }[keyof Cases]>;
/**
 * @tsplus pipeable effect-http/client/RequestExecutor catchAll
 * @tsplus location "@effect-http/client/Request/Executor"
 */
export declare const catchAll: <E, R2, E2, A2>(f: (e: E) => import("../_common.js").Effect<R2, E2, A2>) => <R, A>(self: RequestExecutor<R, E, A>) => RequestExecutor<R2 | R, E2, A2 | A>;
